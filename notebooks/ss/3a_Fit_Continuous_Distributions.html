
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Parametric FDC Estimation &#8212; Streamflow Distribution Estimation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/ss/3a_Fit_Continuous_Distributions';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="Streamflow Distribution Estimation - Home"/>
    <script>document.write(`<img src="../../_static/logo.png" class="logo__image only-dark" alt="Streamflow Distribution Estimation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Introduction
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../1_data.html">Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2_Methods.html">Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_Predict_Runoff_Statistics.html">Predict Runoff Statistics from Catchment Attributes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4_Reference_Distributions.html">Reference Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5_FDC_Estimation.html">FDC Estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6_Large_Sample_Results_Comparison.html">Large Sample Comparison Results</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/dankovacek/divergence_estimation" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/dankovacek/divergence_estimation/issues/new?title=Issue%20on%20page%20%2Fnotebooks/ss/3a_Fit_Continuous_Distributions.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/notebooks/ss/3a_Fit_Continuous_Distributions.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Parametric FDC Estimation</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Parametric FDC Estimation</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#methodology">Methodology</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#general-data-processing-functions">General data processing functions</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#estimate-entropy">Estimate entropy</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#define-a-measurement-error-model">Define a measurement error model</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#id1"></a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-the-noise-added-to-a-discriminant-value-due-to-assuming-an-error-distribution-as-a-prior">Compute the “noise” added to a discriminant value due to assuming an error distribution as a prior</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#pairwise-processing">Pairwise Processing</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#citations">Citations</a></li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="parametric-fdc-estimation">
<h1>Parametric FDC Estimation<a class="headerlink" href="#parametric-fdc-estimation" title="Link to this heading">#</a></h1>
<p>Consider a sequence of methods for estimating the flow duration curve at an unmonitored location. Starting from the simplest method and increasing in complexity.  The goal is to estimate a distribution, then evaluate the expectation of the method over a large sample by computing the divergence between the “true” distribution <span class="math notranslate nohighlight">\(P\)</span> and the corresponding estimate <span class="math notranslate nohighlight">\(Q\)</span>.  Consider several divergences from the class of f-divergences for their unique properties, namely their associated conjugate dual or surrogate loss functions.</p>
<blockquote>
<div><p><strong>Note</strong>: clarify the relationship between individual f-divergences, their conjugate dual functions, and their surrogate loss functions.</p>
</div></blockquote>
<ol class="arabic simple">
<li><p><strong>Naive or maximum uncertainty</strong>: as a baseline, the divergence of a probability distribution from the uniform distribution is related to the entropy.  This may be interpretable as a baseline that describes the maximum reduction in uncertainty, i.e. from maximum uncertainty to observation.  (we may take some kind of result from asymptotic convergence towards the true entropy/divergence from the Jordan results as a way to describe “uncertainty about uncertainty”)  <em>“This problem includes as a special case the problem of estimating the mutual information, corresponding to the KL divergence between a joint distribution and the product of its marginals, as well as the problem of estimating the Shannon entropy of a distribution P, which is related to the KL divergence between P and the uniform distribution.”</em> (see Nguyen et al. 2009 <strong>Estimating divergence functionals and the likelihood  ratio by convex risk minimization</strong>)</p></li>
<li><p><strong>k-Nearest neighbour</strong>: take the k nearest streamflow stations and approximate the target location based on some kind of average.  Subsets of this method include a) different k, b) weighting schemes on top of different k, or c) other intermediate models on k.</p></li>
<li><p><strong>“Best” neighbour</strong>: how much better could the “best” neighbour be if we knew how to pick it?  Note: we don’t really know how to pick it. (see Poole et al. 2021 Regionalization for Ungauged Catchments — Lessons Learned From a Comparative Large-Sample Study).</p>
<ul class="simple">
<li><p>An “upper” bound for this is computing what the “extra bits per sample” cost of using a uniform distribution as a model, i.e. <span class="math notranslate nohighlight">\(D_K(P||U)\)</span> because some number of neighbours will be worse than this (one question is now many).</p></li>
<li><p>A “lower” bound for this is estimating the uncertainty in the distribution estimate itself, because there is a limit to the precision we can use to rank neighbours based on KL divergence.</p></li>
</ul>
</li>
<li><p><strong>Parametric distribution estimation</strong>: (following previous results) we show that the mean runoff can be predicted well.  We know that the standard deviation is well correlated to the mean, so we have two parameters that we can use to estimate the distribution using any number of parametric forms. <strong>Non-parametric distributions do not represent generators, so KDE can’t be used to estimate a distribution for an ungauged catchment</strong>.</p></li>
<li><p><strong>Divergence Prediction</strong>: what if we ignore the specifics how <em>how</em> the two distributions differ and instead focus on <em>how much</em> they differ.</p></li>
</ol>
<p>One model that predicts sufficient statistics, then compute KL divergence.
Next model that predicts the computed KL divergence.
Both models use only catchment characteristics.</p>
</section>
<section id="methodology">
<h1>Methodology<a class="headerlink" href="#methodology" title="Link to this heading">#</a></h1>
<p>Let <span class="math notranslate nohighlight">\(P\)</span> represent the “ground truth” distribution of unit area runoff for a monitored catchment <span class="math notranslate nohighlight">\(i\)</span>.  Let <span class="math notranslate nohighlight">\(\hat P_i\)</span> represent an estimate of <span class="math notranslate nohighlight">\(P_i\)</span>.</p>
<p>For all <span class="math notranslate nohighlight">\(i\)</span> in <span class="math notranslate nohighlight">\(M\)</span> monitored catchments:</p>
<ol class="arabic simple">
<li><p>Compute an estimate of the entropy of <span class="math notranslate nohighlight">\(P_i\)</span> based on <span class="math notranslate nohighlight">\(\hat P_i\)</span>:</p>
<ul class="simple">
<li><p>The entropy is sensitive to the method</p></li>
</ul>
</li>
<li><p>Estimate</p></li>
<li><p>Use the parameters as a model Q in pairwise comparisons, these eliminate</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">time</span><span class="w"> </span><span class="kn">import</span> <span class="n">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">entropy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">data_processing_functions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dpf</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>

<span class="c1"># visualize the catchment centroid locations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bokeh.plotting</span><span class="w"> </span><span class="kn">import</span> <span class="n">figure</span><span class="p">,</span> <span class="n">show</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bokeh.layouts</span><span class="w"> </span><span class="kn">import</span> <span class="n">gridplot</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bokeh.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">output_notebook</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bokeh.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">ColumnDataSource</span><span class="p">,</span> <span class="n">LinearAxis</span><span class="p">,</span> <span class="n">Range1d</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bokeh.palettes</span><span class="w"> </span><span class="kn">import</span> <span class="n">Colorblind</span><span class="p">,</span> <span class="n">Sunset10</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">lognorm</span><span class="p">,</span> <span class="n">expon</span><span class="p">,</span> <span class="n">kappa4</span><span class="p">,</span> <span class="n">gaussian_kde</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">kl_div</span><span class="p">,</span> <span class="n">digamma</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span>

<span class="c1"># from sklearn.neighbors import NearestNeighbors</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.distance</span><span class="w"> </span><span class="kn">import</span> <span class="n">cdist</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">KDEpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">FFTKDE</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">jax.numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">jnp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">jax</span><span class="w"> </span><span class="kn">import</span> <span class="n">vmap</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">jax.scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">gaussian_kde</span> <span class="k">as</span> <span class="n">jkde</span>

<span class="n">output_notebook</span><span class="p">()</span>

<span class="n">BASE_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ModuleNotFoundError</span><span class="g g-Whitespace">                       </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">line</span> <span class="mi">24</span>
<span class="g g-Whitespace">     </span><span class="mi">21</span> <span class="c1"># from sklearn.neighbors import NearestNeighbors</span>
<span class="g g-Whitespace">     </span><span class="mi">22</span> <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.distance</span><span class="w"> </span><span class="kn">import</span> <span class="n">cdist</span>
<span class="ne">---&gt; </span><span class="mi">24</span> <span class="kn">from</span><span class="w"> </span><span class="nn">KDEpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">FFTKDE</span>
<span class="g g-Whitespace">     </span><span class="mi">25</span> <span class="kn">import</span><span class="w"> </span><span class="nn">jax.numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">jnp</span>
<span class="g g-Whitespace">     </span><span class="mi">26</span> <span class="kn">from</span><span class="w"> </span><span class="nn">jax</span><span class="w"> </span><span class="kn">import</span> <span class="n">vmap</span>

<span class="ne">ModuleNotFoundError</span>: No module named &#39;KDEpy&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># import attributes </span>
<span class="n">rev_date</span> <span class="o">=</span> <span class="s1">&#39;20250227&#39;</span>
<span class="n">attributes_fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;BCUB_watershed_attributes_updated_</span><span class="si">{</span><span class="n">rev_date</span><span class="si">}</span><span class="s1">.geojson&#39;</span><span class="p">))</span>
<span class="n">attr_df</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">attributes_fpath</span><span class="p">)</span>
<span class="n">attr_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">attr_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
<span class="n">filtered_stns</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># load the predicted parameter results</span>
<span class="n">predict_result_folder</span> <span class="o">=</span> <span class="s1">&#39;/home/danbot2/code_5820/24/divergence_measures/docs/notebooks/data/prediction_results/runoff_prediction_results&#39;</span>
<span class="c1"># target_cols = [&#39;mean_uar&#39;, &#39;sd_uar&#39;, &#39;logq_mean_mm&#39;, &#39;logq_sd_mm&#39;,]</span>
<span class="n">target_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mean_uar&#39;</span><span class="p">,</span> <span class="s1">&#39;sd_uar&#39;</span><span class="p">,</span> <span class="s1">&#39;mean_logx&#39;</span><span class="p">,</span> <span class="s1">&#39;sd_logx&#39;</span><span class="p">]</span>

<span class="n">predicted_param_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">target_columns</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">file</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;best_out_of_sample_</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">_predictions.csv&#39;</span>
    <span class="n">rdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">predict_result_folder</span><span class="p">,</span> <span class="n">file</span><span class="p">),</span> <span class="n">index_col</span><span class="o">=</span><span class="s1">&#39;official_id&#39;</span><span class="p">)</span>
    <span class="n">rdf</span> <span class="o">=</span> <span class="n">rdf</span><span class="p">[[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">rdf</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Unnamed:&#39;</span><span class="p">)]]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;official_id&#39;</span><span class="p">)</span>
    <span class="n">predicted_param_dict</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdf</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="general-data-processing-functions">
<h1>General data processing functions<a class="headerlink" href="#general-data-processing-functions" title="Link to this heading">#</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">generate_bootstrap_samples</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a matrix of N bootstrap samples, each of length L.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data (array-like): 1D array of sample data.</span>
<span class="sd">        N (int): Number of bootstrap samples to generate.</span>
<span class="sd">        L (int): Length of each bootstrap sample.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Matrix of shape (N, L) containing bootstrap samples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">N</span><span class="p">))</span>
    <span class="n">bootstrap_samples</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">bootstrap_samples</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="estimate-entropy">
<h1>Estimate entropy<a class="headerlink" href="#estimate-entropy" title="Link to this heading">#</a></h1>
<p>The entropy of a distribution <span class="math notranslate nohighlight">\(P\)</span> is related to the KL divergence between <span class="math notranslate nohighlight">\(P\)</span> and the uniform distribution <span class="math notranslate nohighlight">\(\mathbb{U}\)</span> by the following:</p>
<p>The KL divergence between two distributions <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> is:</p>
<div class="math notranslate nohighlight">
\[D_\text{KL}(P||Q) = \int p(x) \log \frac{p(x)}{q(x)} dx\]</div>
<p>Where <span class="math notranslate nohighlight">\(p(x)\)</span> and <span class="math notranslate nohighlight">\(q(x)\)</span> are the probability density functions of <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> respectively.  If <span class="math notranslate nohighlight">\(Q\)</span> is a uniform distribution over <span class="math notranslate nohighlight">\([a, b]\)</span>, the density is the constant <span class="math notranslate nohighlight">\(q(x) = (b-a)^{-1}\)</span>, <span class="math notranslate nohighlight">\(x \in [a, b]\)</span>.  Substituting into the KL divergence expression:</p>
<div class="math notranslate nohighlight">
\[D_\text{KL}(P||Q) = \int p(x) \log \frac{p(x)}{1/(b-a)}dx = \int p(x) \log p(x)dx - \int p(x)\log \frac{1}{b-a}dx\]</div>
<p>Since <span class="math notranslate nohighlight">\(log\frac{1}{b-a}\)</span> is constant over the domain,</p>
<div class="math notranslate nohighlight">
\[\int p(x)\log \frac{1}{b-a} dx = \log(b-a)\]</div>
<p>And the first term is the negative entropy of <span class="math notranslate nohighlight">\(p(x)\)</span>, i.e. <span class="math notranslate nohighlight">\(-H(P) = \int p(x) \log (x) dx\)</span>, then:</p>
<div class="math notranslate nohighlight">
\[D_\text{KL}(P||Q) = -H(P) + \log(b-a)\]</div>
<p>So the maximum uncertainty <span class="math notranslate nohighlight">\(\log(b-a)\)</span> is reduced by <span class="math notranslate nohighlight">\(\log(b-a) - H(P) = D_\text{KL}(P||Q)\)</span> bits per sample by observing the system.</p>
</section>
<section id="define-a-measurement-error-model">
<h1>Define a measurement error model<a class="headerlink" href="#define-a-measurement-error-model" title="Link to this heading">#</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the ranges and associated errors</span>
<span class="n">error_points</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">,</span> <span class="mf">1e3</span><span class="p">,</span> <span class="mf">1e4</span><span class="p">,</span> <span class="mf">1e5</span><span class="p">])</span>  <span class="c1"># Magnitude points</span>
<span class="n">error_values</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.20</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>    <span class="c1"># Associated errors (as proportions)</span>

<span class="n">efig</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">x_axis_type</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">efig</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">error_points</span><span class="p">,</span> <span class="n">error_values</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;Measurement Error Model&#39;</span><span class="p">)</span>
<span class="n">efig</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$$\text{Flow } m^3/s$$&#39;</span>
<span class="n">efig</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$$\text{Error } [/100]$$&#39;</span>
<span class="n">efig</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">format_fig_fonts</span><span class="p">(</span><span class="n">efig</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">show</span><span class="p">(</span><span class="n">efig</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
  <div id="c8017864-8374-409c-8d6f-3757ae8028e4" data-root-id="p1048" style="display: contents;"></div>
</div><script type="application/javascript">(function(root) {
  function embed_document(root) {
  const docs_json = {"d45ab6f4-29ce-44f8-86c5-861a8b462fd1":{"version":"3.6.0","title":"Bokeh Application","roots":[{"type":"object","name":"Figure","id":"p1048","attributes":{"width":400,"height":300,"x_range":{"type":"object","name":"DataRange1d","id":"p1049"},"y_range":{"type":"object","name":"DataRange1d","id":"p1050"},"x_scale":{"type":"object","name":"LogScale","id":"p1057"},"y_scale":{"type":"object","name":"LinearScale","id":"p1058"},"title":{"type":"object","name":"Title","id":"p1055"},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p1088","attributes":{"data_source":{"type":"object","name":"ColumnDataSource","id":"p1082","attributes":{"selected":{"type":"object","name":"Selection","id":"p1083","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p1084"},"data":{"type":"map","entries":[["x",{"type":"ndarray","array":{"type":"bytes","data":"F7fROG8SgzoK1yM8zczMPQAAgD8AACBBAADIQgAAekQAQBxGAFDDRw=="},"shape":[10],"dtype":"float32","order":"little"}],["y",{"type":"ndarray","array":{"type":"bytes","data":"AAAgQQAAoEAAAIA/AAAAPwAAgD7NzMw9zczMPZqZGT7NzEw+AACAPg=="},"shape":[10],"dtype":"float32","order":"little"}]]}}},"view":{"type":"object","name":"CDSView","id":"p1089","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p1090"}}},"glyph":{"type":"object","name":"Line","id":"p1085","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y"},"line_color":"red","line_width":2}},"nonselection_glyph":{"type":"object","name":"Line","id":"p1086","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y"},"line_color":"red","line_alpha":0.1,"line_width":2}},"muted_glyph":{"type":"object","name":"Line","id":"p1087","attributes":{"x":{"type":"field","field":"x"},"y":{"type":"field","field":"y"},"line_color":"red","line_alpha":0.2,"line_width":2}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p1056","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p1069"},{"type":"object","name":"WheelZoomTool","id":"p1070","attributes":{"renderers":"auto"}},{"type":"object","name":"BoxZoomTool","id":"p1071","attributes":{"overlay":{"type":"object","name":"BoxAnnotation","id":"p1072","attributes":{"syncable":false,"line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","handles":{"type":"object","name":"BoxInteractionHandles","id":"p1078","attributes":{"all":{"type":"object","name":"AreaVisuals","id":"p1077","attributes":{"fill_color":"white","hover_fill_color":"lightgray"}}}}}}}},{"type":"object","name":"SaveTool","id":"p1079"},{"type":"object","name":"ResetTool","id":"p1080"},{"type":"object","name":"HelpTool","id":"p1081"}]}},"left":[{"type":"object","name":"LinearAxis","id":"p1064","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1065","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1066"},"axis_label":"$$\\text{Error } [/100]$$","axis_label_text_font":"Bitstream Charter","axis_label_text_font_size":"12pt","major_label_policy":{"type":"object","name":"AllLabels","id":"p1067"},"major_label_text_font":"Bitstream Charter","major_label_text_font_size":"10pt"}}],"below":[{"type":"object","name":"LogAxis","id":"p1059","attributes":{"ticker":{"type":"object","name":"LogTicker","id":"p1060","attributes":{"num_minor_ticks":10,"mantissas":[1,5]}},"formatter":{"type":"object","name":"LogTickFormatter","id":"p1061"},"axis_label":"$$\\text{Flow } m^3/s$$","axis_label_text_font":"Bitstream Charter","axis_label_text_font_size":"12pt","major_label_policy":{"type":"object","name":"AllLabels","id":"p1062"},"major_label_text_font":"Bitstream Charter","major_label_text_font_size":"10pt"}}],"center":[{"type":"object","name":"Grid","id":"p1063","attributes":{"axis":{"id":"p1059"}}},{"type":"object","name":"Grid","id":"p1068","attributes":{"dimension":1,"axis":{"id":"p1064"}}},{"type":"object","name":"Legend","id":"p1091","attributes":{"label_text_font":"Bitstream Charter","label_text_font_size":"10pt","items":[{"type":"object","name":"LegendItem","id":"p1092","attributes":{"label":{"type":"value","value":"Measurement Error Model"},"renderers":[{"id":"p1088"}]}}]}}]}}]}};
  const render_items = [{"docid":"d45ab6f4-29ce-44f8-86c5-861a8b462fd1","roots":{"p1048":"c8017864-8374-409c-8d6f-3757ae8028e4"},"root_ids":["p1048"]}];
  void root.Bokeh.embed.embed_items_notebook(docs_json, render_items);
  }
  if (root.Bokeh !== undefined) {
    embed_document(root);
  } else {
    let attempts = 0;
    const timer = setInterval(function(root) {
      if (root.Bokeh !== undefined) {
        clearInterval(timer);
        embed_document(root);
      } else {
        attempts++;
        if (attempts > 100) {
          clearInterval(timer);
          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
        }
      }
    }, 10, root)
  }
})(window);</script></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">vectorized_kde_integration</span><span class="p">(</span><span class="n">log_data</span><span class="p">,</span> <span class="n">eval_grid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform integration for a single bootstrap sample using its KDE fit.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    - log_data: Log-transformed data points for one bootstrap sample (1D array).</span>
<span class="sd">    - eval_grid: Shared evaluation grid (1D array).</span>

<span class="sd">    Returns:</span>
<span class="sd">    - Integrated densities over the evaluation grid (1D array).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fit_object</span> <span class="o">=</span> <span class="n">jkde</span><span class="p">(</span><span class="n">log_data</span><span class="p">,</span> <span class="n">bw_method</span><span class="o">=</span><span class="s1">&#39;silverman&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">le</span><span class="p">:</span> <span class="n">fit_object</span><span class="o">.</span><span class="n">integrate_box_1d</span><span class="p">(</span><span class="o">-</span><span class="n">jnp</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">le</span><span class="p">))(</span><span class="n">eval_grid</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">compute_baseline_kde_fits</span><span class="p">(</span><span class="n">eval_grid</span><span class="p">,</span> <span class="n">bootstrap_samples</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute KDE for each bootstrap sample column in a vectorized manner.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    - eval_grid: Shared evaluation grid (array of shape (n_eval,)).</span>
<span class="sd">    - bootstrap_samples: Matrix of bootstrap samples (shape (n_data, n_bootstrap)).</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    - Density estimates for each bootstrap sample (array of shape (n_eval, n_bootstrap)).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Log-transform the bootstrap samples</span>
    <span class="n">log_samples</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">bootstrap_samples</span><span class="p">)</span>

    <span class="c1"># Define a function to integrate a single column</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">integrate_column</span><span class="p">(</span><span class="n">log_data</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">vectorized_kde_integration</span><span class="p">(</span><span class="n">log_data</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eval_grid</span><span class="p">))</span>
    
    <span class="c1"># Apply the function to each column of the bootstrap samples</span>
    <span class="n">cdf</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">integrate_column</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">out_axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)(</span><span class="n">log_samples</span><span class="p">)</span>
    <span class="n">pmf</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">cdf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pmf</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pmf</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Interpolated error function</span>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolate_error_model</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate measurement error as a function of x using the provided error ranges.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">error_points</span><span class="p">,</span> <span class="n">error_values</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_fft_kde_fit_bootstrap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
    <span class="c1"># input_data = jnp.log10(data)</span>
    <span class="n">fft_weights</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vmap</span><span class="p">(</span><span class="n">interpolate_error_model</span><span class="p">)(</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">fft_weights</span> <span class="o">/=</span> <span class="n">fft_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">log_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> 
    <span class="n">cdfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">log_data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">fft_weights</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
        <span class="n">nn</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">fft_fit</span> <span class="o">=</span> <span class="n">FFTKDE</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">fft_fit</span><span class="o">.</span><span class="n">evaluate</span><span class="p">()</span>
        <span class="n">fft_density</span> <span class="o">=</span> <span class="n">fft_fit</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">cdfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fft_density</span><span class="p">)</span>
        
    <span class="n">fft_kde_cdf</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cdfs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># Normalize CDF to ensure it sums to 1</span>
    <span class="n">fft_kde_cdf</span> <span class="o">/=</span> <span class="n">fft_kde_cdf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pmf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fft_kde_cdf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pmf</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pmf</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_simulations</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">max_diff</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">stn</span> <span class="ow">in</span> <span class="n">filtered_stns</span><span class="p">:</span>
    <span class="n">test_df</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">get_timeseries_data</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
    <span class="n">test_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">stn</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">test_df</span><span class="p">[</span><span class="n">stn</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">add_jitter</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">generate_bootstrap_samples</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_simulations</span><span class="p">)</span>
    <span class="n">log_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

    <span class="c1"># create a common grid to evaluate pdfs numerically</span>
    <span class="n">eval_grid</span> <span class="o">=</span> <span class="n">create_pdf_eval_grid</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># here we generate bootstrap samples of the baseline </span>
    <span class="c1"># distribution estimate</span>
    <span class="n">kde_fits</span> <span class="o">=</span> <span class="n">compute_baseline_kde_fits</span><span class="p">(</span><span class="n">eval_grid</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span> 
    <span class="c1"># print(kde_fits.shape)</span>

    <span class="c1"># compute distributions incorporating adaptive kernel</span>
    <span class="c1"># bandwidth based on an assumed measurement error model</span>
    <span class="n">adaptive_kde_fits</span> <span class="o">=</span> <span class="n">compute_fft_kde_fit_bootstrap</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">eval_grid</span><span class="p">)</span>
    <span class="c1"># print(adaptive_kde_fits.shape)</span>
    <span class="c1"># print(asdf)</span>
    <span class="c1"># compute the KL divergence between simple and weighted KDE fits</span>
    <span class="c1"># for the bootstrap samples</span>
    <span class="n">kde_KLD</span> <span class="o">=</span> <span class="n">compute_kl_divergence</span><span class="p">(</span><span class="n">kde_fits</span><span class="p">,</span> <span class="n">adaptive_kde_fits</span><span class="p">)</span>
    <span class="n">kde_CI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">kde_KLD</span><span class="p">,</span> <span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">))</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kde_CI</span><span class="p">)</span>
    <span class="n">ci</span> <span class="o">=</span> <span class="n">kde_CI</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">kde_CI</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># find the nearest k stations and use their distribution(s) as a model</span>
    <span class="c1"># for k in [1, 2, 3, 4, 5]:</span>
        
    
    <span class="c1"># uncertainty_reduction_kde = np.round(max_uncertainty - np.percentile(kde_H, (97.5, 50, 2.5)), 2)</span>
    <span class="c1"># ci = uncertainty_reduction_kde[2] - uncertainty_reduction_kde[0]</span>
    <span class="c1"># results.append([ci, len(test_df)])</span>
    <span class="k">if</span> <span class="n">ci</span> <span class="o">&gt;</span> <span class="n">max_diff</span><span class="p">:</span>
        <span class="n">max_diff</span> <span class="o">=</span> <span class="n">ci</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;New largest CI = </span><span class="si">{</span><span class="n">ci</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> (N=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">25</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_stns</span><span class="p">)</span><span class="si">}</span><span class="s1"> completed&#39;</span><span class="p">)</span>
        <span class="c1"># print(asdf)</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>New largest CI = 0.01 (N=1752)
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2025-01-16 12:51:44.003774: W external/xla/xla/tsl/framework/bfc_allocator.cc:497] Allocator (GPU_0_bfc) ran out of memory trying to allocate 459.39MiB (rounded to 481702912)requested by op 
2025-01-16 12:51:44.004051: W external/xla/xla/tsl/framework/bfc_allocator.cc:508] ****************************************************************************************__*********_
E0116 12:51:44.004086 2110204 pjrt_stream_executor_client.cc:3085] Execution of replica 0 failed: RESOURCE_EXHAUSTED: Out of memory while trying to allocate 481702800 bytes.
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ValueError</span><span class="g g-Whitespace">                                </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">line</span> <span class="mi">18</span>
<span class="g g-Whitespace">     </span><span class="mi">14</span> <span class="n">eval_grid</span> <span class="o">=</span> <span class="n">create_pdf_eval_grid</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">16</span> <span class="c1"># here we generate bootstrap samples of the baseline </span>
<span class="g g-Whitespace">     </span><span class="mi">17</span> <span class="c1"># distribution estimate</span>
<span class="ne">---&gt; </span><span class="mi">18</span> <span class="n">kde_fits</span> <span class="o">=</span> <span class="n">compute_baseline_kde_fits</span><span class="p">(</span><span class="n">eval_grid</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span> 
<span class="g g-Whitespace">     </span><span class="mi">19</span> <span class="c1"># print(kde_fits.shape)</span>
<span class="g g-Whitespace">     </span><span class="mi">20</span> 
<span class="g g-Whitespace">     </span><span class="mi">21</span> <span class="c1"># compute distributions incorporating adaptive kernel</span>
<span class="g g-Whitespace">     </span><span class="mi">22</span> <span class="c1"># bandwidth based on an assumed measurement error model</span>
<span class="g g-Whitespace">     </span><span class="mi">23</span> <span class="n">adaptive_kde_fits</span> <span class="o">=</span> <span class="n">compute_fft_kde_fit_bootstrap</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">eval_grid</span><span class="p">)</span>

<span class="nn">Cell In[8], line 35,</span> in <span class="ni">compute_baseline_kde_fits</span><span class="nt">(eval_grid, bootstrap_samples)</span>
<span class="g g-Whitespace">     </span><span class="mi">32</span>     <span class="k">return</span> <span class="n">vectorized_kde_integration</span><span class="p">(</span><span class="n">log_data</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eval_grid</span><span class="p">))</span>
<span class="g g-Whitespace">     </span><span class="mi">34</span> <span class="c1"># Apply the function to each column of the bootstrap samples</span>
<span class="ne">---&gt; </span><span class="mi">35</span> <span class="n">cdf</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">integrate_column</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">out_axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)(</span><span class="n">log_samples</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">36</span> <span class="n">pmf</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">cdf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">37</span> <span class="n">pmf</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="p">[</span><span class="o">...</span> <span class="n">skipping</span> <span class="n">hidden</span> <span class="mi">3</span> <span class="n">frame</span><span class="p">]</span>

<span class="nn">Cell In[8], line 32,</span> in <span class="ni">compute_baseline_kde_fits.&lt;locals&gt;.integrate_column</span><span class="nt">(log_data)</span>
<span class="g g-Whitespace">     </span><span class="mi">31</span> <span class="k">def</span><span class="w"> </span><span class="nf">integrate_column</span><span class="p">(</span><span class="n">log_data</span><span class="p">):</span>
<span class="ne">---&gt; </span><span class="mi">32</span>     <span class="k">return</span> <span class="n">vectorized_kde_integration</span><span class="p">(</span><span class="n">log_data</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eval_grid</span><span class="p">))</span>

<span class="nn">Cell In[8], line 13,</span> in <span class="ni">vectorized_kde_integration</span><span class="nt">(log_data, eval_grid)</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span><span class="w"> </span><span class="sd">&quot;&quot;&quot;</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span><span class="sd"> Perform integration for a single bootstrap sample using its KDE fit.</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span><span class="sd"> </span>
<span class="sd">   (...)</span>
<span class="g g-Whitespace">     </span><span class="mi">10</span><span class="sd"> - Integrated densities over the evaluation grid (1D array).</span>
<span class="g g-Whitespace">     </span><span class="mi">11</span><span class="sd"> &quot;&quot;&quot;</span>
<span class="g g-Whitespace">     </span><span class="mi">12</span> <span class="n">fit_object</span> <span class="o">=</span> <span class="n">jkde</span><span class="p">(</span><span class="n">log_data</span><span class="p">,</span> <span class="n">bw_method</span><span class="o">=</span><span class="s1">&#39;silverman&#39;</span><span class="p">)</span>
<span class="ne">---&gt; </span><span class="mi">13</span> <span class="k">return</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">le</span><span class="p">:</span> <span class="n">fit_object</span><span class="o">.</span><span class="n">integrate_box_1d</span><span class="p">(</span><span class="o">-</span><span class="n">jnp</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">le</span><span class="p">))(</span><span class="n">eval_grid</span><span class="p">)</span>

    <span class="p">[</span><span class="o">...</span> <span class="n">skipping</span> <span class="n">hidden</span> <span class="mi">3</span> <span class="n">frame</span><span class="p">]</span>

<span class="nn">Cell In[8], line 13,</span> in <span class="ni">vectorized_kde_integration.&lt;locals&gt;.&lt;lambda&gt;</span><span class="nt">(le)</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span><span class="w"> </span><span class="sd">&quot;&quot;&quot;</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span><span class="sd"> Perform integration for a single bootstrap sample using its KDE fit.</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span><span class="sd"> </span>
<span class="sd">   (...)</span>
<span class="g g-Whitespace">     </span><span class="mi">10</span><span class="sd"> - Integrated densities over the evaluation grid (1D array).</span>
<span class="g g-Whitespace">     </span><span class="mi">11</span><span class="sd"> &quot;&quot;&quot;</span>
<span class="g g-Whitespace">     </span><span class="mi">12</span> <span class="n">fit_object</span> <span class="o">=</span> <span class="n">jkde</span><span class="p">(</span><span class="n">log_data</span><span class="p">,</span> <span class="n">bw_method</span><span class="o">=</span><span class="s1">&#39;silverman&#39;</span><span class="p">)</span>
<span class="ne">---&gt; </span><span class="mi">13</span> <span class="k">return</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">le</span><span class="p">:</span> <span class="n">fit_object</span><span class="o">.</span><span class="n">integrate_box_1d</span><span class="p">(</span><span class="o">-</span><span class="n">jnp</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">le</span><span class="p">))(</span><span class="n">eval_grid</span><span class="p">)</span>

<span class="nn">File ~/code_5820/data_analysis/lib/python3.10/site-packages/jax/_src/scipy/stats/kde.py:162,</span> in <span class="ni">gaussian_kde.integrate_box_1d</span><span class="nt">(self, low, high)</span>
<span class="g g-Whitespace">    </span><span class="mi">160</span> <span class="n">low</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">((</span><span class="n">low</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">161</span> <span class="n">high</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">((</span><span class="n">high</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span>
<span class="ne">--&gt; </span><span class="mi">162</span> <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">*</span> <span class="p">(</span><span class="n">special</span><span class="o">.</span><span class="n">ndtr</span><span class="p">(</span><span class="n">high</span><span class="p">)</span> <span class="o">-</span> <span class="n">special</span><span class="o">.</span><span class="n">ndtr</span><span class="p">(</span><span class="n">low</span><span class="p">)))</span>

<span class="nn">File ~/code_5820/data_analysis/lib/python3.10/site-packages/jax/_src/scipy/special.py:907,</span> in <span class="ni">ndtr</span><span class="nt">(x)</span>
<span class="g g-Whitespace">    </span><span class="mi">903</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
<span class="g g-Whitespace">    </span><span class="mi">904</span>   <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
<span class="g g-Whitespace">    </span><span class="mi">905</span>       <span class="s2">&quot;x.dtype=</span><span class="si">{}</span><span class="s2"> is not supported, see docstring for supported types.&quot;</span>
<span class="g g-Whitespace">    </span><span class="mi">906</span>       <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
<span class="ne">--&gt; </span><span class="mi">907</span> <span class="k">return</span> <span class="n">_ndtr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="nn">File ~/code_5820/data_analysis/lib/python3.10/site-packages/jax/_src/scipy/special.py:919,</span> in <span class="ni">_ndtr</span><span class="nt">(x)</span>
<span class="g g-Whitespace">    </span><span class="mi">914</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">half_sqrt_2</span>
<span class="g g-Whitespace">    </span><span class="mi">915</span> <span class="n">z</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">916</span> <span class="n">y</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">half_sqrt_2</span><span class="p">),</span>
<span class="g g-Whitespace">    </span><span class="mi">917</span>                     <span class="n">dtype</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span> <span class="o">+</span> <span class="n">lax</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="n">w</span><span class="p">),</span>
<span class="g g-Whitespace">    </span><span class="mi">918</span>                     <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">dtype</span><span class="p">(</span><span class="mf">0.</span><span class="p">)),</span>
<span class="ne">--&gt; </span><span class="mi">919</span>                                     <span class="n">dtype</span><span class="p">(</span><span class="mf">2.</span><span class="p">)</span> <span class="o">-</span> <span class="n">lax</span><span class="o">.</span><span class="n">erfc</span><span class="p">(</span><span class="n">z</span><span class="p">),</span>
<span class="g g-Whitespace">    </span><span class="mi">920</span>                                     <span class="n">lax</span><span class="o">.</span><span class="n">erfc</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>
<span class="g g-Whitespace">    </span><span class="mi">921</span> <span class="k">return</span> <span class="n">dtype</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span>

<span class="nn">File ~/code_5820/data_analysis/lib/python3.10/site-packages/jax/_src/numpy/array_methods.py:1050,</span> in <span class="ni">_forward_operator_to_aval.&lt;locals&gt;.op</span><span class="nt">(self, *args)</span>
<span class="g g-Whitespace">   </span><span class="mi">1049</span> <span class="k">def</span><span class="w"> </span><span class="nf">op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="ne">-&gt; </span><span class="mi">1050</span>   <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aval</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="nn">File ~/code_5820/data_analysis/lib/python3.10/site-packages/jax/_src/numpy/array_methods.py:573,</span> in <span class="ni">_defer_to_unrecognized_arg.&lt;locals&gt;.deferring_binary_op</span><span class="nt">(self, other)</span>
<span class="g g-Whitespace">    </span><span class="mi">571</span> <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">swap</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">572</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_accepted_binop_types</span><span class="p">):</span>
<span class="ne">--&gt; </span><span class="mi">573</span>   <span class="k">return</span> <span class="n">binary_op</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">574</span> <span class="c1"># Note: don&#39;t use isinstance here, because we don&#39;t want to raise for</span>
<span class="g g-Whitespace">    </span><span class="mi">575</span> <span class="c1"># subclasses, e.g. NamedTuple objects that may override operators.</span>
<span class="g g-Whitespace">    </span><span class="mi">576</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_rejected_binop_types</span><span class="p">:</span>

<span class="nn">File ~/code_5820/data_analysis/lib/python3.10/site-packages/jax/_src/numpy/ufunc_api.py:177,</span> in <span class="ni">ufunc.__call__</span><span class="nt">(self, out, where, *args)</span>
<span class="g g-Whitespace">    </span><span class="mi">175</span>   <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;where argument of </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">176</span> <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__static_props</span><span class="p">[</span><span class="s1">&#39;call&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_vectorized</span>
<span class="ne">--&gt; </span><span class="mi">177</span> <span class="k">return</span> <span class="n">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="p">[</span><span class="o">...</span> <span class="n">skipping</span> <span class="n">hidden</span> <span class="mi">14</span> <span class="n">frame</span><span class="p">]</span>

<span class="nn">File ~/code_5820/data_analysis/lib/python3.10/site-packages/jax/_src/pjit.py:1738,</span> in <span class="ni">_pjit_call_impl</span><span class="nt">(jaxpr, in_shardings, out_shardings, in_layouts, out_layouts, resource_env, donated_invars, name, keep_unused, inline, *args)</span>
<span class="nn">   1729 donated_argnums = tuple(i for i, d</span> in <span class="ni">enumerate</span><span class="nt">(donated_invars) if d)</span>
<span class="g g-Whitespace">   </span><span class="mi">1730</span> <span class="n">cache_key</span> <span class="o">=</span> <span class="n">pxla</span><span class="o">.</span><span class="n">JitGlobalCppCacheKeys</span><span class="p">(</span>
<span class="g g-Whitespace">   </span><span class="mi">1731</span>     <span class="n">donate_argnums</span><span class="o">=</span><span class="n">donated_argnums</span><span class="p">,</span> <span class="n">donate_argnames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1732</span>     <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
   <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="g g-Whitespace">   </span><span class="mi">1736</span>     <span class="n">out_layouts_treedef</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_layouts_leaves</span><span class="o">=</span><span class="n">out_layouts</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1737</span>     <span class="n">use_resource_env</span><span class="o">=</span><span class="n">resource_env</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
<span class="ne">-&gt; </span><span class="mi">1738</span> <span class="k">return</span> <span class="n">xc</span><span class="o">.</span><span class="n">_xla</span><span class="o">.</span><span class="n">pjit</span><span class="p">(</span>
<span class="g g-Whitespace">   </span><span class="mi">1739</span>     <span class="n">name</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">call_impl_cache_miss</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">cache_key</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1740</span>     <span class="n">tree_util</span><span class="o">.</span><span class="n">dispatch_registry</span><span class="p">,</span> <span class="n">pxla</span><span class="o">.</span><span class="n">cc_shard_arg</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1741</span>     <span class="n">_get_cpp_global_cache</span><span class="p">(</span><span class="n">cache_key</span><span class="o">.</span><span class="n">contains_explicit_attributes</span><span class="p">))(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="ne">ValueError</span>: RESOURCE_EXHAUSTED: Out of memory while trying to allocate 481702800 bytes.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ci_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ci&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">])</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;KDE estimated H(P) CI vs. sample size, </span><span class="si">{</span><span class="n">n_simulations</span><span class="si">}</span><span class="s1"> bootstrap samples&#39;</span><span class="p">)</span><span class="c1">#, x_axis_type=&#39;log&#39;)</span>
<span class="n">years_equiv</span> <span class="o">=</span> <span class="n">ci_df</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">365.24</span>
<span class="n">fig</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">years_equiv</span><span class="p">,</span> <span class="n">ci_df</span><span class="p">[</span><span class="s1">&#39;ci&#39;</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;95% CI&#39;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$$\text{Sample size [x365]}$$&#39;</span>
<span class="n">fig</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$$\text{[bits/sample]}$$&#39;</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">format_fig_fonts</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
<span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The idea behind the above plot is to show how the uncertainty, as expressed by the 95% confidence interval of a bootstrap sample, in the entropy estimate of a large sample of arbitrary distributions, varies as a function of the sample size.  The x-axis represents the “effective” sample size in more intuitive terms of years.</p>
<p>The motivation is to understand how the length of record is reflected in downstream analysis when comparing pairs of arbitrary distributions.</p>
<p>What is needed is to figure out how to convey this in terms that relate to the ultimate discriminant, or the ability to distinguish between potential models for their reduction in uncertainty.  Stated otherwise, to describe some kind of threshold where we can say that one proxy model is better than another, that is provides a more accurate estimate of the ‘ground truth’ distribution.  Such a model would enable the large scale comparison of potential future observation network expansion locations on the basis of how much they reduce the <strong>aggregate uncertainty</strong> of the unmonitored space.</p>
</section>
<section id="id1">
<h1><a class="headerlink" href="#id1" title="Link to this heading">#</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">neg_log_likelihood</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">params</span>
    <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>  <span class="c1"># Enforce positive scale</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">logpdf</span> <span class="o">=</span> <span class="n">kappa4</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">logpdf</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">logpdf</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">logpdf</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

<span class="k">def</span><span class="w"> </span><span class="nf">fit_kappa4_mle</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Handle edge cases where MLE is not feasible</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">}</span>
    
    <span class="c1"># Define the initial guesses for the parameters</span>
    <span class="n">initial_params</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>
    
    <span class="c1"># Bounds for the parameters: h and k between -2 and 2, scale &gt; 1e-5</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
    
    <span class="c1"># Minimize the negative log-likelihood</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">neg_log_likelihood</span><span class="p">,</span> <span class="n">initial_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;L-BFGS-B&#39;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># Log or handle fitting failure if needed</span>
    
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="n">h</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">loc</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="n">scale</span><span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">compute_pdf_cdf_kde_scipy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">grid_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the probability density function (pdf) and cumulative distribution function (cdf)</span>
<span class="sd">    from an array of values using Kernel Density Estimation (KDE) with scipy.stats.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    data (array-like): Input data array.</span>
<span class="sd">    grid_points (int): Number of points in the grid where the pdf and cdf are evaluated.</span>
<span class="sd">    bandwidth (float or str, optional): The bandwidth of the kernel. If None, Scott&#39;s Rule is used.</span>
<span class="sd">                                         Can also be a string for methods like &#39;scott&#39; or &#39;silverman&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">    x_grid (numpy.ndarray): Grid points where the pdf and cdf are evaluated.</span>
<span class="sd">    pdf_values (numpy.ndarray): Estimated pdf values corresponding to x_grid.</span>
<span class="sd">    cdf_values (numpy.ndarray): Estimated cdf values corresponding to x_grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert input data to a numpy array</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="c1"># Create a Gaussian KDE object</span>
    <span class="n">kde</span> <span class="o">=</span> <span class="n">gaussian_kde</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bw_method</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">)</span>
    
    <span class="c1"># Create a grid over which to evaluate the KDE</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
    <span class="n">x_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">grid_points</span><span class="p">)</span>
    
    <span class="c1"># Evaluate the pdf over the grid</span>
    <span class="n">pdf_values</span> <span class="o">=</span> <span class="n">kde</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)</span>
    
    <span class="c1"># Compute the cdf by integrating the pdf</span>
    <span class="n">cdf_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kde</span><span class="o">.</span><span class="n">integrate_box_1d</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x_grid</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">x_grid</span><span class="p">,</span> <span class="n">pdf_values</span><span class="p">,</span> <span class="n">cdf_values</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">remap_low_to_high_resolution</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">which_binning</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Vectorized distribution of low-resolution frequencies over high-resolution bins.</span>
<span class="sd">    Expands each low-res bin&#39;s frequency uniformly across the corresponding high-res bins.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b1_bin_dict</span> <span class="o">=</span> <span class="n">compute_discrete_distributions</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>  <span class="c1"># Low-res (Q)</span>
    <span class="n">b2_bin_dict</span> <span class="o">=</span> <span class="n">compute_discrete_distributions</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span>  <span class="c1"># High-res (P)</span>
    <span class="n">b1_bins</span> <span class="o">=</span> <span class="n">b1_bin_dict</span><span class="p">[</span><span class="n">which_binning</span><span class="p">][</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span>
    <span class="n">b1_freqs</span> <span class="o">=</span> <span class="n">b1_bin_dict</span><span class="p">[</span><span class="n">which_binning</span><span class="p">][</span><span class="s1">&#39;freqs&#39;</span><span class="p">]</span>
    <span class="n">b2_bins</span> <span class="o">=</span> <span class="n">b2_bin_dict</span><span class="p">[</span><span class="n">which_binning</span><span class="p">][</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span>
    <span class="n">b2_freqs</span> <span class="o">=</span> <span class="n">b2_bin_dict</span><span class="p">[</span><span class="n">which_binning</span><span class="p">][</span><span class="s1">&#39;freqs&#39;</span><span class="p">]</span>
    <span class="c1"># Normalize up-scaled low-res frequencies and convert to probabilities</span>
    <span class="n">b1_probs</span> <span class="o">=</span> <span class="n">b1_freqs</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b1_freqs</span><span class="p">)</span>
    <span class="c1"># Determine the low-res bin for each high-res bin</span>
    <span class="n">bin_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">b2_bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">b1_bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Map high-res bins to low-res bins</span>
    
    <span class="c1"># Compute counts of high-res bins falling into each low-res bin</span>
    <span class="n">counts_per_low_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">bin_indices</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">b1_probs</span><span class="p">))</span>

    <span class="c1"># Broadcast low-res frequencies to high-res bins, dividing by the count to distribute uniformly</span>
    <span class="n">high_res_probs</span> <span class="o">=</span> <span class="n">b1_probs</span><span class="p">[</span><span class="n">bin_indices</span><span class="p">]</span> <span class="o">/</span> <span class="n">counts_per_low_bin</span><span class="p">[</span><span class="n">bin_indices</span><span class="p">]</span>
    <span class="c1"># Normalize to ensure the result sums to 1</span>
    <span class="n">high_res_probs</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">high_res_probs</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">high_res_probs</span><span class="p">,</span> <span class="n">b1_bin_dict</span><span class="p">,</span> <span class="n">b2_bin_dict</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compute_discrete_distributions</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="c1"># 1. Determine the log-spaced bin edges</span>
    <span class="n">bin_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">total_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># 1. Compute the histogram using equal-width bins</span>
    <span class="n">counts</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="n">b</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">densities</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="n">b</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">bin_widths</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
    <span class="n">bin_dict</span><span class="p">[</span><span class="s1">&#39;equal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;edges&#39;</span><span class="p">:</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="s1">&#39;freqs&#39;</span><span class="p">:</span> <span class="n">freqs</span><span class="p">,</span> <span class="s1">&#39;densities&#39;</span><span class="p">:</span> <span class="n">densities</span><span class="p">,</span> <span class="s1">&#39;widths&#39;</span><span class="p">:</span> <span class="n">bin_widths</span><span class="p">}</span>

    <span class="c1"># 2. Compute the histogram using log-spaced bins</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">log_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">minx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">maxx</span><span class="p">),</span> <span class="mi">2</span><span class="o">**</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bin_widths</span> <span class="o">=</span> <span class="n">log_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">log_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">log_densities</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">log_edges</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">log_counts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">log_edges</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">log_freqs</span> <span class="o">=</span> <span class="n">log_counts</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log_counts</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">log_freqs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log_freqs</span><span class="p">)</span>
    <span class="n">bin_dict</span><span class="p">[</span><span class="s1">&#39;log&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;edges&#39;</span><span class="p">:</span> <span class="n">log_edges</span><span class="p">,</span> <span class="s1">&#39;freqs&#39;</span><span class="p">:</span> <span class="n">log_freqs</span><span class="p">,</span> <span class="s1">&#39;densities&#39;</span><span class="p">:</span> <span class="n">densities</span><span class="p">,</span> <span class="s1">&#39;widths&#39;</span><span class="p">:</span> <span class="n">bin_widths</span><span class="p">}</span>

    <span class="c1"># 3. Compute the histogram using uniform (probability) bins</span>
    <span class="n">quantiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">uniform_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">)</span>
    <span class="n">bin_widths</span> <span class="o">=</span> <span class="n">uniform_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">uniform_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">uniform_freqs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">uniform_edges</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">uniform_counts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">uniform_edges</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">uniform_freqs</span> <span class="o">=</span> <span class="n">uniform_counts</span> <span class="o">/</span> <span class="n">total_count</span>
    <span class="c1"># assert abs(sum(uniform_freqs) - 1) &lt; 0.001, sum(uniform_freqs)</span>
    <span class="n">bin_dict</span><span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;edges&#39;</span><span class="p">:</span> <span class="n">uniform_edges</span><span class="p">,</span> <span class="s1">&#39;freqs&#39;</span><span class="p">:</span> <span class="n">uniform_freqs</span><span class="p">,</span> <span class="s1">&#39;densities&#39;</span><span class="p">:</span> <span class="n">densities</span><span class="p">,</span> <span class="s1">&#39;widths&#39;</span><span class="p">:</span> <span class="n">bin_widths</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">bin_dict</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">create_MLE_fit_plot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">stn</span><span class="p">):</span>
    <span class="n">test_fig</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">x_axis_type</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>  

    <span class="c1"># plot empirical (discrete) distributions using linear and log binning</span>
    <span class="n">b</span><span class="o">=</span><span class="mi">8</span>
    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s1">_bit_log&#39;</span>
    <span class="n">bin_edges</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">log_bin_edges</span><span class="p">,</span> <span class="n">log_freqs</span> <span class="o">=</span> <span class="n">compute_discrete_distributions</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">stn</span><span class="p">)</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">top</span><span class="o">=</span><span class="n">freqs</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">freqs</span><span class="p">],</span> 
                  <span class="n">legend_label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">b</span><span class="w"> </span><span class="si">}</span><span class="s1">bits linear bins&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">Sunset10</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fill_alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">log_bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">log_bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">top</span><span class="o">=</span><span class="n">log_freqs</span><span class="p">,</span> 
                  <span class="n">bottom</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">freqs</span><span class="p">],</span> <span class="n">legend_label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s1"> bits log bins&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">Sunset10</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> 
                  <span class="n">line_color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>

    <span class="c1"># fit and plot a lognormal distribution</span>
    <span class="n">ln_shape</span><span class="p">,</span> <span class="n">ln_loc</span><span class="p">,</span> <span class="n">ln_scale</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">stn</span><span class="p">],</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Fixing location to 0</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">ln_mle_pdf</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ln_shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">ln_scale</span><span class="p">)</span>

    <span class="c1"># fit and plot an exponential distribution</span>
    <span class="n">ex_loc</span><span class="p">,</span> <span class="n">ex_scale</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">stn</span><span class="p">],</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ex_mle_pdf</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">ex_scale</span><span class="p">)</span>

    <span class="n">test_fig</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ln_mle_pdf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;LN MLE pdf&#39;</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ex_mle_pdf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;EXP MLE pdf&#39;</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">background_fill_alpha</span> <span class="o">=</span> <span class="mf">0.6</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="s1">&#39;top_right&#39;</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">click_policy</span><span class="o">=</span><span class="s1">&#39;hide&#39;</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$$\text{Mean Daily Flow } [m^3/s]$$&#39;</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$$P(X)$$&#39;</span>
    <span class="n">test_fig</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">format_fig_fonts</span><span class="p">(</span><span class="n">test_fig</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">test_fig</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">create_logspace_bins</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">num_bins</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create linearly spaced bins in log space over the range of `data`.&quot;&quot;&quot;</span>
    <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">log_min</span><span class="p">,</span> <span class="n">log_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">min_val</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">max_val</span><span class="p">)</span>
    <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">log_min</span><span class="p">,</span> <span class="n">log_max</span><span class="p">,</span> <span class="n">num_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bin_edges</span>


<span class="k">def</span><span class="w"> </span><span class="nf">calculate_probabilities</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the probabilities of data falling into each bin given `bin_edges`.&quot;&quot;&quot;</span>
    <span class="n">counts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bin_edges</span><span class="p">)</span>
    <span class="n">probabilities</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">counts</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># Normalize to get probabilities</span>
    <span class="k">return</span> <span class="n">probabilities</span>


<span class="k">def</span><span class="w"> </span><span class="nf">aggregate_probabilities</span><span class="p">(</span><span class="n">high_res_probs</span><span class="p">,</span> <span class="n">high_res_bins</span><span class="p">,</span> <span class="n">low_res_bins</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Aggregate high-resolution probabilities to match low-resolution bins.</span>
<span class="sd">    This will sum the high_res_probs that fall within each low-res bin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">low_res_probs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">low_res_bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Find indices of high-resolution bins that fall within the current low-res bin</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">high_res_bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">low_res_bins</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">high_res_bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">low_res_bins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Sum probabilities within the range</span>
        <span class="n">low_res_probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">high_res_probs</span><span class="p">[</span><span class="n">indices</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">low_res_probs</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">compute_kl_divergence</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute KL divergence between two probability distributions `p` and `q`.&quot;&quot;&quot;</span>
    <span class="c1"># Avoid division by zero and log of zero by adding a small epsilon</span>
    <span class="c1"># epsilon = 1e-10</span>
    <span class="c1"># p = np.maximum(p, epsilon)</span>
    <span class="c1"># q = np.maximum(q, epsilon)</span>
    <span class="n">kl_divergence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span> <span class="o">/</span> <span class="n">q</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">kl_divergence</span>

    
<span class="k">def</span><span class="w"> </span><span class="nf">fit_continuous_distributions</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;simulate the target using the parametric MLE parameters from the proxy&quot;&quot;&quot;</span>
    <span class="c1"># fit and plot a lognormal distribution</span>
    <span class="n">ln_shape</span><span class="p">,</span> <span class="n">ln_loc</span><span class="p">,</span> <span class="n">ln_scale</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Fixing location to 0</span>
    <span class="n">ex_loc</span><span class="p">,</span> <span class="n">ex_scale</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">kp</span> <span class="o">=</span> <span class="n">fit_kappa4_mle</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># kp = constrained_optimization(data)</span>
    <span class="n">kde</span> <span class="o">=</span> <span class="n">gaussian_kde</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">bw_method</span><span class="o">=</span><span class="s1">&#39;scott&#39;</span><span class="p">)</span>

    <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span><span class="c1"># + [np.inf]</span>
    <span class="n">ln_cdf_vals</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">ln_shape</span><span class="p">,</span> 
                              <span class="n">loc</span><span class="o">=</span><span class="n">ln_loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">ln_scale</span><span class="p">)</span>
    <span class="n">expon_cdf_vals</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">ex_loc</span><span class="p">,</span> 
                               <span class="n">scale</span><span class="o">=</span><span class="n">ex_scale</span><span class="p">)</span>
    <span class="n">kappa4_cdf_vals</span> <span class="o">=</span> <span class="n">kappa4</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">kp</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="n">kp</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">],</span>
                                 <span class="n">loc</span><span class="o">=</span><span class="n">kp</span><span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">kp</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">])</span>
    
    <span class="c1"># Compute the KDE-based CDF at the evaluation points</span>
    <span class="n">kde_cdf_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kde</span><span class="o">.</span><span class="n">integrate_box_1d</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">])</span>
    
    <span class="n">p_sim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">p_sim</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1">_LN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ln_cdf_vals</span><span class="p">)</span>
    <span class="n">p_sim</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1">_EXP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">expon_cdf_vals</span><span class="p">)</span>
    <span class="n">p_sim</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1">_KP4&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">kappa4_cdf_vals</span><span class="p">)</span>
    <span class="n">p_sim</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1">_KDE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">kde_cdf_vals</span><span class="p">)</span>
    <span class="c1"># normalize the distributions </span>
    <span class="n">p_sim</span> <span class="o">/=</span> <span class="n">p_sim</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="c1"># make sure all distributions sum to 1</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">p_sim</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="n">p_sim</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">bin_midpoints</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="c1"># replace the last bin midpoint with half the previous bin&#39;s width</span>
    <span class="c1"># because our right bin edge is np.inf</span>
    <span class="c1"># right_bin_midpoint = edges[-2] + (edges[-2] - edges[-3]) / 2.0</span>
    <span class="c1"># bin_midpoints[-1] = right_bin_midpoint</span>
    <span class="n">p_sim</span><span class="p">[</span><span class="s1">&#39;bin_midpoints&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_midpoints</span>
    <span class="k">return</span> <span class="n">p_sim</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">plot_quantization_comparison</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">stn</span><span class="p">):</span>
    <span class="n">test_fig</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">x_axis_type</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>  

    <span class="c1"># plot empirical (discrete) distributions using linear and log binning</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gold&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">]:</span>
        <span class="n">clr</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s1">_bit_log&#39;</span>
        <span class="n">bin_edges</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">log_bin_edges</span><span class="p">,</span> <span class="n">log_freqs</span> <span class="o">=</span> <span class="n">compute_discrete_distributions</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">stn</span><span class="p">)</span>
        <span class="n">test_fig</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">log_bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">log_bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">top</span><span class="o">=</span><span class="n">log_freqs</span><span class="p">,</span> 
                      <span class="n">bottom</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">freqs</span><span class="p">],</span> <span class="n">legend_label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s1"> bits log bins&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">clr</span><span class="p">,</span> 
                      <span class="n">line_color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># fit and plot a lognormal distribution</span>
    <span class="n">ln_shape</span><span class="p">,</span> <span class="n">ln_loc</span><span class="p">,</span> <span class="n">ln_scale</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">stn</span><span class="p">],</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Fixing location to 0</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">ln_mle_pdf</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ln_shape</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">ln_scale</span><span class="p">)</span>

    <span class="n">kld_test</span> <span class="o">=</span> <span class="n">kl_divergence_between_quantizations</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">stn</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;KLd between </span><span class="si">{</span><span class="n">b1</span><span class="si">}</span><span class="s1"> and </span><span class="si">{</span><span class="n">b2</span><span class="si">}</span><span class="s1"> bit quantizations = </span><span class="si">{</span><span class="n">kld_test</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># fit and plot an exponential distribution</span>
    <span class="n">ex_loc</span><span class="p">,</span> <span class="n">ex_scale</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">stn</span><span class="p">],</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ex_mle_pdf</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">ex_scale</span><span class="p">)</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ln_mle_pdf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;LN MLE pdf&#39;</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ex_mle_pdf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;EXP MLE pdf&#39;</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">background_fill_alpha</span> <span class="o">=</span> <span class="mf">0.6</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="s1">&#39;top_right&#39;</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">click_policy</span><span class="o">=</span><span class="s1">&#39;hide&#39;</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$$\text{Mean Daily Flow } [m^3/s]$$&#39;</span>
    <span class="n">test_fig</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$$P(X)$$&#39;</span>
    <span class="n">test_fig</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">format_fig_fonts</span><span class="p">(</span><span class="n">test_fig</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">test_fig</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qn_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">quantization_noise_results</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">test_bs</span><span class="p">)</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">qn_fig</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">700</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mf">98.5</span><span class="p">]:</span>
    <span class="n">bounds</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">qn_df</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">test_bs</span><span class="p">]</span>
<span class="n">bounds</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">test_bs</span>
<span class="n">qn_fig</span><span class="o">.</span><span class="n">varea</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">test_bs</span><span class="p">,</span> <span class="n">y1</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mf">2.5</span><span class="p">],</span> <span class="n">y2</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mf">98.5</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;95% CI&#39;</span><span class="p">)</span>
<span class="n">qn_fig</span><span class="o">.</span><span class="n">varea</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">test_bs</span><span class="p">,</span> <span class="n">y1</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mi">25</span><span class="p">],</span> <span class="n">y2</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mi">75</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;IQR&#39;</span><span class="p">)</span>
<span class="n">qn_fig</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">test_bs</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mi">50</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;crimson&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;Median&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qn_fig</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$$\text{Noise [bits/sample]}$$&quot;</span>
<span class="n">qn_fig</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$$\text{Dictionary Size (b)} [2^b = \text{N symbols}]$$&quot;</span>
<span class="n">qn_fig</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">format_fig_fonts</span><span class="p">(</span><span class="n">qn_fig</span><span class="p">)</span>
<span class="n">show</span><span class="p">(</span><span class="n">qn_fig</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">stn</span> <span class="o">=</span> <span class="n">filtered_stns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">test_df</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">get_timeseries_data</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">plot_quantization_comparison</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">test_df</span><span class="p">,</span> <span class="n">stn</span><span class="p">)</span>

<span class="n">show</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">bokeh.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">export_png</span>

<span class="n">test_stn</span> <span class="o">=</span> <span class="n">filtered_stns</span>
<span class="k">for</span> <span class="n">stn</span> <span class="ow">in</span> <span class="n">filtered_stns</span><span class="p">:</span>
    <span class="n">output_folder</span> <span class="o">=</span> <span class="s1">&#39;MLE_plots&#39;</span>
    <span class="n">plot_fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_folder</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s2">_LN_and_expon_fits.png&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">plot_fpath</span><span class="p">):</span>
        <span class="k">continue</span>
    <span class="n">test_df</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">get_timeseries_data</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
    <span class="n">test_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">stn</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span> <span class="o">=</span> <span class="n">test_df</span><span class="p">[</span><span class="n">stn</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">test_df</span><span class="p">[</span><span class="n">stn</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="c1"># print(f&#39;X range is {minx:.1f} to {maxx:.1f} cms&#39;)</span>
    <span class="c1"># print(&#39;&#39;)</span>
    
    <span class="n">test_fig</span> <span class="o">=</span> <span class="n">create_MLE_fit_plot</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">test_df</span><span class="p">,</span> <span class="n">stn</span><span class="p">)</span>
    
    <span class="n">export_png</span><span class="p">(</span><span class="n">test_fig</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">plot_fpath</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">stn</span> <span class="ow">in</span> <span class="n">filtered_stns</span><span class="p">:</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">get_timeseries_data</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
    <span class="n">ln_shape</span><span class="p">,</span> <span class="n">ln_loc</span><span class="p">,</span> <span class="n">ln_scale</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">stn</span><span class="p">],</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">expon_loc</span><span class="p">,</span> <span class="n">expon_scale</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">stn</span><span class="p">],</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># kh, kk, k_loc, k_scale = fit_kappa4_mle(df[stn])</span>
    <span class="c1"># kh, kk, k_loc, k_scale = constrained_optimization(df[stn])</span>
    <span class="n">attr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">stn</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;ln_shape&#39;</span><span class="p">,</span> <span class="s1">&#39;ln_loc&#39;</span><span class="p">,</span> <span class="s1">&#39;ln_scale&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ln_shape</span><span class="p">,</span> <span class="n">ln_loc</span><span class="p">,</span> <span class="n">ln_scale</span><span class="p">)</span>
    <span class="n">attr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">stn</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;expon_loc&#39;</span><span class="p">,</span> <span class="s1">&#39;expon_scale&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">expon_loc</span><span class="p">,</span> <span class="n">expon_scale</span><span class="p">)</span>
    <span class="c1"># attr_df.loc[attr_df[&#39;official_id&#39;] == stn, [&#39;kappa_h&#39;, &#39;kappa_k&#39;, &#39;kappa_loc&#39;, &#39;kappa_scale&#39;]] = (kh, kk, k_loc, k_scale)</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">test_bs</span><span class="p">:</span>
        <span class="n">attr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">stn</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s1">_quantization_noise&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kl_divergence_between_quantizations</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">test_bs</span><span class="p">),</span> <span class="n">stn</span><span class="p">)</span> 
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">150</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    ...</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_stns</span><span class="p">)</span><span class="si">}</span><span class="s1"> completed.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># convert the MLE parameters to dicts for easier access</span>
<span class="n">ln_dict</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">attr_df</span>
    <span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;official_id&#39;</span><span class="p">)[[</span><span class="s1">&#39;ln_shape&#39;</span><span class="p">,</span> <span class="s1">&#39;ln_loc&#39;</span><span class="p">,</span> <span class="s1">&#39;ln_scale&#39;</span><span class="p">]]</span>
    <span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">expon_dict</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">attr_df</span>
    <span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;official_id&#39;</span><span class="p">)[[</span><span class="s1">&#39;expon_loc&#39;</span><span class="p">,</span> <span class="s1">&#39;expon_scale&#39;</span><span class="p">]]</span>
    <span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># kappa_dict = (</span>
<span class="c1">#     attr_df</span>
<span class="c1">#     .set_index(&#39;official_id&#39;)[[&#39;kappa_a&#39;, &#39;kappa_b&#39;, &#39;kappa_c&#39;, &#39;kappa_d&#39;]]</span>
<span class="c1">#     .to_dict(orient=&#39;index&#39;)</span>
<span class="c1"># )</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="compute-the-noise-added-to-a-discriminant-value-due-to-assuming-an-error-distribution-as-a-prior">
<h1>Compute the “noise” added to a discriminant value due to assuming an error distribution as a prior<a class="headerlink" href="#compute-the-noise-added-to-a-discriminant-value-due-to-assuming-an-error-distribution-as-a-prior" title="Link to this heading">#</a></h1>
<p>Rating curve uncertainty is a hard problem in hydrology.  Instead of treating daily flow observations as discrete measurements with the fixed (often overzealous) precision that it is published by governing agencies, we can assume some kind of basic error model and test how much the error model distorts the information in the distribution.  In other words, how much noise/uncertainty is added for any model error.</p>
<p>Below we’ll test a range of uniform error distributions as models for the observations.  We’ll take an example streamflow record, and we’ll quantize it to a range of dictionary sizes in two ways.  One way is to bin the observations as they are, we’ll refer to this as the “deterministic” treatment.  The second way is to apply a series of error distribution models, calling it the “stochastic treatment”, and bin the observations by counting the fraction of the observation distribution interval that lies in each bin.  In other words, we’ll count partial observations in proportion to where they fall over the binning intervals as opposed to counting a whole observation based on the interval alone.</p>
<p>The quantization will take in a bitrate <span class="math notranslate nohighlight">\(b\)</span>, and it will divide and log-transform the measured interval <span class="math notranslate nohighlight">\((\log(x_\text{min}),\log(x_\text{max}))\)</span> into <span class="math notranslate nohighlight">\(2^b\)</span> log-spaced bins.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compute_log_uniform_bins</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">stn</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">):</span>
    <span class="n">n_bins</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">bitrate</span>
    <span class="n">min_log_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">stn</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="n">max_log_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">stn</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

    <span class="c1"># set the bin edges to be evenly spaced between the</span>
    <span class="c1"># observed range of the proxy/donor series</span>
    <span class="c1"># np.digitize will assign 0 for out-of-range values at left</span>
    <span class="c1"># and n_bins + 1 for out-of-range values at right</span>
    <span class="n">log_bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
        <span class="n">min_log_val</span><span class="p">,</span>
        <span class="n">max_log_val</span><span class="p">,</span>
        <span class="n">n_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># convert back to linear space</span>
    <span class="n">bin_edges</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="o">**</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">log_bin_edges</span><span class="p">]</span>

    <span class="c1"># there should be n_bins edges which define n_bins - 1 bins</span>
    <span class="c1"># this is to reserve 2 bin for out-of-range values to the right</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_bins</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">bin_edges</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">apply_error_to_observations</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">stn</span><span class="p">,</span> <span class="n">bitrate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="n">min_q</span><span class="p">,</span> <span class="n">max_q</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">stn</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="mf">1e-9</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">stn</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1e-9</span>
    <span class="k">assert</span> <span class="n">min_q</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="c1"># use equal width bins in log10 space</span>
    <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">compute_log_uniform_bins</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">stn</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">)</span>
    <span class="c1"># df[f&#39;{bitrate}_bits_quantized&#39;] = np.digitize(df[stn], bin_edges)</span>
    <span class="n">fractional_obs_counts</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">error_adjusted_fractional_bin_counts</span><span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">stn</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">),</span> <span class="n">bitrate</span><span class="p">,</span> <span class="n">error_factor</span><span class="o">=</span><span class="n">error</span>
    <span class="p">)</span>
    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">error</span><span class="p">)</span><span class="si">}</span><span class="s1">_error&#39;</span>
    <span class="n">count_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">bitrate</span><span class="p">))</span>
    <span class="n">count_df</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">count_df</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fractional_obs_counts</span>
    <span class="n">count_df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">n_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">count_df</span><span class="p">[</span><span class="n">label</span><span class="p">])</span>
    <span class="c1"># normalize p_obs and p_sim</span>
    <span class="k">return</span> <span class="n">count_df</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">n_obs</span>
    
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compute_unadjusted_counts</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">stn</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">):</span>
    <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">compute_log_uniform_bins</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">stn</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">)</span>
    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1">_simple_</span><span class="si">{</span><span class="n">bitrate</span><span class="si">}</span><span class="s1">bits&#39;</span>
    <span class="n">df</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">stn</span><span class="p">],</span> <span class="n">bin_edges</span><span class="p">)</span>
    <span class="c1"># print(df[[stn, f&#39;{stn}_quantized_{bitrate}bits&#39;]].head(4))</span>
    <span class="c1"># count the occurrences of each quantized value</span>
    <span class="c1"># the &quot;simulated&quot; series is the proxy/donor series</span>
    <span class="c1"># and the &quot;observed&quot; series is the target location</span>
    <span class="n">obs_count_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
    <span class="n">count_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">bitrate</span><span class="p">))</span>
    <span class="n">count_df</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">count_df</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="n">obs_count_df</span><span class="p">[</span><span class="n">stn</span><span class="p">]</span>
    <span class="n">count_df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">adjusted_p</span> <span class="o">=</span> <span class="n">count_df</span> <span class="o">/</span> <span class="n">obs_count_df</span><span class="p">[</span><span class="n">stn</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">adjusted_p</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compute_distortion</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
    <span class="n">df</span><span class="p">,</span> <span class="n">stn</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">inputs</span>
    <span class="n">simple_frequencies</span> <span class="o">=</span> <span class="n">compute_unadjusted_counts</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">stn</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">error_adjusted_frequencies</span> <span class="o">=</span> <span class="n">apply_error_to_observations</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">stn</span><span class="p">,</span> <span class="n">bitrate</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">err</span><span class="p">)</span>
    <span class="c1"># compute KL divergence between the simple and adjusted frequencies</span>
    <span class="c1"># this represents the distortion due to the error model</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">simple_frequencies</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">error_adjusted_frequencies</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">distortion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">simple_frequencies</span><span class="p">)</span>
    <span class="n">distortion</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">simple_frequencies</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">simple_frequencies</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/</span> <span class="n">error_adjusted_frequencies</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
    <span class="n">kld</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">distortion</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stn</span><span class="p">,</span> <span class="n">kld</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">err</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="pairwise-processing">
<h1>Pairwise Processing<a class="headerlink" href="#pairwise-processing" title="Link to this heading">#</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>

<span class="c1"># generate all combinations of pairs of station ids</span>
<span class="n">id_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">filtered_stns</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">id_pairs</span><span class="p">)</span><span class="si">}</span><span class="s1"> unique pairings in the dataset&#39;</span><span class="p">)</span>
<span class="c1"># shuffle the pairs to make testing smaller batches more robust</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">id_pairs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># load the attributes file with catchment geometries</span>
<span class="n">geom_file</span> <span class="o">=</span> <span class="s1">&#39;BCUB_watershed_attributes_updated.geojson&#39;</span>
<span class="n">bcub_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">geom_file</span><span class="p">))</span>
<span class="n">bcub_gdf</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bcub_gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set a revision date for the results output file</span>
<span class="n">revision_date</span> <span class="o">=</span> <span class="s1">&#39;20241112&#39;</span>

<span class="c1"># how many pairs to compute in each batch</span>
<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="c1"># batch_size = 10</span>

<span class="c1"># # what percentage of 365 observations in a year counts as a &quot;complete&quot; year</span>
<span class="c1"># completeness_threshold = 0.9</span>
<span class="c1"># min_observations = 365 * 0.9</span>

<span class="c1"># station pairs with less than min_years concurrent years of data are excluded (for concurrent analysis),</span>
<span class="c1"># stations with less than min_years are excluded (for non-concurrent analysis),</span>
<span class="n">min_years</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">#[2, 3, 4, 5, 10]</span>

<span class="c1"># a prior is applied to q in the form of a uniform array of 10**c pseudo-counts &quot;c&quot;</span>
<span class="c1"># this prior is used to test the effect of the choice of prior on the model</span>
<span class="n">pseudo_counts</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="c1"># set the number of quantization levels to test, equal to 2^bitrate</span>
<span class="n">bitrates</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">]</span>

<span class="c1"># Preload all records into a dictionary for fast lookup</span>
<span class="n">records_dict</span> <span class="o">=</span> <span class="n">bcub_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;official_id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">input_batch_generator</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">id_pairs_filtered</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">,</span> 
                          <span class="n">min_years</span><span class="p">,</span> <span class="n">use_partial_counts</span><span class="p">):</span>
    <span class="n">batch_inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">proxy</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">id_pairs_filtered</span><span class="p">:</span>
        
        <span class="n">proxy_dict</span> <span class="o">=</span> <span class="n">records_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">proxy</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">target_dict</span> <span class="o">=</span> <span class="n">records_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="p">{})</span>

        <span class="n">proxy_dict</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">proxy</span>
        <span class="n">target_dict</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span>

        <span class="k">assert</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">in</span> <span class="n">proxy_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">proxy_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">assert</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">in</span> <span class="n">target_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">target_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        
        <span class="n">batch</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">proxy_dict</span><span class="p">,</span> <span class="n">target_dict</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">,</span> 
            <span class="n">min_years</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">batch_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">batch_inputs</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">temp_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="s1">&#39;data/&#39;</span><span class="p">,</span> <span class="s1">&#39;temp&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">temp_dir</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">temp_dir</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">simulated_parametric_probabilities</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">proxy</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;simulate the target using the parametric MLE parameters from the proxy&quot;&quot;&quot;</span>
    <span class="n">ln_params</span> <span class="o">=</span> <span class="n">ln_dict</span><span class="p">[</span><span class="n">proxy</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>
    <span class="n">exp_params</span> <span class="o">=</span> <span class="n">expon_dict</span><span class="p">[</span><span class="n">proxy</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>
    <span class="n">p_sim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">bin_edges</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">bin_edges</span> <span class="o">+</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>

    <span class="c1"># ln_pdf_vals = lognorm.pdf(bin_midpoints, ln_params[&#39;ln_shape&#39;], loc=ln_params[&#39;ln_loc&#39;], scale=ln_params[&#39;ln_scale&#39;])</span>
    <span class="c1"># expon_pdf_vals = expon.pdf(bin_midpoints, loc=ln_params[&#39;ln_loc&#39;], scale=ln_params[&#39;ln_scale&#39;])</span>
    <span class="n">ln_cdf_vals</span> <span class="o">=</span> <span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">ln_params</span><span class="p">[</span><span class="s1">&#39;ln_shape&#39;</span><span class="p">],</span> 
                              <span class="n">loc</span><span class="o">=</span><span class="n">ln_params</span><span class="p">[</span><span class="s1">&#39;ln_loc&#39;</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">ln_params</span><span class="p">[</span><span class="s1">&#39;ln_scale&#39;</span><span class="p">])</span>
    <span class="n">expon_cdf_vals</span> <span class="o">=</span> <span class="n">expon</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">ln_params</span><span class="p">[</span><span class="s1">&#39;ln_loc&#39;</span><span class="p">],</span> 
                               <span class="n">scale</span><span class="o">=</span><span class="n">ln_params</span><span class="p">[</span><span class="s1">&#39;ln_scale&#39;</span><span class="p">])</span>
    <span class="c1"># p_sim[target.ln_pdf_label] = ln_pdf_vals</span>
    <span class="n">p_sim</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">ln_cdf_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ln_cdf_vals</span><span class="p">)</span>
    <span class="c1"># p_sim[target.expon_pdf_label] = expon_pdf_vals</span>
    <span class="n">p_sim</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">expon_cdf_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">expon_cdf_vals</span><span class="p">)</span>

    <span class="c1"># normalize the distributions</span>
    <span class="n">p_sim</span> <span class="o">/=</span> <span class="n">p_sim</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">p_sim</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="n">p_sim</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">p_sim</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">process_KL_divergence</span><span class="p">(</span><span class="n">p_obs</span><span class="p">,</span> <span class="n">p_sim</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">,</span> <span class="n">concurrent_data</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes the Kullback-Leibler (KL) divergence between observed and simulated probability distributions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p_obs : np.ndarray</span>
<span class="sd">        The observed probability distribution.</span>
<span class="sd">    p_sim : pd.DataFrame</span>
<span class="sd">        A DataFrame containing the simulated probability distributions with different priors.</span>
<span class="sd">    bitrate : int</span>
<span class="sd">        The number of bits used for quantizing the observed series.</span>
<span class="sd">    concurrent_data : bool</span>
<span class="sd">        A flag indicating whether the data is concurrent.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.Series</span>
<span class="sd">        A series containing the sum of KL divergences for each simulated distribution.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        If any value in the simulated distribution is zero, which should not happen due to the addition of pseudo-counts.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function computes the KL divergence for each simulated distribution in `p_sim`.</span>
<span class="sd">    - It ensures that the probability distributions sum to 1 before computing the divergence.</span>
<span class="sd">    - If the data is concurrent, the divergence labels are prefixed with &#39;dkl_concurrent_&#39;, otherwise &#39;dkl_nonconcurrent_&#39;.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; p_obs = np.array([0.2, 0.3, 0.5])</span>
<span class="sd">    &gt;&gt;&gt; p_sim = pd.DataFrame({&#39;q_post_0.1R&#39;: [0.1, 0.4, 0.5], &#39;q_post_0.5R&#39;: [0.2, 0.3, 0.5]})</span>
<span class="sd">    &gt;&gt;&gt; bitrate = 3</span>
<span class="sd">    &gt;&gt;&gt; concurrent_data = True</span>
<span class="sd">    &gt;&gt;&gt; sum_dkl = process_KL_divergence(p_obs, p_sim, bitrate, concurrent_data)</span>
<span class="sd">    &gt;&gt;&gt; print(sum_dkl)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># dkl_df = uf.compute_kl_divergence(p_obs, p_sim, bitrate, concurrent_data)</span>

    <span class="c1"># explicitly set data types before vectorization</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p_obs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;bin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">bitrate</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;bin&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">small_val_flags</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">p_sim</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;dkl_nonconcurrent_&quot;</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">if</span> <span class="n">concurrent_data</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;dkl_concurrent_&quot;</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p_sim</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> 
        <span class="n">small_values</span> <span class="o">=</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">epsilon</span>
        <span class="n">kld_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kld_array</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/</span> <span class="n">q</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="n">df</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">kld_array</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">small_values</span><span class="p">):</span>
            <span class="n">small_val_flags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">n_flags</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">small_val_flags</span><span class="p">)</span>
    <span class="n">q_flag</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">n_flags</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">q_flag</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">small_val_flags</span><span class="p">)</span>
        <span class="c1"># print(q_flag)</span>
    <span class="n">sum_dkl</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sum_dkl</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;negative or zero dkl&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">sum_dkl</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;negative or zero dkl&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sum_dkl</span><span class="p">,</span> <span class="n">q_flag</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">process_divergences</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">p_obs</span><span class="p">,</span> <span class="n">p_sim</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">,</span> <span class="n">concurrent_data</span><span class="p">):</span>
    <span class="n">dkl</span><span class="p">,</span> <span class="n">q_flag</span> <span class="o">=</span> <span class="n">process_KL_divergence</span><span class="p">(</span><span class="n">p_obs</span><span class="p">,</span> <span class="n">p_sim</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">,</span> <span class="n">concurrent_data</span><span class="p">)</span>

    <span class="c1"># p = p_obs</span>
    <span class="c1"># q = p_sim[&quot;q_sim_no_prior&quot;].values</span>
    <span class="c1"># q_uniform = p_sim[&quot;q_uniform&quot;].values</span>
    <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dkl</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;small_q_flag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_flag</span>

    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">process_probabilities</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span> <span class="n">proxy</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">,</span> <span class="n">concurrent_data</span><span class="p">,</span> <span class="c1">#pseudo_counts, p_errors</span>
<span class="p">):</span>
    <span class="n">target</span><span class="o">.</span><span class="n">obs_quantized_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;obs_quantized_</span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">bitrate</span><span class="si">}</span><span class="s2">b&quot;</span>
    <span class="n">target</span><span class="o">.</span><span class="n">sim_quantized_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;sim_quantized_</span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">bitrate</span><span class="si">}</span><span class="s2">b&quot;</span>
    <span class="c1"># compute the bin edges based on equal width in log space</span>
    <span class="c1"># binning should be done on the &#39;ground truth&#39; observed range (the target)</span>
    <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">uniform_log_bins</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">)</span>

    <span class="n">simple_count_df</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">compute_unadjusted_counts</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">,</span> <span class="n">concurrent_data</span>
    <span class="p">)</span>
    
    <span class="n">p_obs</span> <span class="o">=</span> <span class="n">simple_count_df</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">obs_label</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">simple_count_df</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">obs_label</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># add a uniformly distributed error to the observed data</span>
    <span class="c1"># and compute probabilities from partial observation counts</span>
    <span class="c1"># where counts are divided based on the proportion of the bin</span>
    <span class="c1"># that the measurement error falls within</span>
    <span class="n">fractional_obs_counts</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">error_adjusted_fractional_bin_counts</span><span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">obs_label</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">),</span> <span class="n">bitrate</span><span class="p">,</span> <span class="n">error_factor</span><span class="o">=</span><span class="mf">0.1</span>
    <span class="p">)</span>
    <span class="n">fractional_sim_counts</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">error_adjusted_fractional_bin_counts</span><span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">sim_label</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">),</span> <span class="n">bitrate</span><span class="p">,</span> <span class="n">error_factor</span><span class="o">=</span><span class="mf">0.1</span>
    <span class="p">)</span>

    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
    <span class="c1"># print(f&#39; {t1-t0:.2f}s to process fractional bin counts&#39;)</span>

    <span class="n">partial_count_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">bitrate</span><span class="p">))</span>
    <span class="n">partial_count_df</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">obs_label</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">partial_count_df</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">sim_label</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">partial_count_df</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">obs_label</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fractional_obs_counts</span>
    <span class="n">partial_count_df</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">sim_label</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fractional_sim_counts</span>
    <span class="n">partial_count_df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">partial_count_df</span> <span class="o">/=</span> <span class="n">partial_count_df</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    
    <span class="c1"># Check if the sums are close enough to 1 within a tolerance of 0.001</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">partial_count_df</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="n">partial_count_df</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">p_sim</span> <span class="o">=</span> <span class="n">simulated_parametric_probabilities</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">proxy</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">p_obs</span><span class="p">,</span> <span class="n">p_sim</span><span class="p">,</span> <span class="n">bin_edges</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">process_batch</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>    
    <span class="p">(</span>
        <span class="n">proxy</span><span class="p">,</span>
        <span class="n">target</span><span class="p">,</span>
        <span class="n">bitrate</span><span class="p">,</span>
        <span class="n">min_concurrent_years</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">inputs</span>
    
    <span class="n">proxy_id</span><span class="p">,</span> <span class="n">target_id</span> <span class="o">=</span> <span class="n">proxy</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">],</span> <span class="n">target</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span>
    <span class="n">bitrate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bitrate</span><span class="p">)</span>

    <span class="c1"># create a result dict object for tracking results of the batch comparison</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;proxy&quot;</span><span class="p">:</span> <span class="n">proxy_id</span><span class="p">,</span>
        <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">target_id</span><span class="p">,</span>
        <span class="s2">&quot;bitrate&quot;</span><span class="p">:</span> <span class="n">bitrate</span><span class="p">,</span>
        <span class="s2">&quot;min_concurrent_years&quot;</span><span class="p">:</span> <span class="n">min_concurrent_years</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">station_info</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;proxy&quot;</span><span class="p">:</span> <span class="n">proxy</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">target</span><span class="p">}</span>

    <span class="c1"># check if the polygons are nested</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;nested_catchments&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">check_if_nested</span><span class="p">(</span>
        <span class="n">proxy</span><span class="p">,</span> <span class="n">target</span>
    <span class="p">)</span>

    <span class="c1"># for stn in pair:</span>
    <span class="n">proxy</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">Station</span><span class="p">(</span><span class="n">station_info</span><span class="p">[</span><span class="s2">&quot;proxy&quot;</span><span class="p">])</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">Station</span><span class="p">(</span><span class="n">station_info</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">])</span>
    <span class="n">target</span><span class="o">.</span><span class="n">ln_pdf_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">_sim_lognorm_pdf&#39;</span>
    <span class="n">target</span><span class="o">.</span><span class="n">ln_cdf_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">_sim_lognorm_cdf&#39;</span>
    <span class="n">target</span><span class="o">.</span><span class="n">expon_pdf_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">_sim_expon_pdf&#39;</span>
    <span class="n">target</span><span class="o">.</span><span class="n">expon_cdf_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">_sim_expon_cdf&#39;</span>

    <span class="c1"># compute spatial distance</span>
    <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">station_info</span><span class="p">[</span><span class="s2">&quot;proxy&quot;</span><span class="p">][</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span><span class="p">,</span>
        <span class="n">station_info</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">][</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># compute the distance between catchment centroids (km)</span>
    <span class="n">centroid_distance</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;centroid_distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">centroid_distance</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">centroid_distance</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">drainage_area_km2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No drainage area for </span><span class="si">{</span><span class="n">target_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">proxy</span><span class="o">.</span><span class="n">drainage_area_km2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No drainage area for </span><span class="si">{</span><span class="n">proxy_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Retrieve the data for both stations</span>
    <span class="c1"># this is all data, including non-concurrent</span>
    <span class="n">adf</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">retrieve_nonconcurrent_data</span><span class="p">(</span><span class="n">proxy_id</span><span class="p">,</span> <span class="n">target_id</span><span class="p">)</span>

    <span class="k">assert</span> <span class="o">~</span><span class="n">adf</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span> <span class="s2">&quot;No data returned.&quot;</span>

    <span class="k">for</span> <span class="n">stn</span> <span class="ow">in</span> <span class="p">[</span><span class="n">proxy</span><span class="p">,</span> <span class="n">target</span><span class="p">]:</span>
        <span class="n">adf</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">transform_and_jitter</span><span class="p">(</span><span class="n">adf</span><span class="p">,</span> <span class="n">stn</span><span class="p">)</span>

    <span class="c1"># simulate flow at the target based on equal unit area runoff scaling</span>
    <span class="n">adf</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">sim_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">adf</span><span class="p">[</span><span class="n">proxy</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
        <span class="n">target</span><span class="o">.</span><span class="n">drainage_area_km2</span> <span class="o">/</span> <span class="n">proxy</span><span class="o">.</span><span class="n">drainage_area_km2</span>
    <span class="p">)</span>

    <span class="c1"># filter for the concurrent data</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">adf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">proxy_id</span><span class="p">,</span> <span class="n">target_id</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;any&quot;</span><span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;num_concurrent_obs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="n">num_complete_concurrent_years</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">num_complete_concurrent_years</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">count_complete_years</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">proxy_id</span><span class="p">)</span>
        
    <span class="n">counts</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="n">proxy_id</span><span class="p">,</span> <span class="n">target_id</span><span class="p">]]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">adf</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">proxy</span><span class="o">.</span><span class="n">n_obs</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">n_obs</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">proxy_id</span><span class="p">],</span> <span class="n">counts</span><span class="p">[</span><span class="n">target_id</span><span class="p">]</span>
    <span class="n">result</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;proxy_n_obs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">proxy</span><span class="o">.</span><span class="n">n_obs</span>
    <span class="n">result</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;target_n_obs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">n_obs</span>
    <span class="n">result</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;proxy_frac_concurrent&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">/</span> <span class="n">proxy</span><span class="o">.</span><span class="n">n_obs</span>
    <span class="n">result</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;target_frac_concurrent&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">/</span> <span class="n">target</span><span class="o">.</span><span class="n">n_obs</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">proxy_id</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">target_id</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Zero observations.  Skipping.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># process the PMFs and divergences for concurrent data</span>
    <span class="c1"># using a range of uniform priors via pseudo counts</span>
    <span class="k">if</span> <span class="n">num_complete_concurrent_years</span> <span class="o">&gt;</span> <span class="n">min_concurrent_years</span><span class="p">:</span>
        <span class="c1"># df is concurrent data, so the results</span>
        <span class="c1"># are updating concurrent data here</span>
        <span class="c1"># df, proxy, target, bitrate, concurrent_data, partial_counts, pseudo_counts</span>
        <span class="n">concurrent_data</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">p_obs</span><span class="p">,</span> <span class="n">p_sim</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">process_probabilities</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span> <span class="n">proxy</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">,</span> <span class="n">concurrent_data</span><span class="p">,</span> <span class="c1">#pseudo_counts, p_errors</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">n_obs</span> <span class="o">&gt;</span> <span class="mi">365</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">proxy</span><span class="o">.</span><span class="n">n_obs</span> <span class="o">&gt;</span> <span class="mi">365</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">):</span>
        <span class="c1"># adf is all data (includes non-concurrent), so the results</span>
        <span class="c1"># are updated if both series meet the minimum length</span>
        <span class="n">concurrent_data</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">p_obs</span><span class="p">,</span> <span class="n">p_sim</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">process_probabilities</span><span class="p">(</span>
            <span class="n">adf</span><span class="p">,</span> <span class="n">proxy</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">,</span> <span class="n">concurrent_data</span><span class="p">,</span><span class="c1"># pseudo_counts, p_errors</span>
        <span class="p">)</span>
        
    <span class="n">result</span> <span class="o">=</span> <span class="n">process_divergences</span><span class="p">(</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">p_obs</span><span class="p">,</span> <span class="n">p_sim</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">,</span> <span class="n">concurrent_data</span>
    <span class="p">)</span>

    <span class="n">noise</span> <span class="o">=</span> <span class="n">process_noise</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">p_obs</span><span class="p">,</span> <span class="n">p_sim</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">,</span> <span class="n">concurrent_data</span><span class="p">)</span>
    <span class="c1"># result[&#39;underspecified_model_flag&#39;] = underspecified_flag</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># the &#39;process&#39; variable is here so jupyter doesn&#39;t go computing </span>
<span class="c1"># a million rows per iteration when the book is built for pushing to github pages.</span>
<span class="c1"># reordered_bitrates = [4, 6, 8, 10, 12, 3, 5, 7, 9, 11]</span>
<span class="n">process</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">partial_counts</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">if</span> <span class="n">process</span><span class="p">:</span> 
    <span class="k">for</span> <span class="n">bitrate</span> <span class="ow">in</span> <span class="n">reordered_bitrates</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Processing pairs at </span><span class="si">{</span><span class="n">bitrate</span><span class="si">}</span><span class="s1"> bits quantization &#39;</span><span class="p">)</span>
        <span class="n">results_fname</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;KL_parametric_fits_</span><span class="si">{</span><span class="n">bitrate</span><span class="si">}</span><span class="s1">bits_</span><span class="si">{</span><span class="n">revision_date</span><span class="si">}</span><span class="s1">.csv&#39;</span>

        <span class="n">out_fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data/&#39;</span><span class="p">,</span> <span class="s1">&#39;parametric_divergence_test&#39;</span><span class="p">,</span> <span class="n">results_fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">out_fpath</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="n">n_batches</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">id_pairs</span><span class="p">)</span> <span class="o">//</span> <span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">batches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">id_pairs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">),</span> <span class="n">n_batches</span><span class="p">)</span>
        <span class="n">n_pairs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_pairs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;    Processing </span><span class="si">{</span><span class="n">n_pairs</span><span class="si">}</span><span class="s2"> pairs in </span><span class="si">{</span><span class="n">n_batches</span><span class="si">}</span><span class="s2"> batches at </span><span class="si">{</span><span class="n">bitrate</span><span class="si">}</span><span class="s2"> bits&quot;</span>
        <span class="p">)</span>
        <span class="n">batch_no</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">batch_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="c1"># error_df = error_model_df[error_model_df[&#39;bitrate&#39;] == bitrate].copy()</span>
        <span class="k">for</span> <span class="n">batch_ids</span> <span class="ow">in</span> <span class="n">batches</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Starting batch </span><span class="si">{</span><span class="n">batch_no</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">batches</span><span class="p">)</span><span class="si">}</span><span class="s1"> processing.&#39;</span><span class="p">)</span>
            <span class="n">batch_fname</span> <span class="o">=</span> <span class="n">results_fname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.csv&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;_batch_</span><span class="si">{</span><span class="n">batch_no</span><span class="si">:</span><span class="s1">03d</span><span class="si">}</span><span class="s1">.csv&#39;</span><span class="p">)</span>
            <span class="n">batch_output_fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">temp_dir</span><span class="p">,</span> <span class="n">batch_fname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">batch_output_fpath</span><span class="p">):</span>
                <span class="n">batch_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batch_output_fpath</span><span class="p">)</span>
                <span class="n">batch_no</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            
            <span class="c1"># define the input array for multiprocessing</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">input_batch_generator</span><span class="p">(</span><span class="n">bcub_gdf</span><span class="p">,</span> <span class="n">batch_ids</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">,</span>
                     <span class="n">min_years</span><span class="p">,</span> <span class="n">partial_counts</span><span class="p">)</span>

            <span class="k">with</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">process_batch</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

            <span class="n">batch_result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">batch_result</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Empty batch.  Skipping&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">batch_result</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">batch_output_fpath</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Saved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">batch_result</span><span class="p">)</span><span class="si">}</span><span class="s2"> new results to file.&quot;</span><span class="p">)</span>
            
            <span class="n">batch_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batch_output_fpath</span><span class="p">)</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    Processed </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">batch_ids</span><span class="p">)</span><span class="si">}</span><span class="s1"> pairs at (</span><span class="si">{</span><span class="n">bitrate</span><span class="si">}</span><span class="s1"> bits) in </span><span class="si">{</span><span class="n">t2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1"> seconds&#39;</span><span class="p">)</span>
            <span class="n">batch_no</span> <span class="o">+=</span> <span class="mi">1</span>
            
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    Concatenating </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">batch_files</span><span class="p">)</span><span class="si">}</span><span class="s1"> batch files.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_files</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">all_results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;pyarrow&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">batch_files</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">all_results</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">out_fpath</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">out_fpath</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">batch_files</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    Wrote </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_results</span><span class="p">)</span><span class="si">}</span><span class="s1"> results to </span><span class="si">{</span><span class="n">out_fpath</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    No new results to write to file.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="citations">
<h1>Citations<a class="headerlink" href="#citations" title="Link to this heading">#</a></h1>
<span class="target" id="id2"></span></section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notebooks/ss"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Parametric FDC Estimation</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#methodology">Methodology</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#general-data-processing-functions">General data processing functions</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#estimate-entropy">Estimate entropy</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#define-a-measurement-error-model">Define a measurement error model</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#id1"></a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#compute-the-noise-added-to-a-discriminant-value-due-to-assuming-an-error-distribution-as-a-prior">Compute the “noise” added to a discriminant value due to assuming an error distribution as a prior</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#pairwise-processing">Pairwise Processing</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#citations">Citations</a></li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Dan Kovacek
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>