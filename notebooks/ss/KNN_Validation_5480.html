
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Non-Parametric Simulation &#8212; Streamflow Distribution Estimation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/ss/KNN_Validation_5480';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="Streamflow Distribution Estimation - Home"/>
    <script>document.write(`<img src="../../_static/logo.png" class="logo__image only-dark" alt="Streamflow Distribution Estimation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Introduction
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../1_data.html">Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2_Methods.html">Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_Predict_Runoff_Statistics.html">Predict Runoff Statistics from Catchment Attributes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5_FDC_Estimation.html">Non-Parametric Simulation</a></li>


<li class="toctree-l1"><a class="reference internal" href="../6_Large_Sample_Results_Comparison.html">Notes</a></li>




</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/dankovacek/divergence_estimation" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/dankovacek/divergence_estimation/issues/new?title=Issue%20on%20page%20%2Fnotebooks/ss/KNN_Validation_5480.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/notebooks/ss/KNN_Validation_5480.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Non-Parametric Simulation</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Non-Parametric Simulation</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#time-based-ensemble">Time-based ensemble</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#frequency-based-ensembles">Frequency-based ensembles</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#notes-on-k-nearest-neighbours">Notes on k-nearest neighbours</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#summary-set-theoretic-foundations-of-strict-k-nn-concurrency-selection">Summary: Set-Theoretic Foundations of Strict k-NN Concurrency Selection</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#set-theoretic-definition">Set-Theoretic Definition</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#related-concepts">Related Concepts</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#practical-implication">Practical Implication</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#define-a-universal-parametric-prior">Define a universal parametric prior</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#global-uniform-prior">Global Uniform Prior</a></li>
</ul>
</li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">time</span><span class="w"> </span><span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">cKDTree</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">xgboost</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xgb</span>
<span class="n">xgb</span><span class="o">.</span><span class="n">config_context</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">laplace</span><span class="p">,</span> <span class="n">genextreme</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">jax</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">jax.numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">jnp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">jax</span><span class="w"> </span><span class="kn">import</span> <span class="n">jit</span>

<span class="c1"># from KDEpy import FFTKDE</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">kde_estimator</span><span class="w"> </span><span class="kn">import</span> <span class="n">KDEEstimator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">fdc_estimator_context</span><span class="w"> </span><span class="kn">import</span> <span class="n">FDCEstimationContext</span> 
<span class="kn">from</span><span class="w"> </span><span class="nn">fdc_data</span><span class="w"> </span><span class="kn">import</span> <span class="n">StationData</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">data_processing_functions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dpf</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">concurrent.futures</span><span class="w"> </span><span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="n">BASE_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ModuleNotFoundError</span><span class="g g-Whitespace">                       </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">line</span> <span class="mi">23</span>
<span class="g g-Whitespace">     </span><span class="mi">19</span> <span class="kn">from</span><span class="w"> </span><span class="nn">jax</span><span class="w"> </span><span class="kn">import</span> <span class="n">jit</span>
<span class="g g-Whitespace">     </span><span class="mi">21</span> <span class="c1"># from KDEpy import FFTKDE</span>
<span class="ne">---&gt; </span><span class="mi">23</span> <span class="kn">from</span><span class="w"> </span><span class="nn">kde_estimator</span><span class="w"> </span><span class="kn">import</span> <span class="n">KDEEstimator</span>
<span class="g g-Whitespace">     </span><span class="mi">24</span> <span class="kn">from</span><span class="w"> </span><span class="nn">fdc_estimator_context</span><span class="w"> </span><span class="kn">import</span> <span class="n">FDCEstimationContext</span> 
<span class="g g-Whitespace">     </span><span class="mi">25</span> <span class="kn">from</span><span class="w"> </span><span class="nn">fdc_data</span><span class="w"> </span><span class="kn">import</span> <span class="n">StationData</span>

<span class="ne">ModuleNotFoundError</span>: No module named &#39;kde_estimator&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">bokeh.plotting</span><span class="w"> </span><span class="kn">import</span> <span class="n">figure</span><span class="p">,</span> <span class="n">show</span><span class="p">,</span> <span class="n">output_notebook</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bokeh.layouts</span><span class="w"> </span><span class="kn">import</span> <span class="n">gridplot</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">xyzservices.providers</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xyz</span>
<span class="n">tiles</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;USGS&#39;</span><span class="p">][</span><span class="s1">&#39;USTopo&#39;</span><span class="p">]</span>
<span class="n">output_notebook</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">    <style>
        .bk-notebook-logo {
            display: block;
            width: 20px;
            height: 20px;
            background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAOkSURBVDiNjZRtaJVlGMd/1/08zzln5zjP1LWcU9N0NkN8m2CYjpgQYQXqSs0I84OLIC0hkEKoPtiH3gmKoiJDU7QpLgoLjLIQCpEsNJ1vqUOdO7ppbuec5+V+rj4ctwzd8IIbbi6u+8f1539dt3A78eXC7QizUF7gyV1fD1Yqg4JWz84yffhm0qkFqBogB9rM8tZdtwVsPUhWhGcFJngGeWrPzHm5oaMmkfEg1usvLFyc8jLRqDOMru7AyC8saQr7GG7f5fvDeH7Ej8CM66nIF+8yngt6HWaKh7k49Soy9nXurCi1o3qUbS3zWfrYeQDTB/Qj6kX6Ybhw4B+bOYoLKCC9H3Nu/leUTZ1JdRWkkn2ldcCamzrcf47KKXdAJllSlxAOkRgyHsGC/zRday5Qld9DyoM4/q/rUoy/CXh3jzOu3bHUVZeU+DEn8FInkPBFlu3+nW3Nw0mk6vCDiWg8CeJaxEwuHS3+z5RgY+YBR6V1Z1nxSOfoaPa4LASWxxdNp+VWTk7+4vzaou8v8PN+xo+KY2xsw6une2frhw05CTYOmQvsEhjhWjn0bmXPjpE1+kplmmkP3suftwTubK9Vq22qKmrBhpY4jvd5afdRA3wGjFAgcnTK2s4hY0/GPNIb0nErGMCRxWOOX64Z8RAC4oCXdklmEvcL8o0BfkNK4lUg9HTl+oPlQxdNo3Mg4Nv175e/1LDGzZen30MEjRUtmXSfiTVu1kK8W4txyV6BMKlbgk3lMwYCiusNy9fVfvvwMxv8Ynl6vxoByANLTWplvuj/nF9m2+PDtt1eiHPBr1oIfhCChQMBw6Aw0UulqTKZdfVvfG7VcfIqLG9bcldL/+pdWTLxLUy8Qq38heUIjh4XlzZxzQm19lLFlr8vdQ97rjZVOLf8nclzckbcD4wxXMidpX30sFd37Fv/GtwwhzhxGVAprjbg0gCAEeIgwCZyTV2Z1REEW8O4py0wsjeloKoMr6iCY6dP92H6Vw/oTyICIthibxjm/DfN9lVz8IqtqKYLUXfoKVMVQVVJOElGjrnnUt9T9wbgp8AyYKaGlqingHZU/uG2NTZSVqwHQTWkx9hxjkpWDaCg6Ckj5qebgBVbT3V3NNXMSiWSDdGV3hrtzla7J+duwPOToIg42ChPQOQjspnSlp1V+Gjdged7+8UN5CRAV7a5EdFNwCjEaBR27b3W890TE7g24NAP/mMDXRWrGoFPQI9ls/MWO2dWFAar/xcOIImbbpA3zgAAAABJRU5ErkJggg==);
        }
    </style>
    <div>
        <a href="https://bokeh.org" target="_blank" class="bk-notebook-logo"></a>
        <span id="dc622cf9-f603-4278-ab96-f95f1ce55206">Loading BokehJS ...</span>
    </div>
</div><script type="application/javascript">'use strict';
(function(root) {
  function now() {
    return new Date();
  }

  const force = true;

  if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
    root._bokeh_onload_callbacks = [];
    root._bokeh_is_loading = undefined;
  }

const JS_MIME_TYPE = 'application/javascript';
  const HTML_MIME_TYPE = 'text/html';
  const EXEC_MIME_TYPE = 'application/vnd.bokehjs_exec.v0+json';
  const CLASS_NAME = 'output_bokeh rendered_html';

  /**
   * Render data to the DOM node
   */
  function render(props, node) {
    const script = document.createElement("script");
    node.appendChild(script);
  }

  /**
   * Handle when an output is cleared or removed
   */
  function handleClearOutput(event, handle) {
    function drop(id) {
      const view = Bokeh.index.get_by_id(id)
      if (view != null) {
        view.model.document.clear()
        Bokeh.index.delete(view)
      }
    }

    const cell = handle.cell;

    const id = cell.output_area._bokeh_element_id;
    const server_id = cell.output_area._bokeh_server_id;

    // Clean up Bokeh references
    if (id != null) {
      drop(id)
    }

    if (server_id !== undefined) {
      // Clean up Bokeh references
      const cmd_clean = "from bokeh.io.state import curstate; print(curstate().uuid_to_server['" + server_id + "'].get_sessions()[0].document.roots[0]._id)";
      cell.notebook.kernel.execute(cmd_clean, {
        iopub: {
          output: function(msg) {
            const id = msg.content.text.trim()
            drop(id)
          }
        }
      });
      // Destroy server and session
      const cmd_destroy = "import bokeh.io.notebook as ion; ion.destroy_server('" + server_id + "')";
      cell.notebook.kernel.execute(cmd_destroy);
    }
  }

  /**
   * Handle when a new output is added
   */
  function handleAddOutput(event, handle) {
    const output_area = handle.output_area;
    const output = handle.output;

    // limit handleAddOutput to display_data with EXEC_MIME_TYPE content only
    if ((output.output_type != "display_data") || (!Object.prototype.hasOwnProperty.call(output.data, EXEC_MIME_TYPE))) {
      return
    }

    const toinsert = output_area.element.find("." + CLASS_NAME.split(' ')[0]);

    if (output.metadata[EXEC_MIME_TYPE]["id"] !== undefined) {
      toinsert[toinsert.length - 1].firstChild.textContent = output.data[JS_MIME_TYPE];
      // store reference to embed id on output_area
      output_area._bokeh_element_id = output.metadata[EXEC_MIME_TYPE]["id"];
    }
    if (output.metadata[EXEC_MIME_TYPE]["server_id"] !== undefined) {
      const bk_div = document.createElement("div");
      bk_div.innerHTML = output.data[HTML_MIME_TYPE];
      const script_attrs = bk_div.children[0].attributes;
      for (let i = 0; i < script_attrs.length; i++) {
        toinsert[toinsert.length - 1].firstChild.setAttribute(script_attrs[i].name, script_attrs[i].value);
        toinsert[toinsert.length - 1].firstChild.textContent = bk_div.children[0].textContent
      }
      // store reference to server id on output_area
      output_area._bokeh_server_id = output.metadata[EXEC_MIME_TYPE]["server_id"];
    }
  }

  function register_renderer(events, OutputArea) {

    function append_mime(data, metadata, element) {
      // create a DOM node to render to
      const toinsert = this.create_output_subarea(
        metadata,
        CLASS_NAME,
        EXEC_MIME_TYPE
      );
      this.keyboard_manager.register_events(toinsert);
      // Render to node
      const props = {data: data, metadata: metadata[EXEC_MIME_TYPE]};
      render(props, toinsert[toinsert.length - 1]);
      element.append(toinsert);
      return toinsert
    }

    /* Handle when an output is cleared or removed */
    events.on('clear_output.CodeCell', handleClearOutput);
    events.on('delete.Cell', handleClearOutput);

    /* Handle when a new output is added */
    events.on('output_added.OutputArea', handleAddOutput);

    /**
     * Register the mime type and append_mime function with output_area
     */
    OutputArea.prototype.register_mime_type(EXEC_MIME_TYPE, append_mime, {
      /* Is output safe? */
      safe: true,
      /* Index of renderer in `output_area.display_order` */
      index: 0
    });
  }

  // register the mime type if in Jupyter Notebook environment and previously unregistered
  if (root.Jupyter !== undefined) {
    const events = require('base/js/events');
    const OutputArea = require('notebook/js/outputarea').OutputArea;

    if (OutputArea.prototype.mime_types().indexOf(EXEC_MIME_TYPE) == -1) {
      register_renderer(events, OutputArea);
    }
  }
  if (typeof (root._bokeh_timeout) === "undefined" || force === true) {
    root._bokeh_timeout = Date.now() + 5000;
    root._bokeh_failed_load = false;
  }

  const NB_LOAD_WARNING = {'data': {'text/html':
     "<div style='background-color: #fdd'>\n"+
     "<p>\n"+
     "BokehJS does not appear to have successfully loaded. If loading BokehJS from CDN, this \n"+
     "may be due to a slow or bad network connection. Possible fixes:\n"+
     "</p>\n"+
     "<ul>\n"+
     "<li>re-rerun `output_notebook()` to attempt to load from CDN again, or</li>\n"+
     "<li>use INLINE resources instead, as so:</li>\n"+
     "</ul>\n"+
     "<code>\n"+
     "from bokeh.resources import INLINE\n"+
     "output_notebook(resources=INLINE)\n"+
     "</code>\n"+
     "</div>"}};

  function display_loaded(error = null) {
    const el = document.getElementById("dc622cf9-f603-4278-ab96-f95f1ce55206");
    if (el != null) {
      const html = (() => {
        if (typeof root.Bokeh === "undefined") {
          if (error == null) {
            return "BokehJS is loading ...";
          } else {
            return "BokehJS failed to load.";
          }
        } else {
          const prefix = `BokehJS ${root.Bokeh.version}`;
          if (error == null) {
            return `${prefix} successfully loaded.`;
          } else {
            return `${prefix} <b>encountered errors</b> while loading and may not function as expected.`;
          }
        }
      })();
      el.innerHTML = html;

      if (error != null) {
        const wrapper = document.createElement("div");
        wrapper.style.overflow = "auto";
        wrapper.style.height = "5em";
        wrapper.style.resize = "vertical";
        const content = document.createElement("div");
        content.style.fontFamily = "monospace";
        content.style.whiteSpace = "pre-wrap";
        content.style.backgroundColor = "rgb(255, 221, 221)";
        content.textContent = error.stack ?? error.toString();
        wrapper.append(content);
        el.append(wrapper);
      }
    } else if (Date.now() < root._bokeh_timeout) {
      setTimeout(() => display_loaded(error), 100);
    }
  }

  function run_callbacks() {
    try {
      root._bokeh_onload_callbacks.forEach(function(callback) {
        if (callback != null)
          callback();
      });
    } finally {
      delete root._bokeh_onload_callbacks
    }
    console.debug("Bokeh: all callbacks have finished");
  }

  function load_libs(css_urls, js_urls, callback) {
    if (css_urls == null) css_urls = [];
    if (js_urls == null) js_urls = [];

    root._bokeh_onload_callbacks.push(callback);
    if (root._bokeh_is_loading > 0) {
      console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
      return null;
    }
    if (js_urls == null || js_urls.length === 0) {
      run_callbacks();
      return null;
    }
    console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
    root._bokeh_is_loading = css_urls.length + js_urls.length;

    function on_load() {
      root._bokeh_is_loading--;
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
        run_callbacks()
      }
    }

    function on_error(url) {
      console.error("failed to load " + url);
    }

    for (let i = 0; i < css_urls.length; i++) {
      const url = css_urls[i];
      const element = document.createElement("link");
      element.onload = on_load;
      element.onerror = on_error.bind(null, url);
      element.rel = "stylesheet";
      element.type = "text/css";
      element.href = url;
      console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
      document.body.appendChild(element);
    }

    for (let i = 0; i < js_urls.length; i++) {
      const url = js_urls[i];
      const element = document.createElement('script');
      element.onload = on_load;
      element.onerror = on_error.bind(null, url);
      element.async = false;
      element.src = url;
      console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
      document.head.appendChild(element);
    }
  };

  function inject_raw_css(css) {
    const element = document.createElement("style");
    element.appendChild(document.createTextNode(css));
    document.body.appendChild(element);
  }

  const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.7.3.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.7.3.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.7.3.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.7.3.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.7.3.min.js"];
  const css_urls = [];

  const inline_js = [    function(Bokeh) {
      Bokeh.set_log_level("info");
    },
function(Bokeh) {
    }
  ];

  function run_inline_js() {
    if (root.Bokeh !== undefined || force === true) {
      try {
            for (let i = 0; i < inline_js.length; i++) {
      inline_js[i].call(root, root.Bokeh);
    }

      } catch (error) {display_loaded(error);throw error;
      }if (force === true) {
        display_loaded();
      }} else if (Date.now() < root._bokeh_timeout) {
      setTimeout(run_inline_js, 100);
    } else if (!root._bokeh_failed_load) {
      console.log("Bokeh: BokehJS failed to load within specified timeout.");
      root._bokeh_failed_load = true;
    } else if (force !== true) {
      const cell = $(document.getElementById("dc622cf9-f603-4278-ab96-f95f1ce55206")).parents('.cell').data().cell;
      cell.output_area.append_execute_result(NB_LOAD_WARNING)
    }
  }

  if (root._bokeh_is_loading === 0) {
    console.debug("Bokeh: BokehJS loaded, going straight to plotting");
    run_inline_js();
  } else {
    load_libs(css_urls, js_urls, function() {
      console.debug("Bokeh: BokehJS plotting callback run at", now());
      run_inline_js();
    });
  }
}(window));</script></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># load the catchment characteristics</span>
<span class="n">rev_date</span> <span class="o">=</span> <span class="s1">&#39;20250227&#39;</span>
<span class="n">fname</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;BCUB_watershed_attributes_updated_</span><span class="si">{</span><span class="n">rev_date</span><span class="si">}</span><span class="s1">.csv&#39;</span>
<span class="n">attr_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">fname</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;official_id&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;drainage_area_km2&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">})</span>
<span class="n">attr_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">attr_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
<span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;log_drainage_area_km2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;drainage_area_km2&#39;</span><span class="p">])</span>
<span class="c1"># attr_df = attr_df[~attr_df[&#39;official_id&#39;].isin(exclude)]</span>
<span class="c1"># attr_df.columns = [c.lower() for c in attr_df.columns]</span>
<span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;tmean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;tmin&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;tmax&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
<span class="n">station_ids</span> <span class="o">=</span> <span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
<span class="c1"># assert &#39;12414900&#39; in station_ids</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">station_ids</span><span class="p">)</span><span class="si">}</span><span class="s1"> monitored basins in the attribute set.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>There are 1308 monitored basins in the attribute set.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># streamflow folder from (updated) HYSETS</span>
<span class="n">HYSETS_DIR</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;/home/danbot/code/common_data/HYSETS&#39;</span><span class="p">)</span>
<span class="c1"># STREAMFLOW_DIR = HYSETS_DIR / &#39;streamflow&#39;</span>

<span class="n">hs_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;data/HYSETS_watershed_properties.txt&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">)</span>
<span class="n">hs_df</span> <span class="o">=</span> <span class="n">hs_df</span><span class="p">[</span><span class="n">hs_df</span><span class="p">[</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">station_ids</span><span class="p">)]</span>
<span class="n">hs_df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Watershed_ID</th>
      <th>Source</th>
      <th>Name</th>
      <th>Official_ID</th>
      <th>Centroid_Lat_deg_N</th>
      <th>Centroid_Lon_deg_E</th>
      <th>Drainage_Area_km2</th>
      <th>Drainage_Area_GSIM_km2</th>
      <th>Flag_GSIM_boundaries</th>
      <th>Flag_Artificial_Boundaries</th>
      <th>...</th>
      <th>Land_Use_Wetland_frac</th>
      <th>Land_Use_Water_frac</th>
      <th>Land_Use_Urban_frac</th>
      <th>Land_Use_Shrubs_frac</th>
      <th>Land_Use_Crops_frac</th>
      <th>Land_Use_Snow_Ice_frac</th>
      <th>Flag_Land_Use_Extraction</th>
      <th>Permeability_logk_m2</th>
      <th>Porosity_frac</th>
      <th>Flag_Subsoil_Extraction</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>846</th>
      <td>847</td>
      <td>HYDAT</td>
      <td>CROWSNEST RIVER AT FRANK</td>
      <td>05AA008</td>
      <td>49.59732</td>
      <td>-114.4106</td>
      <td>402.6522</td>
      <td>NaN</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0.0103</td>
      <td>0.0065</td>
      <td>0.0328</td>
      <td>0.0785</td>
      <td>0.0015</td>
      <td>0.0002</td>
      <td>1</td>
      <td>-15.543306</td>
      <td>0.170479</td>
      <td>1</td>
    </tr>
    <tr>
      <th>849</th>
      <td>850</td>
      <td>HYDAT</td>
      <td>CASTLE RIVER NEAR BEAVER MINES</td>
      <td>05AA022</td>
      <td>49.48866</td>
      <td>-114.1444</td>
      <td>820.6510</td>
      <td>NaN</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0.0058</td>
      <td>0.0023</td>
      <td>0.0105</td>
      <td>0.1156</td>
      <td>0.0246</td>
      <td>0.0000</td>
      <td>1</td>
      <td>-15.929747</td>
      <td>0.150196</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>2 rows × 29 columns</p>
</div></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># retrieve LSTM ensemble predictions</span>
<span class="n">lstm_result_folder</span> <span class="o">=</span> <span class="s1">&#39;/home/danbot/code/neuralhydrology/data/ensemble_results&#39;</span>
<span class="n">lstm_result_files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">lstm_result_folder</span><span class="p">)</span>
<span class="n">lstm_result_stns</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">lstm_result_files</span><span class="p">]</span>
<span class="k">assert</span> <span class="s1">&#39;12414900&#39;</span> <span class="ow">in</span> <span class="n">lstm_result_stns</span>

<span class="c1"># find any non-matching station ids in the lstm result files</span>
<span class="k">for</span> <span class="n">stn</span> <span class="ow">in</span> <span class="n">lstm_result_stns</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">stn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">station_ids</span><span class="p">:</span>
        <span class="c1"># try adding a leading zero</span>
        <span class="n">ending_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">station_ids</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">stn</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ending_in</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">stn</span><span class="p">,</span> <span class="s1">&#39;matches&#39;</span><span class="p">,</span> <span class="n">ending_in</span><span class="p">)</span>
        <span class="n">modified_stn</span> <span class="o">=</span> <span class="n">stn</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">modified_stn</span> <span class="ow">in</span> <span class="n">station_ids</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found modified station id: </span><span class="si">{</span><span class="n">modified_stn</span><span class="si">}</span><span class="s1"> for </span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Warning: </span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1"> is in LSTM results but not in the station attributes.&#39;</span><span class="p">)</span>

<span class="c1"># filter for the common stations between BCUB region and LSTM-compatible (i.e. 1980-)</span>
<span class="n">daymet_concurrent_stations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">station_ids</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">lstm_result_stns</span><span class="p">))</span>
<span class="c1"># assert &#39;12414900&#39; in daymet_concurrent_stations</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">daymet_concurrent_stations</span><span class="p">)</span><span class="si">}</span><span class="s1"> monitored basins concurrent with LSTM ensemble results.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>12414900 matches [&#39;0212414900&#39;]
Warning: 12414900 is in LSTM results but not in the station attributes.
Warning: 15056030 is in LSTM results but not in the station attributes.
There are 723 monitored basins concurrent with LSTM ensemble results.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># import updated catchment polygons</span>
<span class="n">poly_fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;BCUB_watershed_attributes_updated_</span><span class="si">{</span><span class="n">rev_date</span><span class="si">}</span><span class="s1">.geojson&#39;</span><span class="p">))</span>
<span class="n">catchment_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">poly_fpath</span><span class="p">)</span>
<span class="n">catchment_gdf</span> <span class="o">=</span> <span class="n">catchment_gdf</span><span class="p">[</span><span class="n">catchment_gdf</span><span class="p">[</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">station_ids</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">catchment_gdf</span><span class="p">),</span> <span class="s1">&#39;catchments in the polygon set&#39;</span><span class="p">)</span>

<span class="c1"># import the license water extraction points</span>
<span class="n">dam_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;data/Dam_Points_20240103.gpkg&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">dam_gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="n">catchment_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="s2">&quot;Catchment and dam geometries must have the same CRS&quot;</span>
<span class="n">joined</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">catchment_gdf</span><span class="p">,</span> <span class="n">dam_gdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;contains&quot;</span><span class="p">)</span>
<span class="c1"># Create a new boolean column &#39;contains_dam&#39; in catchment_gdf.</span>
<span class="c1"># If a polygon&#39;s index appears in the joined result, it means it contains at least one point.</span>
<span class="n">regulated</span> <span class="o">=</span> <span class="n">joined</span><span class="p">[</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
<span class="n">catchment_gdf</span><span class="p">[</span><span class="s2">&quot;contains_dam&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">catchment_gdf</span><span class="p">[</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">regulated</span><span class="p">)</span>
<span class="n">n_regulated</span> <span class="o">=</span> <span class="n">catchment_gdf</span><span class="p">[</span><span class="s1">&#39;contains_dam&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n_regulated</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">catchment_gdf</span><span class="p">)</span><span class="si">}</span><span class="s1"> catchments contain withdrawal licenses&#39;</span><span class="p">)</span>

<span class="c1"># # create dicts for easier access to &#39;official_id&#39;: &#39;drainage area&#39;, geometry, regulation status</span>
<span class="n">da_dict</span> <span class="o">=</span> <span class="n">attr_df</span><span class="p">[[</span><span class="s1">&#39;official_id&#39;</span><span class="p">,</span> <span class="s1">&#39;drainage_area_km2&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;official_id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()[</span><span class="s1">&#39;drainage_area_km2&#39;</span><span class="p">]</span>
<span class="n">dam_dict</span> <span class="o">=</span> <span class="n">catchment_gdf</span><span class="p">[[</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">,</span> <span class="s1">&#39;contains_dam&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()[</span><span class="s1">&#39;contains_dam&#39;</span><span class="p">]</span>
<span class="n">polygon_dict</span> <span class="o">=</span> <span class="n">catchment_gdf</span><span class="p">[[</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>

<span class="c1"># # add the centroid point geometry to the attributes dataframe</span>
<span class="n">attr_df</span> <span class="o">=</span> <span class="n">attr_df</span><span class="p">[</span><span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">catchment_gdf</span><span class="p">[</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">centroids</span> <span class="o">=</span> <span class="n">attr_df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">polygon_dict</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">centroid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">attr_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">attr_df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">centroids</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">catchment_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
<span class="n">attr_gdf</span><span class="p">[</span><span class="s2">&quot;contains_dam&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr_gdf</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dam_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dam_dict</span> <span class="k">else</span> <span class="kc">False</span><span class="p">)</span>
<span class="c1"># add the concurrency status as a boolean column</span>
<span class="n">attr_gdf</span><span class="p">[</span><span class="s1">&#39;LSTM_concurrent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr_gdf</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">daymet_concurrent_stations</span><span class="p">)</span>
<span class="n">attr_gdf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;N network stations=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">attr_gdf</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1307 catchments in the polygon set
175/1307 catchments contain withdrawal licenses
N network stations=1307
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># bad_pts = gpd.read_file(&#39;data/consistently_bad_pts.geojson&#39;)</span>
<span class="c1"># bad_pts[&#39;regulated&#39;] = bad_pts[&#39;ids&#39;].apply(lambda x: x in dam_dict and dam_dict[x])</span>
<span class="c1"># bad_pts.to_file(&#39;data/consistently_bad_pts.geojson&#39;, driver=&#39;GeoJSON&#39;)</span>
<span class="c1"># make a dict of number of bad points per station</span>
<span class="c1"># bad_pts_dict = bad_pts[[&#39;ids&#39;, &#39;counts&#39;]].groupby(&#39;official_id&#39;).size().to_dict()</span>
<span class="c1"># bad_pts.head()</span>
<span class="c1"># attr_gdf.to_file(os.path.join(&#39;data&#39;, f&#39;BCUB_watershed_attributes_updated_{rev_date}.geojson&#39;), driver=&#39;GeoJSON&#39;)</span>
</pre></div>
</div>
</div>
</div>
<section id="non-parametric-simulation">
<h1>Non-Parametric Simulation<a class="headerlink" href="#non-parametric-simulation" title="Link to this heading">#</a></h1>
<section id="time-based-ensemble">
<h2>Time-based ensemble<a class="headerlink" href="#time-based-ensemble" title="Link to this heading">#</a></h2>
<p>A probability distribution <span class="math notranslate nohighlight">\(\hat p = f(\tilde x(t))\)</span> is estimated for a target (ungauged location) by a weighted mean of runoff time-series from k nearest neighbour stations, <span class="math notranslate nohighlight">\(\tilde x(t) = \textbf{X}(t)\cdot w\)</span> where <span class="math notranslate nohighlight">\(X(t) \in \mathbb{R}^{N \times k}\)</span> and <span class="math notranslate nohighlight">\(w \in \mathbb{R}^{k\times 1}\)</span> is a vector of k weights.  So <span class="math notranslate nohighlight">\(\hat p = f(\textbf{X}(t) \cdot w )\)</span>  Weights <span class="math notranslate nohighlight">\(w\)</span> are computed in three ways, described in the next subsection, and k-nearest neighbours are selected using the criteria defined below.  Each gauged station in the monitoring network is treated as an ungauged location to generate a large sample of simulations across hydrologically diverse catchments, or rather as many catchments as can be tested.</p>
</section>
<section id="frequency-based-ensembles">
<h2>Frequency-based ensembles<a class="headerlink" href="#frequency-based-ensembles" title="Link to this heading">#</a></h2>
<p>A simulated probability density function is estimated from observations of k nearest neighbour stations.  First, k simulated series are generated by equal unit area runoff , <span class="math notranslate nohighlight">\(\hat p = \hat P \cdot w\)</span> where <span class="math notranslate nohighlight">\(\hat P = [\hat p_1, \hat p_2, \cdots, \hat p_k]\)</span> and each <span class="math notranslate nohighlight">\(\hat p_i = f(X_i(t))\)</span>.</p>
<p>In both cases, the function <span class="math notranslate nohighlight">\(f \rightarrow \hat p(x)\)</span> represents kernel density estimation, which defines the probability density as $<span class="math notranslate nohighlight">\(\hat p(x) = \frac{1}{n \cdot h(x)} \sum_{i=1}^{n}K\left( \frac{x-x_i}{h(x)}\right)\)</span>$</p>
<p>Where <span class="math notranslate nohighlight">\(h(x)\)</span> reflects an adaptive kernel bandwidth that addresses vestiges of precision in the observed data to reflect the nature of streamflow as a continuous variable, and additionally incorporates piecewise linear model to represent overall measurement uncertainty.</p>
</section>
</section>
<section id="notes-on-k-nearest-neighbours">
<h1>Notes on k-nearest neighbours<a class="headerlink" href="#notes-on-k-nearest-neighbours" title="Link to this heading">#</a></h1>
<p>Time series streamflow records vary widely in their temporal coverage, and finding k-nearest neighbours presents a tradeoff between selecting nearest neighbours and maximizing the number of observations concurrent with the target.  From the literature, concurrency is assured by pre-selecting a subset of stations with continuous records over a common period of record, or by infilling gaps with k-nearest neighbours simulation.  Some kind of tradeoff must be made, and we aim to use a method that maximizes information content while minimizing the number of assumptions.  The following notes are intended to clarify the implications of using k-nearest neighbours to fill gaps in the time series.</p>
<ol class="arabic simple">
<li><p><strong>Infilled-by-kNN != Independent Proxy</strong>: If a gap in an observation record is inferred from neighbors, it becomes redundant in the ensemble and increases the weight of the other (k minus n) neighbours.  So at that time step, its influence is non-unique, and including it in the ensemble is functionally equivalent to using the same set of other proxies directly, or just reducing the ensemble size.</p></li>
<li><p><strong>Inflated Ensemble Size</strong>: Filling gaps by “nested” k-nearest neighbours inflates the expresed number of independent neighbors.  Comparing the effectiveness of ensemble simulations as a function of k is then misleading because the effective number of independent proxies is <em>at most</em> k.</p></li>
<li><p><strong>Information leakage risk</strong>: If you repeatedly use kNN to fill missing data from within the same pool, especially when simulating extreme values, you risk suppressing variability by biasing toward the central tendency of the ensemble.  This defeats one of the core motivations for kNN: to preserve structure and variability from observations at neighboring stations.</p></li>
</ol>
<p>To address the nuance above, we propose three time-based methods for selecting k-nearest neighbours beyond strictly nodes in the network.  The problem is related to the set-cover problem where the goal is to select a subset of stations that maximizes the intersection of their data availability over a specified time period.  The following sections outline the three methods for selecting k-nearest neighbours based on availability of concurrent data.</p>
<section id="summary-set-theoretic-foundations-of-strict-k-nn-concurrency-selection">
<h2>Summary: Set-Theoretic Foundations of Strict k-NN Concurrency Selection<a class="headerlink" href="#summary-set-theoretic-foundations-of-strict-k-nn-concurrency-selection" title="Link to this heading">#</a></h2>
<p>This problem is closely related to classic combinatorial and set-theoretic optimization problems.</p>
<section id="set-theoretic-definition">
<h3>Set-Theoretic Definition<a class="headerlink" href="#set-theoretic-definition" title="Link to this heading">#</a></h3>
<p>Let each column <span class="math notranslate nohighlight">\(( S_i \subseteq T )\)</span> represent the set of timestamps where station <span class="math notranslate nohighlight">\(( i )\)</span> has valid (non-NaN) data.<br />
Let <span class="math notranslate nohighlight">\(( \mathcal{S} = \{ S_1, S_2, \dots, S_n \} )\)</span> be the collection of all such subsets, sorted by proximity (e.g., distance or attribute similarity).<br />
The goal is to select a subset <span class="math notranslate nohighlight">\(( \mathcal{K} \subset \mathcal{S} )\)</span> such that:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(( |\mathcal{K}| = k )\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(( \bigcap_{S \in \mathcal{K}} S )\)</span> satisfies a temporal completeness constraint (e.g., ≥5 years with ≥10 observations in each of 12 months)</p></li>
</ul>
<p>This is a constrained subset selection problem on the intersection of sets.</p>
</section>
<section id="related-concepts">
<h3>Related Concepts<a class="headerlink" href="#related-concepts" title="Link to this heading">#</a></h3>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Concept</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Set Intersection Selection</p></td>
<td><p>Select ( k ) sets whose intersection satisfies a completeness constraint.</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum Coverage under Cardinality Constraint</p></td>
<td><p>Choose ( k ) sets to maximize the coverage (or completeness) of their intersection.</p></td>
</tr>
<tr class="row-even"><td><p>Recursive k-Subset Validation</p></td>
<td><p>If the initial ( k ) sets fail, iteratively add more candidates and evaluate all ( \binom{k+1}{k} ) combinations, and so on.</p></td>
</tr>
<tr class="row-odd"><td><p>NP-Hard Nature</p></td>
<td><p>This problem is computationally hard and shares structure with the Set Cover and Maximum Coverage problems.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="practical-implication">
<h3>Practical Implication<a class="headerlink" href="#practical-implication" title="Link to this heading">#</a></h3>
<p>This formulation justifies using greedy or approximate subset selection strategies when exhaustively testing all combinations becomes computationally infeasible.</p>
</section>
</section>
</section>
<section id="define-a-universal-parametric-prior">
<h1>Define a universal parametric prior<a class="headerlink" href="#define-a-universal-parametric-prior" title="Link to this heading">#</a></h1>
<p>In order to fairly test how parametric and non-parametric pdf estimation methods compare to each other, we need a consistent way to deal with indeterminate cases where the simulated distribution does not provide support coverage of the “ground truth” observations.  I feel two ways about this: the KL divergence is the culprit here, and the problem could be avoided by choosing another divergence measure.  However the definintion of KL divergence in information theoretic terms of compression make it seem more foundational than other measures, but ultimately is this true?  Should we look to math statistics to make more direct links between f-divergences and what we use as a discriminant for a particular application?  Should we be more concerned about “Bayesian consistency” of the discriminant (or surrogate loss function) with the choice of divergence measure?</p>
<ol class="arabic simple">
<li><p><strong>Quantify the distribution of unsupported mass across all models</strong>.  It is important to describe the extent of the problem across the sample <strong>and</strong> across various methods.  i.e. discrete distributions have the issue of support coverage, but so do all methods!</p></li>
<li><p>Even in kNN / ensemble simulation approaches, the problem of incomplete support coverage necessitates assuming some prior probability.  The issue is that setting a uniform prior over the observed range takes advantage of information about the observed range.</p></li>
</ol>
<section id="global-uniform-prior">
<h2>Global Uniform Prior<a class="headerlink" href="#global-uniform-prior" title="Link to this heading">#</a></h2>
<div class="math notranslate nohighlight">
\[f(x) = \frac{1}{b-a}, \quad x\in (a, b) \text{ and } f(x) = 0 \text{ otherwise.}\]</div>
<div class="math notranslate nohighlight">
\[\int_a^b f(x)\text{dx} = 1\]</div>
<p>Given the target range is a sub interval <span class="math notranslate nohighlight">\((c, d) \subseteq (a, b)\)</span>, then the <strong>total</strong> prior probability mass over (c, d) is:</p>
<div class="math notranslate nohighlight">
\[M_\text{target} = \int_c^d \frac{1}{b-a}\text{dx} = \frac{d-c}{b-a}\]</div>
<p>Over the set of intervals <span class="math notranslate nohighlight">\(\Delta x_i\)</span> covering the <strong>target range</strong>, the probability mass associated with each interval (bin) is given by:</p>
<div class="math notranslate nohighlight">
\[\Delta x_i \frac{d-c}{b-a}\]</div>
<p>A desirable property of the prior is that it reflects the strength of belief in the model (data), where a smaller prior reflects stronger belief in the data/model and vice versa.  Dividing by the number of observations has such an effect, however it also makes for very small priors.  The consequence of very small priors is they have negligible effect on models that provide complete support coverage, and they severely penalize models that do not, resulting in a form of instability.  The very small prior creates a heavy tail in the distribution of a large sample of KL divergences, with further downstream effects in optimization.</p>
<p>A method that uses a prior with negligible effect on a model with complete support coverage and a very big effect on one without can be interpreted in a few ways:</p>
<ol class="arabic simple">
<li><p>Incomplete support coverage, or underspecification, is very heavily penalized.  The method does not tolerate a model that cannot predict the full observed range.</p></li>
<li><p>A <strong>proper</strong> probability distribution sums (discrete) or integrates (continuous) to 1.  Very small probabilities are in a sense associated with a high degree of certainty since they reflect the expectation of the system being observed in a particular state.</p></li>
<li><p>The penalty of underestimating a state frequency is that storing and transmitting information about the state requires (the log ratio) more bandwidth/disk space because it is assigned a longer bit string than the actual frequency calls for under optimal encoding.</p></li>
<li><p>Assigning a very small probability to a state …</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># load the predicted parameter results</span>
<span class="n">parameter_prediction_results_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;parameter_prediction_results&#39;</span><span class="p">,</span> <span class="p">)</span>
<span class="n">predicted_params_fpath</span>   <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parameter_prediction_results_folder</span><span class="p">,</span> <span class="s1">&#39;mean_parameter_predictions.csv&#39;</span><span class="p">)</span>
<span class="n">rdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">predicted_params_fpath</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;official_id&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})</span>
<span class="n">predicted_param_dict</span> <span class="o">=</span> <span class="n">rdf</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plots</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">predicted_param_sample</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">al</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;mean_logx_mean_predicted&#39;</span><span class="p">,</span> <span class="s1">&#39;sd_logx_mean_predicted&#39;</span><span class="p">],</span> <span class="p">[</span><span class="sa">r</span><span class="s1">&#39;$$\text{Log Mean UAR }(L/s/\text</span><span class="si">{km}</span><span class="s1">^2)$$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$$\text{Log SD UAR }(L/s/\text</span><span class="si">{km}</span><span class="s1">^2)$$&#39;</span><span class="p">]):</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">predicted_param_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="n">predicted_param_sample</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>
    <span class="c1"># plot the histogram of the mean_uar values</span>
    <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># create a scatter plot of the predicted parameter vs the target parameter</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Predicted </span><span class="si">{</span><span class="n">l</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">top</span><span class="o">=</span><span class="n">hist</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">fill_color</span><span class="o">=</span><span class="s1">&#39;lightblue&#39;</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="n">al</span>
    <span class="n">f</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$$P(x)$$&#39;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">format_fig_fonts</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">plots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="c1"># retrieve all the mean_uar values </span>

<span class="n">lt</span> <span class="o">=</span> <span class="n">gridplot</span><span class="p">(</span><span class="n">plots</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
<span class="n">show</span><span class="p">(</span><span class="n">lt</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
  <div id="e8fd7368-6b47-4114-88c6-34cb3709360a" data-root-id="p1102" style="display: contents;"></div>
</div><script type="application/javascript">(function(root) {
  function embed_document(root) {
  const docs_json = {"b84b372d-e073-4125-97de-8f374a43694b":{"version":"3.7.3","title":"Bokeh Application","roots":[{"type":"object","name":"GridPlot","id":"p1102","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p1101","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p1095","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p1025"},{"type":"object","name":"PanTool","id":"p1071"}]}},{"type":"object","name":"ToolProxy","id":"p1096","attributes":{"tools":[{"type":"object","name":"WheelZoomTool","id":"p1026","attributes":{"renderers":"auto"}},{"type":"object","name":"WheelZoomTool","id":"p1072","attributes":{"renderers":"auto"}}]}},{"type":"object","name":"ToolProxy","id":"p1097","attributes":{"tools":[{"type":"object","name":"BoxZoomTool","id":"p1027","attributes":{"dimensions":"both","overlay":{"type":"object","name":"BoxAnnotation","id":"p1028","attributes":{"syncable":false,"line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","handles":{"type":"object","name":"BoxInteractionHandles","id":"p1034","attributes":{"all":{"type":"object","name":"AreaVisuals","id":"p1033","attributes":{"fill_color":"white","hover_fill_color":"lightgray"}}}}}}}},{"type":"object","name":"BoxZoomTool","id":"p1073","attributes":{"dimensions":"both","overlay":{"type":"object","name":"BoxAnnotation","id":"p1074","attributes":{"syncable":false,"line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","handles":{"type":"object","name":"BoxInteractionHandles","id":"p1080","attributes":{"all":{"type":"object","name":"AreaVisuals","id":"p1079","attributes":{"fill_color":"white","hover_fill_color":"lightgray"}}}}}}}}]}},{"type":"object","name":"SaveTool","id":"p1098"},{"type":"object","name":"ToolProxy","id":"p1099","attributes":{"tools":[{"type":"object","name":"ResetTool","id":"p1036"},{"type":"object","name":"ResetTool","id":"p1082"}]}},{"type":"object","name":"ToolProxy","id":"p1100","attributes":{"tools":[{"type":"object","name":"HelpTool","id":"p1037"},{"type":"object","name":"HelpTool","id":"p1083"}]}}]}},"children":[[{"type":"object","name":"Figure","id":"p1003","attributes":{"width":400,"height":400,"x_range":{"type":"object","name":"DataRange1d","id":"p1004"},"y_range":{"type":"object","name":"DataRange1d","id":"p1005"},"x_scale":{"type":"object","name":"LinearScale","id":"p1013"},"y_scale":{"type":"object","name":"LinearScale","id":"p1014"},"title":{"type":"object","name":"Title","id":"p1006","attributes":{"text":"Predicted mean_logx_mean_predicted"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p1044","attributes":{"data_source":{"type":"object","name":"ColumnDataSource","id":"p1038","attributes":{"selected":{"type":"object","name":"Selection","id":"p1039","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p1040"},"data":{"type":"map","entries":[["top",{"type":"ndarray","array":{"type":"bytes","data":"yc0YMJDygT+uNCVI2OuKPwAAAAAAAAAArjQlSNjrij/JzRgwkPKBP8PNGDCQ8oE/OwEfPDRvlj/JzRgwkPKhP2dOKE4qKq0/H2grVHxorz+fWhozuRGzPzQBHzw0b7Y/yc0YMJDykT/0GiJChq2oP4vBJksBC7w/0acjRa/MuT/NOp66n9/FP6rHn73I/sY/X3QdOQtQxT8b+6XJbHvLP8+92nODWdM/yc0YMJDy0T8Enl77aSfWPysBHzw0b9Y/SwEfPDRv1j8J+6XJbHvbP8HdVuyci9A/5IenzJWazD+Kepar0kPQP706nrqf38U/6xSpz765zT8sbqTGQ1zKPyqUmbEkgtI/OJSZsSSC0j8J+6XJbHvLP67nGzbiMLQ/vM0YMJDyoT+bNCVI2OuKP7zNGDCQ8nE/1s0YMJDycT8="},"shape":[40],"dtype":"float64","order":"little"}],["left",{"type":"ndarray","array":{"type":"bytes","data":"vtMJDWk5/r9Yz2KMvG77v/LKuwsQpPi/i8YUi2PZ9b8lwm0Ktw7zv7+9xokKRPC/sHI/Erzy6r/kafEQY13lvzDCRh8UkN+/mLCqHGJl1L8APh00YHXCv8Ap14geAJ8/cAhT1mc1yj/QlcXtZUXYP7TTMPgLuOE/gNx++WRN5z9M5cz6veLsPwx3DX4LPPE/cnu0/rcG9D/Yf1t/ZNH2Pz6EAgARnPk/poipgL1m/D8MjVABajH/P7nI+0AL/gBA7UpPgWFjAkAfzaLBt8gDQFNP9gEOLgVAhdFJQmSTBkC5U52CuvgHQOvV8MIQXglAH1hEA2fDCkBR2pdDvSgMQIVc64MTjg1Aud4+xGnzDkB2MEkCYCwQQJDxciIL3xBAqLKcQraREUDCc8ZiYUQSQNw08IIM9xJA9vUZo7epE0A="},"shape":[40],"dtype":"float64","order":"little"}],["right",{"type":"ndarray","array":{"type":"bytes","data":"WM9ijLxu+7/yyrsLEKT4v4vGFItj2fW/JcJtCrcO87+/vcaJCkTwv7ByPxK88uq/5GnxEGNd5b8wwkYfFJDfv5iwqhxiZdS/AD4dNGB1wr/AKdeIHgCfP3AIU9ZnNco/0JXF7WVF2D+00zD4C7jhP4DcfvlkTec/TOXM+r3i7D8Mdw1+CzzxP3J7tP63BvQ/2H9bf2TR9j8+hAIAEZz5P6aIqYC9Zvw/DI1QAWox/z+5yPtAC/4AQO1KT4FhYwJAH82iwbfIA0BTT/YBDi4FQIXRSUJkkwZAuVOdgrr4B0Dr1fDCEF4JQB9YRANnwwpAUdqXQ70oDECFXOuDE44NQLnePsRp8w5AdjBJAmAsEECQ8XIiC98QQKiynEK2kRFAwnPGYmFEEkDcNPCCDPcSQPb1GaO3qRNAD7dDw2JcFEA="},"shape":[40],"dtype":"float64","order":"little"}]]}}},"view":{"type":"object","name":"CDSView","id":"p1045","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p1046"}}},"glyph":{"type":"object","name":"Quad","id":"p1041","attributes":{"left":{"type":"field","field":"left"},"right":{"type":"field","field":"right"},"bottom":{"type":"value","value":0},"top":{"type":"field","field":"top"},"fill_color":{"type":"value","value":"lightblue"}}},"nonselection_glyph":{"type":"object","name":"Quad","id":"p1042","attributes":{"left":{"type":"field","field":"left"},"right":{"type":"field","field":"right"},"bottom":{"type":"value","value":0},"top":{"type":"field","field":"top"},"line_alpha":{"type":"value","value":0.1},"fill_color":{"type":"value","value":"lightblue"},"fill_alpha":{"type":"value","value":0.1},"hatch_alpha":{"type":"value","value":0.1}}},"muted_glyph":{"type":"object","name":"Quad","id":"p1043","attributes":{"left":{"type":"field","field":"left"},"right":{"type":"field","field":"right"},"bottom":{"type":"value","value":0},"top":{"type":"field","field":"top"},"line_alpha":{"type":"value","value":0.2},"fill_color":{"type":"value","value":"lightblue"},"fill_alpha":{"type":"value","value":0.2},"hatch_alpha":{"type":"value","value":0.2}}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p1012","attributes":{"tools":[{"id":"p1025"},{"id":"p1026"},{"id":"p1027"},{"type":"object","name":"SaveTool","id":"p1035"},{"id":"p1036"},{"id":"p1037"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p1020","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1021","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1022"},"axis_label":"$$P(x)$$","axis_label_text_font":"Bitstream Charter","axis_label_text_font_size":"14pt","major_label_policy":{"type":"object","name":"AllLabels","id":"p1023"},"major_label_text_font":"Bitstream Charter","major_label_text_font_size":"12pt"}}],"below":[{"type":"object","name":"LinearAxis","id":"p1015","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1016","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1017"},"axis_label":"$$\\text{Log Mean UAR }(L/s/\\text{km}^2)$$","axis_label_text_font":"Bitstream Charter","axis_label_text_font_size":"14pt","major_label_policy":{"type":"object","name":"AllLabels","id":"p1018"},"major_label_text_font":"Bitstream Charter","major_label_text_font_size":"12pt"}}],"center":[{"type":"object","name":"Grid","id":"p1019","attributes":{"axis":{"id":"p1015"}}},{"type":"object","name":"Grid","id":"p1024","attributes":{"dimension":1,"axis":{"id":"p1020"}}},{"type":"object","name":"Legend","id":"p1047","attributes":{"label_text_font":"Bitstream Charter","label_text_font_size":"12pt","items":[{"type":"object","name":"LegendItem","id":"p1048","attributes":{"label":{"type":"value","value":""},"renderers":[{"id":"p1044"}]}}]}}]}},0,0],[{"type":"object","name":"Figure","id":"p1049","attributes":{"width":400,"height":400,"x_range":{"type":"object","name":"DataRange1d","id":"p1050"},"y_range":{"type":"object","name":"DataRange1d","id":"p1051"},"x_scale":{"type":"object","name":"LinearScale","id":"p1059"},"y_scale":{"type":"object","name":"LinearScale","id":"p1060"},"title":{"type":"object","name":"Title","id":"p1052","attributes":{"text":"Predicted sd_logx_mean_predicted"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p1090","attributes":{"data_source":{"type":"object","name":"ColumnDataSource","id":"p1084","attributes":{"selected":{"type":"object","name":"Selection","id":"p1085","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p1086"},"data":{"type":"map","entries":[["top",{"type":"ndarray","array":{"type":"bytes","data":"bLJV6wmkyz/1jXNFI/PaP5Yzjx2UYuQ/0UWAcAe75D8wjaLOccnvP1f7GTfXBf0/UhSGZQ8nAEC78TjSxET/P/jp+VoV1/c/nmjAKIsY7z/jRYBwB7vkP+HWN5HwVNw/gGmRnzxC2j/l/LskOlnTP6jXCAiifsc/lCDNU2/gyD+UIM1Tb+C4P0NE3oKkZ74/vY5EvNQctj+EslXrCaS7P6mORLzUHJY//mozjZ+VsD8cazONn5WgP9CORLzUHIY/qY5EvNQchj8cazONn5WgPxxrM42flbA//mozjZ+VoD/+ajONn5WgPwAAAAAAAAAAAAAAAAAAAADQjkS81ByWP9CORLzUHJY/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANCORLzUHIY/qY5EvNQchj8="},"shape":[40],"dtype":"float64","order":"little"}],["left",{"type":"ndarray","array":{"type":"bytes","data":"NJC635m34z9ibTPlqPvlP5BKrOq3P+g/vicl8MaD6j/sBJ711cfsPxriFvvkC+8/pN9HAPqn8D86TgSDAcrxP9K8wAUJ7PI/aCt9iBAO9D8AmjkLGDD1P5YI9o0fUvY/LXeyECd09z/E5W6TLpb4P1tUKxY2uPk/8sLnmD3a+j+JMaQbRfz7PyCgYJ5MHv0/tw4dIVRA/j9OfdmjW2L/P/L1SpMxQgBAPi2pVDXTAECKZAcWOWQBQNWbZdc89QFAINPDmECGAkBsCiJaRBcDQLdBgBtIqANAAnne3Es5BEBOsDyeT8oEQJrnml9TWwVA5R75IFfsBUAxVlfiWn0GQHyNtaNeDgdAx8QTZWKfB0AT/HEmZjAIQF4z0OdpwQhAqmouqW1SCUD1oYxqceMJQEHZ6it1dApAjBBJ7XgFC0A="},"shape":[40],"dtype":"float64","order":"little"}],["right",{"type":"ndarray","array":{"type":"bytes","data":"Ym0z5aj75T+QSqzqtz/oP74nJfDGg+o/7ASe9dXH7D8a4hb75AvvP6TfRwD6p/A/Ok4EgwHK8T/SvMAFCezyP2grfYgQDvQ/AJo5Cxgw9T+WCPaNH1L2Py13shAndPc/xOVuky6W+D9bVCsWNrj5P/LC55g92vo/iTGkG0X8+z8goGCeTB79P7cOHSFUQP4/Tn3Zo1ti/z/y9UqTMUIAQD4tqVQ10wBAimQHFjlkAUDVm2XXPPUBQCDTw5hAhgJAbAoiWkQXA0C3QYAbSKgDQAJ53txLOQRATrA8nk/KBECa55pfU1sFQOUe+SBX7AVAMVZX4lp9BkB8jbWjXg4HQMfEE2VinwdAE/xxJmYwCEBeM9DnacEIQKpqLqltUglA9aGManHjCUBB2eordXQKQIwQSe14BQtA2EenrnyWC0A="},"shape":[40],"dtype":"float64","order":"little"}]]}}},"view":{"type":"object","name":"CDSView","id":"p1091","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p1092"}}},"glyph":{"type":"object","name":"Quad","id":"p1087","attributes":{"left":{"type":"field","field":"left"},"right":{"type":"field","field":"right"},"bottom":{"type":"value","value":0},"top":{"type":"field","field":"top"},"fill_color":{"type":"value","value":"lightblue"}}},"nonselection_glyph":{"type":"object","name":"Quad","id":"p1088","attributes":{"left":{"type":"field","field":"left"},"right":{"type":"field","field":"right"},"bottom":{"type":"value","value":0},"top":{"type":"field","field":"top"},"line_alpha":{"type":"value","value":0.1},"fill_color":{"type":"value","value":"lightblue"},"fill_alpha":{"type":"value","value":0.1},"hatch_alpha":{"type":"value","value":0.1}}},"muted_glyph":{"type":"object","name":"Quad","id":"p1089","attributes":{"left":{"type":"field","field":"left"},"right":{"type":"field","field":"right"},"bottom":{"type":"value","value":0},"top":{"type":"field","field":"top"},"line_alpha":{"type":"value","value":0.2},"fill_color":{"type":"value","value":"lightblue"},"fill_alpha":{"type":"value","value":0.2},"hatch_alpha":{"type":"value","value":0.2}}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p1058","attributes":{"tools":[{"id":"p1071"},{"id":"p1072"},{"id":"p1073"},{"type":"object","name":"SaveTool","id":"p1081"},{"id":"p1082"},{"id":"p1083"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p1066","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1067","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1068"},"axis_label":"$$P(x)$$","axis_label_text_font":"Bitstream Charter","axis_label_text_font_size":"14pt","major_label_policy":{"type":"object","name":"AllLabels","id":"p1069"},"major_label_text_font":"Bitstream Charter","major_label_text_font_size":"12pt"}}],"below":[{"type":"object","name":"LinearAxis","id":"p1061","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1062","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1063"},"axis_label":"$$\\text{Log SD UAR }(L/s/\\text{km}^2)$$","axis_label_text_font":"Bitstream Charter","axis_label_text_font_size":"14pt","major_label_policy":{"type":"object","name":"AllLabels","id":"p1064"},"major_label_text_font":"Bitstream Charter","major_label_text_font_size":"12pt"}}],"center":[{"type":"object","name":"Grid","id":"p1065","attributes":{"axis":{"id":"p1061"}}},{"type":"object","name":"Grid","id":"p1070","attributes":{"dimension":1,"axis":{"id":"p1066"}}},{"type":"object","name":"Legend","id":"p1093","attributes":{"label_text_font":"Bitstream Charter","label_text_font_size":"12pt","items":[{"type":"object","name":"LegendItem","id":"p1094","attributes":{"label":{"type":"value","value":""},"renderers":[{"id":"p1090"}]}}]}}]}},0,1]]}}]}};
  const render_items = [{"docid":"b84b372d-e073-4125-97de-8f374a43694b","roots":{"p1102":"e8fd7368-6b47-4114-88c6-34cb3709360a"},"root_ids":["p1102"]}];
  void root.Bokeh.embed.embed_items_notebook(docs_json, render_items);
  }
  if (root.Bokeh !== undefined) {
    embed_document(root);
  } else {
    let attempts = 0;
    const timer = setInterval(function(root) {
      if (root.Bokeh !== undefined) {
        clearInterval(timer);
        embed_document(root);
      } else {
        attempts++;
        if (attempts > 100) {
          clearInterval(timer);
          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
        }
      }
    }, 10, root)
  }
})(window);</script></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">LSTMFDCEstimator</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">target_stn</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># super().__init__(*args, **kwargs)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span> <span class="o">=</span> <span class="n">target_stn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="c1"># self.data = data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LSTM_forcings_folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">LSTM_forcings_folder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LSTM_ensemble_result_folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">LSTM_ensemble_result_folder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_ensemble_result</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim_cols</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;streamflow_sim_&#39;</span><span class="p">)])</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_load_ensemble_result</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">LSTM_ensemble_result_folder</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">_ensemble.csv&#39;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span>
        <span class="c1"># rename &#39;Unnamed: 0&#39; to &#39;time&#39; and set to index</span>
        <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Unnamed: 0&#39;</span><span class="p">:</span> <span class="s1">&#39;time&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>
        <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compare_results_and_input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compare the input streamflow timeseries with the observed streamflow timeseries.</span>
<span class="sd">        Check that the dates in the output match the common dates between Daymet and the input data.</span>
<span class="sd">        &quot;&quot;&quot;</span>    
        <span class="n">input_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># clip the &#39;discharge&#39; column to 1e-4, convert to unit area runoff (L/s/km2), and take the log</span>
        <span class="c1"># input_df[&#39;discharge&#39;] = np.clip(input_df[&#39;discharge&#39;], 1e-4, None)</span>
        <span class="n">input_df</span><span class="p">[</span><span class="s1">&#39;uar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">input_df</span><span class="p">[</span><span class="s1">&#39;discharge&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">da</span>
        <span class="n">input_df</span> <span class="o">=</span> <span class="n">input_df</span><span class="p">[</span><span class="n">input_df</span><span class="o">.</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="s1">&#39;1980-01-01&#39;</span><span class="p">]</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">input_df</span><span class="p">,</span> <span class="n">sim_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;streamflow_obs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;streamflow_obs&#39;</span><span class="p">])</span>

        <span class="n">sim_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sim_df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;streamflow_sim&#39;</span><span class="p">)]</span>
        <span class="n">df</span><span class="p">[</span><span class="n">sim_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">sim_cols</span><span class="p">])</span>
        <span class="c1"># assert that the &#39;log_obs&#39; and the &#39;streamflow_obs&#39; columns are approximately equal</span>

        <span class="c1"># set tolerance in the order of 1 L/s/km2</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;uar&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;streamflow_obs&#39;</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span> 
            <span class="n">max_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;uar&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;streamflow_obs&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Warning: </span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1"> has a max difference of </span><span class="si">{</span><span class="n">max_diff</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> between the input and output streamflow timeseries.&#39;</span><span class="p">)</span>
            <span class="c1"># find the dates around the max difference index</span>
            <span class="c1"># diff_index = np.abs(df[&#39;uar&#39;] - df[&#39;streamflow_obs&#39;]).idxmax()</span>
            <span class="c1"># print(diff_index)</span>
            <span class="c1"># view 5 before and 5 after the max diff index</span>
            <span class="c1"># print(df.loc[diff_index - pd.Timedelta(days=5):diff_index + pd.Timedelta(days=5), [&#39;uar&#39;, &#39;streamflow_obs&#39;]].head(10))</span>
            
        <span class="k">return</span> <span class="n">df</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_kde_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uar_data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kde</span> <span class="o">=</span> <span class="n">KDEEstimator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kde</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span>
            <span class="n">uar_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">target_da</span>
        <span class="p">)</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_load_LSTM_forcing_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># retrieve LSTM forcing data</span>
        <span class="c1"># read the forcing data from the LSTM forcing file</span>
        <span class="c1"># and return a dataframe with the same index as the LSTM results</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">)</span>
        <span class="n">ldf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">met_forcings_folder</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">_forcing.csv&#39;</span><span class="p">))</span>
        <span class="n">ldf</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Unnamed: 0&#39;</span><span class="p">:</span> <span class="s1">&#39;time&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ldf</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">ldf</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>
        <span class="n">ldf</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ldf</span> <span class="o">=</span> <span class="n">ldf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stn_df</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        <span class="c1"># convert to unit area runoff (L/s/km2)</span>
        <span class="n">ldf</span><span class="p">[</span><span class="s1">&#39;uar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">ldf</span><span class="p">[</span><span class="s1">&#39;discharge&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_da</span>
        <span class="k">return</span> <span class="n">ldf</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_plot_pmfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pmf_time</span><span class="p">,</span> <span class="n">pmf_freq</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">):</span>
        <span class="c1"># plot using bokeh</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="n">pmf_time</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;Time Ensemble&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="n">line_dash</span><span class="p">)</span>
        <span class="c1"># f.line(self.data.baseline_log_grid, pmf1, line_width=2, color=&#39;red&#39;, legend_label=&#39;T_MeanLinEns PMF&#39;, line_dash=line_dash)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="n">pmf_freq</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;purple&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;Frequency Ensemble&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="n">line_dash</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;Observed&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="n">line_dash</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="s1">&#39;Log UAR (L/s/km2)&#39;</span>
        <span class="n">f</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="s1">&#39;PMF&#39;</span>
        <span class="n">f</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="s1">&#39;top_left&#39;</span>
        <span class="n">f</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">background_fill_alpha</span> <span class="o">=</span> <span class="mf">0.25</span>
        <span class="n">f</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">click_policy</span> <span class="o">=</span> <span class="s1">&#39;hide&#39;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">format_fig_fonts</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
        <span class="n">show</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_time_ensemble_pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_cols</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">data</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">temporal_ensemble_log</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># this is still in log space</span>
        <span class="n">temporal_ensemble</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">temporal_ensemble_log</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">pmf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_kde_fit</span><span class="p">(</span><span class="n">temporal_ensemble</span><span class="p">)</span>
        <span class="c1"># this computes the PMF in linear space</span>
        <span class="c1"># foo = np.exp(data).mean(axis=1)</span>
        <span class="c1"># pmf1, _ = self._compute_kde_fit(foo.values)</span>
        <span class="k">return</span> <span class="n">pmf</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_frequency_ensemble_pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_cols</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">data</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># compute the frequency ensemble PMF</span>
        <span class="c1"># initialize a len(data) x n_sim_cols array</span>
        <span class="n">pmfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_cols</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_cols</span><span class="p">):</span>
            <span class="n">pmf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_kde_fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
            <span class="n">pmfs</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pmf</span>
        <span class="c1"># average the pmfs over the ensemble </span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">pmfs</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;len(pmfs) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">pmfs</span><span class="p">)</span><span class="si">}</span><span class="s1"> != len(baseline_log_grid) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span> 
        <span class="k">return</span> <span class="n">result</span>
        
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_process_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">divergence_measures</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">time_ensemble_pmf</span><span class="p">,</span> <span class="n">freq_ensemble_pmf</span><span class="p">,</span> <span class="n">baseline_pmf</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># compute the baseline pmf</span>
        <span class="c1"># compute the divergence measures</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">raw_pmf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="s1">&#39;Frequency&#39;</span><span class="p">],</span> <span class="p">[</span><span class="n">time_ensemble_pmf</span><span class="p">,</span> <span class="n">freq_ensemble_pmf</span><span class="p">]):</span>
            <span class="c1"># add the prior and renormalize</span>
            <span class="n">pmf</span> <span class="o">=</span> <span class="n">raw_pmf</span> <span class="o">+</span> <span class="n">eps</span>
            <span class="n">pmf</span> <span class="o">/=</span> <span class="n">pmf</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;raw_pmf&#39;</span><span class="p">:</span> <span class="n">raw_pmf</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="s1">&#39;pmf&#39;</span><span class="p">:</span> <span class="n">pmf</span><span class="o">.</span><span class="n">tolist</span><span class="p">()}</span>
            <span class="k">for</span> <span class="n">measure</span> <span class="ow">in</span> <span class="n">divergence_measures</span><span class="p">:</span>
                <span class="n">bias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_bias_from_eps</span><span class="p">(</span><span class="n">raw_pmf</span><span class="p">,</span> <span class="n">measure</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">divergence_functions</span><span class="p">[</span><span class="n">measure</span><span class="p">](</span><span class="n">baseline_pmf</span><span class="p">,</span> <span class="n">pmf</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">bias</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bias</span> <span class="o">==</span> <span class="o">-</span><span class="mf">0.0</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">bias</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;sum P = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="n">bias</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">bias_pct</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">bias</span> <span class="o">/</span> <span class="n">d</span>
                <span class="k">if</span> <span class="n">bias_pct</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Warning: bias is &gt; 5% of measure: </span><span class="si">{</span><span class="n">bias_pct</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">%&#39;</span><span class="p">)</span>
                
                <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">measure</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">d</span><span class="p">,</span> <span class="s1">&#39;bias&#39;</span><span class="p">:</span> <span class="n">bias</span><span class="p">,</span> <span class="s1">&#39;bias_pct&#39;</span><span class="p">:</span> <span class="n">bias_pct</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">results</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">run_estimators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">divergence_measures</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">baseline_pmf</span><span class="p">):</span>
        <span class="c1"># met_forcing = self._load_LSTM_forcing_file()  # Load LSTM forcing data</span>
        <span class="n">time_ensemble_pmf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_time_ensemble_pmf</span><span class="p">()</span>
        <span class="n">freq_ensemble_pmf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_frequency_ensemble_pmf</span><span class="p">()</span>
        <span class="c1"># self._plot_pmfs(time_ensemble_pmf, freq_ensemble_pmf)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_result</span><span class="p">(</span><span class="n">divergence_measures</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">time_ensemble_pmf</span><span class="p">,</span> <span class="n">freq_ensemble_pmf</span><span class="p">,</span> <span class="n">baseline_pmf</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">FDCEstimatorRunner</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stn_id</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">methods</span><span class="p">,</span> <span class="n">k_nearest</span><span class="p">,</span> <span class="n">parametric_target_cols</span><span class="p">,</span> <span class="n">estimator_classes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span> <span class="o">=</span> <span class="n">stn_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">methods</span> <span class="o">=</span> <span class="n">methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span> <span class="o">=</span> <span class="n">k_nearest</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parametric_target_cols</span> <span class="o">=</span> <span class="n">parametric_target_cols</span>
        <span class="c1"># self._check_min_overlap()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_results_folders</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_readme</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ESTIMATOR_CLASSES</span> <span class="o">=</span> <span class="n">estimator_classes</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_create_results_folders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># create a results foder for each method if it doesn&#39;t exist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;fdc_estimation_results&#39;</span><span class="p">,)</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">methods</span><span class="p">:</span>
            <span class="n">method_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results_folder</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">method_folder</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">method_folder</span><span class="p">)</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_readme</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># create a readme file in the results folder to list constraints</span>
        <span class="n">readme_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results_folder</span><span class="p">,</span> <span class="s1">&#39;README.txt&#39;</span><span class="p">)</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">readme_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;This folder contains the results of the FDC estimation.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Methods evaluated: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">methods</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># add the concurrency constraint and number of stations represented in the network</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">official_ids</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">LSTM_concurrent_network</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Uses only stations within Daymet input period of record / LSTM results: N=</span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s1"> stations in the network.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Global start date on streamflow data: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">global_start_date</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Uses all available network stations in the BCUB region (1950-2024): N=</span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s1"> stationsin the network.&#39;</span><span class="p">)</span>
                

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_ground_truth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kde</span> <span class="o">=</span> <span class="n">KDEEstimator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kde</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">stn_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">uar_label</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">target_da</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">baseline_pmf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline_pmf</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_save_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>


    <span class="c1"># def _check_min_overlap(self):</span>
    <span class="c1">#     if not self.ctx.LSTM_concurrent_network:</span>
    <span class="c1">#         print(&#39;    Skipping minimum overlap check for non-LSTM concurrent network.&#39;)</span>
    <span class="c1">#     else: </span>
    <span class="c1">#         for min_overlap_proportion, cdict in self.ctx.overlap_dict.items():</span>
    <span class="c1">#             min_concurrent_stns = 1e6</span>
    <span class="c1">#             n_less_than_ten, lonely_stns = 0, []</span>
    <span class="c1">#             for stn, concurrent_ids in cdict.items():</span>
    <span class="c1">#                 n_candidates = len(concurrent_ids)</span>
    <span class="c1">#                 if n_candidates &lt; 10:</span>
    <span class="c1">#                     n_less_than_ten += 1</span>
    <span class="c1">#                     lonely_stns.append(stn)</span>
    <span class="c1">#                 if n_candidates &lt; min_concurrent_stns:</span>
    <span class="c1">#                     min_concurrent_stns = n_candidates</span>
    <span class="c1">#             # print(f&quot;    ....{n_less_than_ten} stations do not have at least 10 viable sensors in the network covering at least {min_overlap_proportion}% of the target record.&quot;)</span>

 
    <span class="k">def</span><span class="w"> </span><span class="nf">run_selected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># check the minimum number of years of overlap for all stations in self.ctx.overlap_dict</span>
        
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">methods</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results_folder</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span><span class="si">}</span><span class="s1">_fdc_results.json&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result_file</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">StationData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">k_nearest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">parametric_target_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parametric_target_cols</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_process_ground_truth</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">EstimatorClass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ESTIMATOR_CLASSES</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
                <span class="n">estimator</span> <span class="o">=</span> <span class="n">EstimatorClass</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">run_estimators</span><span class="p">(</span>
                    <span class="n">divergence_measures</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">divergence_measures</span><span class="p">,</span> 
                    <span class="n">eps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
                    <span class="n">baseline_pmf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_save_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> estimator failed for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ParametricFDCEstimator</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">target_stn</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># super().__init__(*args, **kwargs)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span> <span class="o">=</span> <span class="n">target_stn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="c1"># self.data = data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">predicted_param_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_lognorm_pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">pdf</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
        <span class="n">raw_pmf</span> <span class="o">=</span> <span class="n">pdf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>
        <span class="n">pmf</span> <span class="o">=</span> <span class="n">raw_pmf</span> <span class="o">+</span> <span class="n">eps</span>
        <span class="n">pmf</span> <span class="o">/=</span> <span class="n">pmf</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">raw_pmf</span><span class="p">,</span> <span class="n">pmf</span><span class="p">,</span> <span class="n">pdf</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_GEV_pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
        <span class="c1"># assert values are within the valid range for GEV</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>  <span class="c1"># clip xi to avoid numerical issues</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>  <span class="c1"># ensure sigma is positive</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="n">genextreme</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">pdf</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
        <span class="n">raw_pmf</span> <span class="o">=</span> <span class="n">pdf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>
        <span class="n">raw_pmf</span> <span class="o">/=</span> <span class="n">raw_pmf</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># normalize raw PMF</span>
        <span class="n">pmf</span> <span class="o">=</span> <span class="n">raw_pmf</span> <span class="o">+</span> <span class="n">eps</span>
        <span class="n">pmf</span> <span class="o">/=</span> <span class="n">pmf</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">raw_pmf</span><span class="p">,</span> <span class="n">pmf</span><span class="p">,</span> <span class="n">pdf</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_estimate_from_mle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">][</span><span class="s1">&#39;mean_logx_actual&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">][</span><span class="s1">&#39;sd_logx_actual&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_lognorm_pmf</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
    

    <span class="c1"># def _estimate_from_observed_lmoments_gev(self, eps=1e-12):</span>
    <span class="c1">#     # compute the GEV parameters from the L-moments</span>
    <span class="c1">#     xi = self.data.LN_param_dict[&#39;logx_lmom_xi&#39;][self.target_stn][&#39;actual&#39;]</span>
    <span class="c1">#     loc = self.data.LN_param_dict[&#39;logx_lmom_loc&#39;][self.target_stn][&#39;actual&#39;]</span>
    <span class="c1">#     scale = self.data.LN_param_dict[&#39;logx_lmom_scale&#39;][self.target_stn][&#39;actual&#39;]</span>
    <span class="c1">#     return self._compute_GEV_pmf(xi, loc, scale, eps=eps)</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_estimate_from_predicted_log_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">][</span><span class="s1">&#39;mean_logx_mean_predicted&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">][</span><span class="s1">&#39;sd_logx_mean_predicted&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_lognorm_pmf</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
        
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_estimate_from_predicted_linear_mom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
        <span class="n">mean_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">][</span><span class="s1">&#39;mean_uar_mean_predicted&#39;</span><span class="p">]</span>
        <span class="n">sd_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">][</span><span class="s1">&#39;sd_uar_mean_predicted&#39;</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">sd_x</span> <span class="o">/</span> <span class="n">mean_x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mean_x</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">v</span>
        <span class="c1"># compute the lognormal pmf</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_lognorm_pmf</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_estimate_LN_from_randomly_drawn_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
        <span class="c1"># randomly draw from the predicted parameters</span>
        <span class="n">random_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_df</span><span class="p">))</span>
        <span class="n">random_stn_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">random_idx</span><span class="p">]</span>
        <span class="n">mu_random</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="n">random_stn_idx</span><span class="p">][</span><span class="s1">&#39;mean_logx_mean_predicted&#39;</span><span class="p">]</span>
        <span class="n">sigma_random</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="n">random_stn_idx</span><span class="p">][</span><span class="s1">&#39;sd_logx_mean_predicted&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_lognorm_pmf</span><span class="p">(</span><span class="n">mu_random</span><span class="p">,</span> <span class="n">sigma_random</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>

    <span class="c1"># def _estimate_LMOM_gev_from_randomly_drawn_params(self, eps=1e-12):</span>
    <span class="c1">#     # randomly draw from the predicted parameters</span>
    <span class="c1">#     random_idx = np.random.choice(len(self.predicted_parameter_sample[&#39;mean_uar_lmom_xi&#39;]))</span>
    <span class="c1">#     xi = self.predicted_parameter_sample[&#39;mean_uar_lmom_xi&#39;][random_idx]</span>
    <span class="c1">#     loc = self.predicted_parameter_sample[&#39;mean_uar_lmom_loc&#39;][random_idx]</span>
    <span class="c1">#     scale = self.predicted_parameter_sample[&#39;mean_uar_lmom_scale&#39;][random_idx]</span>
    <span class="c1">#     xi = max(xi, -0.5 + eps)  # clip xi to avoid numerical issues</span>
    <span class="c1">#     scale = max(scale, 0.01)  # ensure scale is positive</span>
    <span class="c1">#     # compute the GEV PMF</span>
    <span class="c1">#     return self._compute_GEV_pmf(xi, loc, scale, eps=eps)    </span>

    <span class="c1"># def _estimate_from_predicted_lmoments_gev(self, eps=1e-12):</span>
    <span class="c1">#     # compute the GEV parameters from the L-moments</span>
    <span class="c1">#     xi = self.data.LN_param_dict[&#39;mean_uar_lmom_xi&#39;][self.target_stn][&#39;predicted&#39;]</span>
    <span class="c1">#     loc = self.data.LN_param_dict[&#39;logx_lmom_loc&#39;][self.target_stn][&#39;predicted&#39;]</span>
    <span class="c1">#     scale = self.data.LN_param_dict[&#39;logx_lmom_scale&#39;][self.target_stn][&#39;predicted&#39;]</span>
    <span class="c1">#     return self._compute_GEV_pmf(xi, loc, scale, eps=eps)</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">run_estimators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">divergence_measures</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">baseline_pmf</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">fns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_from_mle</span><span class="p">,</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_from_predicted_log_params</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_from_predicted_linear_mom</span><span class="p">,</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_LN_from_randomly_drawn_params</span><span class="p">,</span>
            <span class="c1"># self._estimate_from_observed_lmoments_gev,</span>
            <span class="c1"># self._estimate_from_predicted_lmoments_gev, </span>
            <span class="c1"># self._estimate_LMOM_gev_from_randomly_drawn_params</span>
            <span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;MLE&#39;</span><span class="p">,</span> <span class="s1">&#39;PredictedLog&#39;</span><span class="p">,</span> <span class="s1">&#39;PredictedMOM&#39;</span><span class="p">,</span> <span class="s1">&#39;RandomDraw&#39;</span><span class="p">,</span> 
                  <span class="c1">#&#39;ObsLMomentsGEV&#39;, &#39;PredictedLMomentsGEV&#39;, &#39;LMomentsGEVRandomDraw&#39;,</span>
                  <span class="p">]</span>
        <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fns</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
            <span class="n">raw_pmf</span><span class="p">,</span> <span class="n">pmf</span><span class="p">,</span> <span class="n">pdf</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;Moments&#39;</span> <span class="ow">in</span> <span class="n">label</span><span class="p">:</span>
                <span class="c1"># assert no nan values in the pmf</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pmf</span><span class="p">)),</span> <span class="sa">f</span><span class="s1">&#39;PMF contains NaN values for </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">pmf</span><span class="p">[:</span><span class="mi">100</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;raw_pmf&#39;</span><span class="p">:</span> <span class="n">raw_pmf</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="s1">&#39;pmf&#39;</span><span class="p">:</span> <span class="n">pmf</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="s1">&#39;pdf&#39;</span><span class="p">:</span> <span class="n">pdf</span><span class="o">.</span><span class="n">tolist</span><span class="p">()}</span>
            <span class="k">for</span> <span class="n">measure</span> <span class="ow">in</span> <span class="n">divergence_measures</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">divergence_functions</span><span class="p">[</span><span class="n">measure</span><span class="p">](</span><span class="n">baseline_pmf</span><span class="p">,</span> <span class="n">pmf</span><span class="p">)</span>
                <span class="n">bias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_bias_from_eps</span><span class="p">(</span><span class="n">raw_pmf</span><span class="p">,</span> <span class="n">measure</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">bias</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bias</span> <span class="o">==</span> <span class="o">-</span><span class="mf">0.0</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">bias</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;sum P = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="n">bias</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">bias_pct</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">bias</span> <span class="o">/</span> <span class="n">d</span>
                <span class="k">if</span> <span class="n">bias_pct</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Warning: bias is &gt; 5% of measure: </span><span class="si">{</span><span class="n">bias_pct</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">%&#39;</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">measure</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">d</span><span class="p">,</span> <span class="s1">&#39;bias&#39;</span><span class="p">:</span> <span class="n">bias</span><span class="p">,</span> <span class="s1">&#39;bias_pct&#39;</span><span class="p">:</span> <span class="n">bias_pct</span><span class="p">}</span>
                <span class="c1"># if measure == &#39;DKL&#39;:</span>
                <span class="c1">#     print(f&#39;     {label} {measure} = {d:.3f} bits/sample&#39;)</span>
        <span class="c1"># compute the bias from the eps</span>
        <span class="k">return</span> <span class="n">results</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">kNNFDCEstimator</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">target_stn</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span> <span class="o">=</span> <span class="n">target_stn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">k_nearest</span>
        <span class="c1"># self.max_to_check_start = data.max_to_check</span>
        <span class="c1"># self.max_to_check = data.max_to_check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_schemes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="c1">#inverse distance and inverse square distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_find_k_nearest_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_type</span><span class="p">,</span> <span class="n">max_to_check</span><span class="p">):</span>
        <span class="c1"># Query the k+1 nearest neighbors because the first neighbor is the target point itself</span>
        <span class="n">target_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_idx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tree_type</span> <span class="o">==</span> <span class="s1">&#39;spatial_dist&#39;</span><span class="p">:</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">spatial_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">target_idx</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">max_to_check</span><span class="p">)</span>
            <span class="n">distances</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="k">elif</span> <span class="n">tree_type</span> <span class="o">==</span> <span class="s1">&#39;attribute_dist&#39;</span><span class="p">:</span>
            <span class="c1"># Example query: Find the nearest neighbors for the first point</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">attribute_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">normalized_attr_values</span><span class="p">[</span><span class="n">target_idx</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">max_to_check</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;tree type not identified, must be one of spatial_dist, or attribute_dist.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Remove target (self) from the results</span>
        <span class="n">self_index</span> <span class="o">=</span> <span class="n">target_idx</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">!=</span> <span class="n">self_index</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">indices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_effective_k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">max_k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">T</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">max_k</span> <span class="o">=</span> <span class="n">max_k</span> <span class="ow">or</span> <span class="n">K</span>

        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">sorted_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">row_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">T</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">effective_k</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mean_furthest</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ks</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">sorted_idx</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">nan_mask</span><span class="p">[</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">valid_count</span> <span class="o">=</span> <span class="n">valid</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">effective_k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valid_count</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
            <span class="n">furthest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">mean_furthest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">furthest_idx</span><span class="p">[</span><span class="n">valid_count</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">valid_count</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;effective_k&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">effective_k</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="s1">&#39;mean_furthest_idx&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">mean_furthest</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">},</span> <span class="n">index</span><span class="o">=</span><span class="n">ks</span><span class="p">)</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_complete_years</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number of complete years in df where each of the 12 months</span>
<span class="sd">        has at least `min_days_per_month` valid observations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">dates</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>
        <span class="n">years</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">year</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dates</span><span class="p">])</span>
        <span class="n">months</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">month</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dates</span><span class="p">])</span>

        <span class="c1"># Build count array: (year, month) → count</span>
        <span class="n">ym_counts</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">years</span><span class="p">,</span> <span class="n">months</span><span class="p">):</span>
            <span class="n">ym_counts</span><span class="p">[(</span><span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Group into full years</span>
        <span class="n">year_to_month_counts</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">ym_counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">year_to_month_counts</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>

        <span class="c1"># A year is complete if it has all 12 months with enough days</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">counts</span> <span class="ow">in</span> <span class="n">year_to_month_counts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">12</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">minimum_days_per_month</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">)</span>
        <span class="p">]</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_query_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">id1</span><span class="p">,</span> <span class="n">id2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Query distance between two points in a tree using official_id.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">id1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_idx</span> <span class="ow">or</span> <span class="n">id2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_idx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;One or both IDs (</span><span class="si">{</span><span class="n">id1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">id2</span><span class="si">}</span><span class="s2">) not found.&quot;</span><span class="p">)</span>
    
        <span class="c1"># Get indices from ID mapping</span>
        <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_idx</span><span class="p">[</span><span class="n">id1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_idx</span><span class="p">[</span><span class="n">id2</span><span class="p">]</span>
        <span class="c1"># Query the distance</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index2</span><span class="p">])</span>  <span class="c1"># Euclidean distance</span>
        <span class="k">return</span> <span class="n">distance</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_retrieve_nearest_nbr_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_type</span><span class="p">):</span>
        <span class="n">MAX_CHECK</span> <span class="o">=</span> <span class="mi">700</span>
        <span class="n">REQUIRED_GOOD</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="c1"># Get the index of the target station</span>
        
        <span class="c1"># Query once for all potential neighbors</span>
        <span class="n">nbr_idxs</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_k_nearest_neighbors</span><span class="p">(</span><span class="n">tree_type</span><span class="p">,</span> <span class="n">MAX_CHECK</span><span class="p">)</span>
        <span class="n">nbr_ids</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">idx_to_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nbr_idxs</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">idx_to_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">]</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nbr_idxs</span><span class="p">,</span> <span class="n">dists</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">idx_to_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">]</span>

        <span class="n">good_nbrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sorted_nbrs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nbr_ids</span><span class="p">,</span> <span class="n">distances</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">nbr_id</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span> <span class="ow">in</span> <span class="n">sorted_nbrs</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">retrieve_timeseries_discharge</span><span class="p">(</span><span class="n">nbr_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">or</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># Skip bad or empty DataFrames</span>
            <span class="n">col</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">nbr_id</span><span class="si">}</span><span class="s1">_uar&#39;</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># Skip if expected column is missing</span>
            <span class="n">proxy_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="n">col</span><span class="p">]]</span>
            <span class="n">complete_years</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_complete_years</span><span class="p">(</span><span class="n">proxy_df</span><span class="p">))</span>
            <span class="n">n_years</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">complete_years</span><span class="p">)</span>
            <span class="n">good_nbrs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nbr_id</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">n_years</span><span class="p">,</span> <span class="n">proxy_df</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_nbrs</span><span class="p">)</span> <span class="o">==</span> <span class="n">REQUIRED_GOOD</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">good_nbrs</span><span class="p">)</span><span class="si">}</span><span class="s2"> good neighbors for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s2"> by </span><span class="si">{</span><span class="n">tree_type</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="c1"># Concatenate the timeseries</span>
        <span class="n">nbr_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">good_nbrs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Build metadata DataFrame</span>
        <span class="n">complement_type</span> <span class="o">=</span> <span class="s1">&#39;attribute_dist&#39;</span> <span class="k">if</span> <span class="n">tree_type</span> <span class="o">==</span> <span class="s1">&#39;spatial_dist&#39;</span> <span class="k">else</span> <span class="s1">&#39;spatial_dist&#39;</span>
        <span class="n">complement_tree</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">complement_type</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">_tree&quot;</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">1000</span> <span class="k">if</span> <span class="n">complement_type</span> <span class="o">==</span> <span class="s1">&#39;spatial_dist&#39;</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="n">nbr_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">[</span><span class="n">r</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">good_nbrs</span><span class="p">],</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="s1">&#39;n_years&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">nbr_data</span><span class="p">[</span><span class="n">complement_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">nbr_data</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_distance</span><span class="p">(</span><span class="n">complement_tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_nearest_neighbour_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate nearest neighbours for spatial and attribute selected k-nearest neighbours for both concurrent and asynchronous records.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    ...initializing nearest neighbours with minimum concurrent record.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbr_dfs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="n">tree_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;spatial_dist&#39;</span><span class="p">,</span> <span class="s1">&#39;attribute_dist&#39;</span><span class="p">]:</span>
            <span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieve_nearest_nbr_data</span><span class="p">(</span><span class="n">tree_type</span><span class="p">)</span>
            <span class="n">effective_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_effective_k</span><span class="p">(</span><span class="n">nbr_df</span><span class="p">,</span> <span class="n">max_k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nbr_dfs</span><span class="p">[</span><span class="n">tree_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;nbr_df&#39;</span><span class="p">:</span> <span class="n">nbr_df</span><span class="p">,</span>
                <span class="s1">&#39;nbr_data&#39;</span><span class="p">:</span> <span class="n">nbr_data</span><span class="p">,</span>
                <span class="s1">&#39;effective_k&#39;</span><span class="p">:</span> <span class="n">effective_k</span><span class="p">,</span>
            <span class="p">}</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute normalized inverse (square) distance weights to a given power.&quot;&quot;&quot;</span>

        <span class="n">distances</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distances</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inv_weights</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">**</span> <span class="n">m</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">inv_weights</span> <span class="o">/</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">inv_weights</span><span class="p">)</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_prior_from_laplace_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicted_uar</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_prior</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">scale_factor</span><span class="o">=</span><span class="mf">1.05</span><span class="p">,</span> <span class="n">recursion_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a Laplace distribution to the simulation and define a </span>
<span class="sd">        pdf across a pre-determined &quot;global&quot; range to avoid data</span>
<span class="sd">        leakage.  &quot;Normalize&quot; by setting the total prior mass to</span>
<span class="sd">        integrate to a factor related to the number of observations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># assert no nan values</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">predicted_uar</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;NaN values in predicted_uar: </span><span class="si">{</span><span class="n">predicted_uar</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="c1"># assert all positive values</span>
        <span class="c1"># assert np.all(predicted_uar &gt; 0), f&#39;Negative values in predicted_uar: {np.min(predicted_uar)}&#39;</span>
        <span class="c1"># replace anything &lt;= 0 with 1e-4 scaled by the drainage area</span>
        <span class="n">predicted_uar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">predicted_uar</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mf">1e-4</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">target_da</span><span class="p">,</span> <span class="n">predicted_uar</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">predicted_uar</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;Negative values in predicted_uar: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">predicted_uar</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="c1"># print(&#39;min/max: &#39;, np.min(predicted_uar), np.max(predicted_uar))</span>
        <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">laplace</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">predicted_uar</span><span class="p">))</span>       

        <span class="c1"># Apply scale factor in case of recursion</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">original_scale</span> <span class="o">=</span> <span class="n">scale</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">scale_factor</span> <span class="o">**</span> <span class="n">recursion_depth</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;   Adjusting scale from </span><span class="si">{</span><span class="n">original_scale</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">scale</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> for recursion depth </span><span class="si">{</span><span class="n">recursion_depth</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">prior_pdf</span> <span class="o">=</span> <span class="n">laplace</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">prior_check</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">prior_pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
        <span class="n">prior_pdf</span> <span class="o">/=</span> <span class="n">prior_check</span>

        <span class="c1"># Check for zeros</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prior_pdf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">prior_pdf</span><span class="p">)):</span>
            <span class="c1"># Prevent scale from being too small</span>
            <span class="k">if</span> <span class="n">recursion_depth</span> <span class="o">&gt;=</span> <span class="n">max_depth</span><span class="p">:</span>
                <span class="c1"># set a very small prior</span>
                <span class="n">prior_pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Recursion limit reached. Scale=</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2">, setting default prior to 1 pseudo-count uniform distribution.&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">prior_pdf</span>
                <span class="c1"># raise ValueError(err_msg)</span>
            <span class="c1"># print(f&quot;Recursion {recursion_depth}: Zero values detected. Increasing scale to {scale:.6f}&quot;)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_prior_from_laplace_fit</span><span class="p">(</span><span class="n">predicted_uar</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="n">n_cols</span><span class="p">,</span> <span class="n">recursion_depth</span><span class="o">=</span><span class="n">recursion_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="n">second_check</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">prior_pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">second_check</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">2e-4</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;prior check != 1, </span><span class="si">{</span><span class="n">second_check</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1"> N=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted_uar</span><span class="p">)</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">predicted_uar</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">prior_pdf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;min prior == 0, scale=</span><span class="si">{</span><span class="n">scale</span><span class="si">:</span><span class="s1">.5f</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="c1"># convert prior PDF to PMF (pseudo-count mass function)</span>
        <span class="n">prior_pmf</span> <span class="o">=</span> <span class="n">prior_pdf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>

        <span class="c1"># scale the number of pseudo-counts based on years of record  (365 / n_observations)</span>
        <span class="c1"># and number of models in the ensemble (given by n_cols)</span>
        <span class="n">prior_pseudo_counts</span> <span class="o">=</span> <span class="n">prior_pmf</span> <span class="o">*</span> <span class="p">(</span><span class="mi">365</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted_uar</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_cols</span><span class="p">))</span>
        
        <span class="c1"># return weighted_prior_pdf</span>
        <span class="k">return</span> <span class="n">prior_pseudo_counts</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_frequency_ensemble_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdfs</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function computes the weighted ensemble distribution estimates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Normalize distance weights</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  <span class="c1"># Ensure 1D array</span>
            <span class="n">pdf_est</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pdfs</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">@</span> <span class="n">weights</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pdf_est</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pdfs</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>


        <span class="c1"># Check integral before normalization</span>
        <span class="n">pdf_check</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">pdf_est</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
        <span class="n">normalized_pdf</span> <span class="o">=</span> <span class="n">pdf_est</span> <span class="o">/</span> <span class="n">pdf_check</span>
        <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">normalized_pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;ensemble pdf does not integrate to 1: </span><span class="si">{</span><span class="n">pdf_check</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span>
                
        <span class="c1"># Compute PMF</span>
        <span class="n">pmf_est</span> <span class="o">=</span> <span class="n">normalized_pdf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>
        <span class="n">pmf_est</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf_est</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pmf_est</span><span class="p">,</span> <span class="n">pdf_est</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_ensemble_member_distribution_estimates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the ensemble distribution estimates based on the KNN dataframe.</span>
<span class="sd">        &quot;&quot;&quot;</span>    
        <span class="n">pdfs</span><span class="p">,</span> <span class="n">prior_biases</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(),</span> <span class="p">{}</span>
        <span class="c1"># initialize a kde estimator object</span>
        <span class="n">kde</span> <span class="o">=</span> <span class="n">KDEEstimator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span> 
            <span class="c1"># evaluate the laplace on the prediction as a prior</span>
            <span class="c1"># drop the nan values</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
            <span class="n">obs_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;0 values for </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s1">&#39;</span>

            <span class="c1"># compute the pdf and pmf using kde</span>
            <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;NaN values in </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">values</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>

            <span class="n">kde_pmf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">kde</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span>
                <span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">target_da</span>
            <span class="p">)</span>

            <span class="n">prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_prior_from_laplace_fit</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># priors are expressed in pseudo-counts</span>
            <span class="c1"># convert the pdf to counts and apply the prior</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">kde_pmf</span> <span class="o">*</span> <span class="n">obs_count</span> <span class="o">+</span> <span class="n">prior</span>

            <span class="c1"># re-normalize the pmf</span>
            <span class="n">pmf</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            <span class="n">pdf</span> <span class="o">=</span> <span class="n">pmf</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>

            <span class="n">pdf_check</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
            <span class="n">pdf</span> <span class="o">/=</span> <span class="n">pdf_check</span>
            <span class="c1"># pdf /= pdf_check</span>
            <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;pdf does not integrate to 1 in compute_ensemble_member_distribution_estimates: </span><span class="si">{</span><span class="n">pdf_check</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">pdfs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdf</span>

            <span class="c1"># convert the pdf to pmf</span>
            <span class="n">pmf</span> <span class="o">=</span> <span class="n">pdf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>
            <span class="n">pmf</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf</span><span class="p">)</span>
            <span class="c1"># assert np.isclose(np.sum(pmf), 1, atol=1e-4), f&#39;pmf does not sum to 1 in compute_ensemble_member_distribution_estimates: {np.sum(pmf):.5f}&#39;</span>
            
            <span class="c1"># compute the bias added by the prior</span>
            <span class="n">prior_biases</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;DKL&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_kld</span><span class="p">(</span><span class="n">kde_pmf</span><span class="p">,</span> <span class="n">pmf</span><span class="p">),</span> <span class="s1">&#39;EMD&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_emd</span><span class="p">(</span><span class="n">kde_pmf</span><span class="p">,</span> <span class="n">pmf</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">pdfs</span><span class="p">,</span> <span class="n">prior_biases</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_frequency_ensemble_distributions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For asynchronous comparisons, we estimate pdfs for ensemble members, then compute the mean in the time domain</span>
<span class="sd">        to represent the FDC simulation.  We do not do temporal averaging in this case.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># distances_all = knn_data_all[&#39;distance&#39;].values[:self.k_nearest]</span>
        <span class="c1"># nbr_ids_all = knn_data_all[&#39;official_id&#39;].values[:self.k_nearest]</span>
        <span class="n">knn_df_all</span> <span class="o">=</span> <span class="n">nbr_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">knn_data_all</span> <span class="o">=</span> <span class="n">nbr_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">frequency_ensemble_pdfs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_ensemble_member_distribution_estimates</span><span class="p">(</span><span class="n">knn_df_all</span><span class="p">)</span>
        
        <span class="c1"># distances = jnp.array(nbr_data[&#39;distance&#39;].astype(float).values)</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">pdfs</span><span class="p">,</span> <span class="n">pmfs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">all_distances</span> <span class="o">=</span> <span class="n">knn_data_all</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">all_ids</span> <span class="o">=</span> <span class="n">knn_data_all</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># prior_bias_df = pd.DataFrame(prior_bias_dict)</span>
        <span class="k">for</span> <span class="n">wm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_schemes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">distances</span> <span class="o">=</span> <span class="n">all_distances</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>
                <span class="n">nbr_ids</span> <span class="o">=</span> <span class="n">all_ids</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>
                <span class="n">knn_pdfs</span> <span class="o">=</span> <span class="n">frequency_ensemble_pdfs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">_NN_</span><span class="si">{</span><span class="n">distance_type</span><span class="si">}</span><span class="s1">_ID</span><span class="si">{</span><span class="n">wm</span><span class="si">}</span><span class="s1">_freqEnsemble&#39;</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_weights</span><span class="p">(</span><span class="n">wm</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
                <span class="n">pmf_est</span><span class="p">,</span> <span class="n">pdf_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_frequency_ensemble_mean</span><span class="p">(</span><span class="n">knn_pdfs</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">pmf_est</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;pmf_est is None for </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">&#39;</span>
            
                <span class="c1"># compute the mean number of observations (non-nan values) per row</span>
                <span class="n">mean_obs_per_timestep</span> <span class="o">=</span> <span class="n">knn_df_all</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">mean_obs_per_proxy</span> <span class="o">=</span> <span class="n">knn_df_all</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
      
                <span class="c1"># compute the frequency-based ensemble pdf estimate</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span> <span class="s1">&#39;n_obs&#39;</span><span class="p">:</span> <span class="n">mean_obs_per_proxy</span><span class="p">,</span>
                                                <span class="s1">&#39;mean_obs_per_timestep&#39;</span><span class="p">:</span> <span class="n">mean_obs_per_timestep</span><span class="p">,</span>
                                                <span class="s1">&#39;nbrs&#39;</span><span class="p">:</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nbr_ids</span><span class="p">)}</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;DKL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_kld</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">,</span> <span class="n">pmf_est</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;EMD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_emd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">,</span> <span class="n">pmf_est</span><span class="p">)</span>
                
                <span class="n">pdfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pdf_est</span><span class="p">))</span>
                <span class="n">pmfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pmf_est</span><span class="p">))</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="c1"># create a dataframe of labels(columns) for each pdf</span>
        <span class="n">knn_pdfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pdfs</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">knn_pmfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pmfs</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># Filter out already existing columns to avoid duplication</span>
        <span class="n">new_pdf_cols</span> <span class="o">=</span> <span class="n">knn_pdfs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">new_pmf_cols</span> <span class="o">=</span> <span class="n">knn_pmfs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="c1"># Concat only new columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="p">,</span> <span class="n">knn_pdfs</span><span class="p">[</span><span class="n">new_pdf_cols</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span><span class="p">,</span> <span class="n">knn_pmfs</span><span class="p">[</span><span class="n">new_pmf_cols</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_delta_spike_pmf_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span> <span class="n">log_grid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a spike PMF and compatible PDF centered at the only value in the input.</span>
<span class="sd">        The spike is placed at the nearest log_grid point to log(single_val).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log_val</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">single_val</span><span class="p">)</span>
        <span class="n">spike_idx</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">log_grid</span> <span class="o">-</span> <span class="n">log_val</span><span class="p">))</span>
        
        <span class="n">pmf</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">log_grid</span><span class="p">)</span>
        <span class="n">pmf</span> <span class="o">=</span> <span class="n">pmf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">spike_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">log_grid</span><span class="p">)</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="n">pmf</span> <span class="o">/</span> <span class="n">dx</span>  <span class="c1"># assign all mass to one bin</span>

        <span class="k">return</span> <span class="n">pmf</span><span class="p">,</span> <span class="n">pdf</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_nse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the Nash-Sutcliffe Efficiency (NSE) between observed and simulated values.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;NaN values in obs: </span><span class="si">{</span><span class="n">obs</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;NaN values in sim: </span><span class="si">{</span><span class="n">sim</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">obs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;Negative values in obs: </span><span class="si">{</span><span class="n">obs</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">sim</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;Negative values in sim: </span><span class="si">{</span><span class="n">sim</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="c1"># Compute the NSE</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">obs</span> <span class="o">-</span> <span class="n">sim</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">obs</span> <span class="o">-</span> <span class="n">obs</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">nse</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nse</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_KGE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the Kling-Gupta Efficiency (KGE) between observed and simulated values.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;NaN values in obs: </span><span class="si">{</span><span class="n">obs</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;NaN values in sim: </span><span class="si">{</span><span class="n">sim</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">obs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;Negative values in obs: </span><span class="si">{</span><span class="n">obs</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">sim</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;Negative values in sim: </span><span class="si">{</span><span class="n">sim</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="c1"># Compute the KGE</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">sim</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">/</span> <span class="n">obs</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">/</span> <span class="n">obs</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
        <span class="n">kge</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kge</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_ensemble_contribution_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
        
        <span class="c1"># Mean number of valid values per row</span>
        <span class="n">mean_valid_per_row</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="c1"># Normalized weights per row, masking NaNs</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">masked_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">weight_sums</span> <span class="o">=</span> <span class="n">masked_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">weight_sums</span><span class="p">[</span><span class="n">weight_sums</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">normalized_weights</span> <span class="o">=</span> <span class="n">masked_weights</span> <span class="o">/</span> <span class="n">weight_sums</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># Average contribution per column across all rows</span>
        <span class="n">mean_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">normalized_weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">effective_n</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">mean_w</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mean_valid_per_row</span><span class="p">,</span> <span class="n">effective_n</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_temporal_mean_ensemble_runoff_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">assert</span> <span class="o">~</span><span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span> <span class="s1">&#39;dataframe is empty&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">df</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="s2">&quot;All values are zero in df[cols] before processing&quot;</span>
        
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="o">~</span><span class="n">jnp</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">weights</span><span class="p">)),</span> <span class="sa">f</span><span class="s1">&#39;nan weight found: </span><span class="si">{</span><span class="n">weights</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;weights do not sum to 1: </span><span class="si">{</span><span class="n">weights</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="c1"># assert (weights &gt; 0).all(), f&#39;not all weights &gt; 0, {weights}&#39;</span>
            <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">weights</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;Weights must not = 0: weights=</span><span class="si">{</span><span class="n">weights</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">estimated_uar</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Some NaNs still in df: </span><span class="si">{</span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span> <span class="o">==</span> <span class="s1">&#39;float64&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">),</span> <span class="s2">&quot;Non-float column in df&quot;</span>
            <span class="n">estimated_uar</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">estimated_uar</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="s2">&quot;NaN values found in estimated_uar&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">estimated_uar</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="sa">f</span><span class="s2">&quot;Estimate &lt; 0 detected: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">estimated_uar</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">estimated_uar</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_weighted_row_mean_ignore_nan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In the case of computing weighted means across multiple columns,</span>
<span class="sd">        we need to adjust the column weights to account for NaN values.</span>
<span class="sd">        This function computes the weighted mean for each row, ignoring NaN values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set the right shape for the weights</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;df.shape[1] != len(weights): </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>  <span class="c1"># valid entries</span>
        <span class="n">masked_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="n">weight_sums</span> <span class="o">=</span> <span class="n">masked_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># avoid division by zero</span>
        <span class="n">weight_sums</span><span class="p">[</span><span class="n">weight_sums</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">normalized_weights</span> <span class="o">=</span> <span class="n">masked_weights</span> <span class="o">/</span> <span class="n">weight_sums</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">estimated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">normalized_weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">mean_valid_per_row</span><span class="p">,</span> <span class="n">effective_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_ensemble_contribution_metrics</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">estimated</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="n">mean_valid_per_row</span><span class="p">,</span> <span class="n">effective_k</span>
            

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_knn_data_effective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">wm</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">,</span> <span class="n">effective_k_nbrs</span><span class="p">):</span>
        <span class="n">eff_k_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbr_dfs</span><span class="p">[</span><span class="n">distance_type</span><span class="p">][</span><span class="s1">&#39;concurrent&#39;</span><span class="p">][</span><span class="s1">&#39;effective_k&#39;</span><span class="p">]</span>
        <span class="n">k_to_use</span> <span class="o">=</span> <span class="n">eff_k_df</span><span class="p">[</span><span class="n">eff_k_df</span><span class="p">[</span><span class="s1">&#39;effective_k&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mean_furthest_idx</span> <span class="o">=</span> <span class="n">eff_k_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">k_to_use</span><span class="p">,</span> <span class="s1">&#39;mean_furthest_idx&#39;</span><span class="p">]</span>
        
        <span class="n">knn_df</span> <span class="o">=</span> <span class="n">nbr_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k_to_use</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_weights</span><span class="p">(</span><span class="n">wm</span><span class="p">,</span> <span class="n">k_to_use</span><span class="p">,</span> <span class="n">distances</span><span class="p">[:</span><span class="n">k_to_use</span><span class="p">])</span>
        <span class="n">temporal_ensemble_mean</span><span class="p">,</span> <span class="n">mean_valid_per_row</span><span class="p">,</span> <span class="n">effective_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_row_mean_ignore_nan</span><span class="p">(</span><span class="n">knn_df</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">nbrs_used</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">knn_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">temporal_ensemble_mean</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">knn_df</span><span class="p">,</span> <span class="n">nbrs_used</span><span class="p">,</span> <span class="n">effective_k</span><span class="p">,</span> <span class="n">mean_furthest_idx</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_finalize_temporal_ensemble</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">temporal_ensemble_mean</span><span class="p">,</span> <span class="n">nbrs_used</span><span class="p">,</span>
            <span class="n">effective_k</span><span class="p">,</span> <span class="n">mean_valid_per_row</span>
            <span class="p">):</span>

        <span class="c1"># Clip to prevent zero runoff issues</span>
        <span class="n">temporal_ensemble_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
            <span class="n">temporal_ensemble_mean</span><span class="p">,</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mf">1e-4</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">target_da</span><span class="p">,</span> <span class="kc">None</span>
        <span class="p">)</span>

        <span class="c1"># Estimate prior from Laplace fit</span>
        <span class="n">prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_prior_from_laplace_fit</span><span class="p">(</span><span class="n">temporal_ensemble_mean</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Compute NSE and KGE</span>
        <span class="n">sim_df</span> <span class="o">=</span> <span class="n">temporal_ensemble_mean</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;sim&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
        <span class="n">sim_obs_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">stn_df</span><span class="p">[[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">_uar&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">sim_df</span><span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span>
        <span class="p">)</span>

        <span class="n">obs</span> <span class="o">=</span> <span class="n">sim_obs_df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">_uar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="n">sim_obs_df</span><span class="p">[</span><span class="s1">&#39;sim&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">nse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_nse</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">sim</span><span class="p">)</span>
        <span class="n">kge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_KGE</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">sim</span><span class="p">)</span>

        <span class="c1"># Estimate PDF/PMF using KDE or </span>
        <span class="c1"># add small amount of random noise if there is no variance</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">temporal_ensemble_mean</span><span class="o">.</span><span class="n">values</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">est_pmf</span><span class="p">,</span> <span class="n">est_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta_spike_pmf_pdf</span><span class="p">(</span>
                <span class="n">temporal_ensemble_mean</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">est_pmf</span><span class="p">,</span> <span class="n">est_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_kde</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span>
                <span class="n">temporal_ensemble_mean</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">target_da</span>
            <span class="p">)</span>

        <span class="k">assert</span> <span class="n">est_pmf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;pmf is None for </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="c1"># Store simulation outputs and metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">est_pdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">est_pmf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;nbrs&#39;</span><span class="p">:</span> <span class="n">nbrs_used</span><span class="p">,</span>
            <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span>
            <span class="s1">&#39;prior&#39;</span><span class="p">:</span> <span class="n">prior</span><span class="p">,</span>
            <span class="s1">&#39;nse&#39;</span><span class="p">:</span> <span class="n">nse</span><span class="p">,</span>
            <span class="s1">&#39;kge&#39;</span><span class="p">:</span> <span class="n">kge</span><span class="p">,</span>
            <span class="s1">&#39;n_obs&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">temporal_ensemble_mean</span><span class="p">),</span>
            <span class="s1">&#39;mean_&#39;</span><span class="p">:</span> <span class="n">mean_valid_per_row</span><span class="p">,</span>
            <span class="s1">&#39;mean_nbrs_per_timestep&#39;</span><span class="p">:</span> <span class="n">effective_k</span><span class="p">,</span>  <span class="c1"># rename if clearer</span>
            <span class="s1">&#39;effective_k&#39;</span><span class="p">:</span> <span class="n">effective_k</span><span class="p">,</span>
            <span class="s1">&#39;DKL&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_kld</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">,</span> <span class="n">est_pmf</span><span class="p">),</span>
            <span class="s1">&#39;EMD&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_emd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">,</span> <span class="n">est_pmf</span><span class="p">)</span>
        <span class="p">}</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_temporal_ensemble_distributions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">,</span> <span class="n">wm</span><span class="p">,</span> <span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span><span class="p">):</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">nbr_data</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">knn_df</span> <span class="o">=</span> <span class="n">nbr_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">_NN_</span><span class="si">{</span><span class="n">distance_type</span><span class="si">}</span><span class="s1">_ID</span><span class="si">{</span><span class="n">wm</span><span class="si">}</span><span class="s1">_timeEnsemble&#39;</span>            
            <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_weights</span><span class="p">(</span><span class="n">wm</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">distances</span><span class="p">[:</span><span class="n">k</span><span class="p">])</span>
            <span class="n">temporal_ensemble_mean</span><span class="p">,</span> <span class="n">mean_valid_per_row</span><span class="p">,</span> <span class="n">effective_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_row_mean_ignore_nan</span><span class="p">(</span><span class="n">knn_df</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
            <span class="n">nbrs_used</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">knn_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_finalize_temporal_ensemble</span><span class="p">(</span>
                <span class="n">k</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">temporal_ensemble_mean</span><span class="p">,</span> <span class="n">nbrs_used</span><span class="p">,</span>
                <span class="n">effective_k</span><span class="p">,</span> <span class="n">mean_valid_per_row</span>
            <span class="p">)</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_distribution_estimates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">):</span>

        <span class="n">nbr_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbr_dfs</span><span class="p">[</span><span class="n">distance_type</span><span class="p">][</span><span class="s1">&#39;nbr_df&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">nbr_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbr_dfs</span><span class="p">[</span><span class="n">distance_type</span><span class="p">][</span><span class="s1">&#39;nbr_data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">wm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_schemes</span><span class="p">:</span>
            <span class="c1"># compute the FDC estimate by temporal ensemble mean</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_temporal_ensemble_distributions</span><span class="p">(</span><span class="n">distance_type</span><span class="p">,</span> <span class="n">wm</span><span class="p">,</span> <span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span><span class="p">)</span>
            <span class="c1"># compute the frequency average ensemble pdfs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_frequency_ensemble_distributions</span><span class="p">(</span><span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">)</span>

        <span class="c1"># Validation</span>
        <span class="n">sim_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">pdf_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">sim_labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">pdf_labels</span><span class="p">)</span>
        
    
    <span class="k">def</span><span class="w"> </span><span class="nf">run_estimators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">divergence_measures</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">baseline_pmf</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complete_target_years</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_complete_years</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">stn_df</span><span class="p">[[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">_uar&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                          
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_nearest_neighbour_data</span><span class="p">()</span>
        <span class="c1"># set the baseline pdf by kde</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_kde</span> <span class="o">=</span> <span class="n">KDEEstimator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;spatial_dist&#39;</span><span class="p">,</span> <span class="s1">&#39;attribute_dist&#39;</span><span class="p">]:</span>            
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_distribution_estimates</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_results</span><span class="p">()</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_make_json_serializable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;tolist&quot;</span><span class="p">):</span>
                <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">output</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_format_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pmf_labels</span><span class="p">,</span> <span class="n">pdf_labels</span><span class="p">,</span> <span class="n">sim_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># assert label sets are the same</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">pmf_labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">pdf_labels</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;pmf_labels </span><span class="si">{</span><span class="n">pmf_labels</span><span class="si">}</span><span class="s1"> != pdf_labels </span><span class="si">{</span><span class="n">pdf_labels</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">pmf_labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">sim_labels</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;pmf_labels </span><span class="si">{</span><span class="n">pmf_labels</span><span class="si">}</span><span class="s1"> != sim_labels </span><span class="si">{</span><span class="n">sim_labels</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">pmf_labels</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;prior&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">pmf_labels</span><span class="p">:</span>
            <span class="c1"># add the pmf and pdf in a json serializable format</span>
            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;pmf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;pdf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_json_serializable</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">results</span>
        
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="n">target_cols</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;mean_uar&#39;</span><span class="p">,</span> <span class="s1">&#39;sd_uar&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;mean_logx&#39;</span><span class="p">,</span> <span class="s1">&#39;sd_logx&#39;</span><span class="p">,</span> 
    <span class="c1"># &#39;uar_lmom_xi&#39;, &#39;uar_lmom_loc&#39;, &#39;uar_lmom_scale&#39;,</span>
    <span class="c1"># &#39;uar_skew&#39;, &#39;uar_kurt&#39;, </span>
    <span class="c1"># &#39;logx_skew&#39;, &#39;logx_kurt&#39;,</span>
    <span class="c1"># &#39;logx_lmom_xi&#39;, &#39;logx_lmom_loc&#39;, &#39;logx_lmom_scale&#39;,</span>
    <span class="c1"># &#39;prob_q_lessthan_0.0001&#39;, &#39;prob_q_lessthan_0.0005&#39;,</span>
    <span class="c1"># &#39;prob_q_lessthan_0.001&#39;, &#39;prob_q_lessthan_0.005&#39;, &#39;prob_q_lessthan_0.01&#39;</span>
<span class="p">]</span>

<span class="c1"># from utils import FDCEstimationContext</span>
<span class="n">attr_gdf_fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;BCUB_watershed_attributes_updated_</span><span class="si">{</span><span class="n">rev_date</span><span class="si">}</span><span class="s1">.geojson&#39;</span><span class="p">)</span>
<span class="n">LSTM_forcings_folder</span> <span class="o">=</span> <span class="s1">&#39;/home/danbot/neuralhydrology/data/BCUB_catchment_mean_met_forcings_20250320&#39;</span>
<span class="n">LSTM_ensemble_result_folder</span> <span class="o">=</span> <span class="s1">&#39;/home/danbot/code/neuralhydrology/data/ensemble_results&#39;</span>
<span class="n">parameter_prediction_results_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;parameter_prediction_results&#39;</span><span class="p">)</span>

<span class="n">methods</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;parametric&#39;</span><span class="p">,</span> <span class="s1">&#39;lstm&#39;</span><span class="p">,</span> <span class="s1">&#39;knn&#39;</span><span class="p">)</span>
<span class="c1"># methods = (&#39;knn&#39;,)</span>
<span class="n">exclude_pre_1980_data</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># use only stations with data 1980-present concurrent with Daymet</span>
<span class="n">daymet_start_date</span> <span class="o">=</span> <span class="s1">&#39;1950-01-01&#39;</span>  <span class="c1"># default start date for Daymet data</span>
<span class="n">k_nearest</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">if</span> <span class="n">exclude_pre_1980_data</span><span class="p">:</span>
    <span class="n">daymet_start_date</span> <span class="o">=</span> <span class="s1">&#39;1850-01-01&#39;</span>

<span class="n">processed</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">ESTIMATOR_CLASSES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;parametric&#39;</span><span class="p">:</span> <span class="n">ParametricFDCEstimator</span><span class="p">,</span>
    <span class="s1">&#39;lstm&#39;</span><span class="p">:</span> <span class="n">LSTMFDCEstimator</span><span class="p">,</span>
    <span class="s1">&#39;knn&#39;</span><span class="p">:</span> <span class="n">kNNFDCEstimator</span><span class="p">,</span>
    <span class="c1"># add others here</span>
<span class="p">}</span>
<span class="n">input_data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;attr_gdf_fpath&#39;</span><span class="p">:</span> <span class="n">attr_gdf_fpath</span><span class="p">,</span>
    <span class="s1">&#39;LSTM_forcings_folder&#39;</span><span class="p">:</span> <span class="n">LSTM_forcings_folder</span><span class="p">,</span>
    <span class="s1">&#39;LSTM_ensemble_result_folder&#39;</span><span class="p">:</span> <span class="n">LSTM_ensemble_result_folder</span><span class="p">,</span>
    <span class="s1">&#39;LSTM_concurrent_network&#39;</span><span class="p">:</span> <span class="n">exclude_pre_1980_data</span><span class="p">,</span>  <span class="c1"># use only stations with data 1980-present concurrent with Daymet</span>
    <span class="s1">&#39;daymet_start_date&#39;</span><span class="p">:</span> <span class="n">daymet_start_date</span><span class="p">,</span>
    <span class="s1">&#39;parameter_prediction_results_folder&#39;</span><span class="p">:</span> <span class="n">parameter_prediction_results_folder</span><span class="p">,</span>
    <span class="s1">&#39;predicted_param_dict&#39;</span><span class="p">:</span> <span class="n">predicted_param_dict</span><span class="p">,</span>
    <span class="s1">&#39;divergence_measures&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;DKL&#39;</span><span class="p">,</span> <span class="s1">&#39;EMD&#39;</span><span class="p">],</span>
    <span class="s1">&#39;eps&#39;</span><span class="p">:</span> <span class="mf">1e-12</span><span class="p">,</span>
    <span class="s1">&#39;min_flow&#39;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">,</span>
    <span class="s1">&#39;n_grid_points&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="mi">12</span><span class="p">,</span>
    <span class="s1">&#39;min_record_length&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="s1">&#39;minimum_days_per_month&#39;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
    <span class="s1">&#39;parametric_target_cols&#39;</span><span class="p">:</span> <span class="n">target_cols</span><span class="p">,</span>
    <span class="s1">&#39;all_official_ids&#39;</span><span class="p">:</span> <span class="n">station_ids</span><span class="p">,</span>
    <span class="s1">&#39;daymet_concurrent_stations&#39;</span><span class="p">:</span> <span class="n">daymet_concurrent_stations</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">FDCEstimationContext</span><span class="p">(</span><span class="o">**</span><span class="n">input_data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1729/723 catchments contain withdrawal licenses
723
Use only stations with minimum concurrency with Daymet / LSTM results: True (n=723)
    ...overlap dict loaded from data/record_overlap_dict.json
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">processed</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">stn</span> <span class="ow">in</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">official_ids</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">daymet_concurrent_stations</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">stn</span> <span class="o">==</span> <span class="s1">&#39;12414900&#39;</span><span class="p">:</span> <span class="c1"># this station has no data in the LSTM ensemble results</span>
        <span class="k">continue</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Estimating FDC for </span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">)</span>  
    <span class="n">runner</span> <span class="o">=</span> <span class="n">FDCEstimatorRunner</span><span class="p">(</span><span class="n">stn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">methods</span><span class="p">,</span> <span class="n">k_nearest</span><span class="p">,</span> <span class="n">target_cols</span><span class="p">,</span> <span class="n">ESTIMATOR_CLASSES</span><span class="p">)</span>
    <span class="n">runner</span><span class="o">.</span><span class="n">run_selected</span><span class="p">()</span>
    <span class="n">processed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="n">elapsed</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="n">unit_time</span> <span class="o">=</span> <span class="n">elapsed</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Processed </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">official_ids</span><span class="p">)</span><span class="si">}</span><span class="s1"> stations in </span><span class="si">{</span><span class="n">unit_time</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds per station&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Estimating FDC for 05AA008...
Estimating FDC for 05AA022...
Estimating FDC for 05AA023...
Estimating FDC for 05AA035...
Estimating FDC for 05AD003...
Estimating FDC for 05BA001...
Estimating FDC for 05BB001...
Estimating FDC for 05BF016...
Estimating FDC for 05BF017...
Estimating FDC for 05BF018...
Processed 10/723 stations in 0.00 seconds per station
Estimating FDC for 05BF019...
Estimating FDC for 05BG006...
Estimating FDC for 05BH015...
Estimating FDC for 05BJ004...
Estimating FDC for 05BJ010...
Estimating FDC for 05BL012...
Estimating FDC for 05BL014...
Estimating FDC for 05BL022...
Estimating FDC for 05CA009...
Estimating FDC for 05CB001...
Processed 20/723 stations in 0.00 seconds per station
Estimating FDC for 05CB004...
Estimating FDC for 05CC001...
Estimating FDC for 05CC007...
Estimating FDC for 05DA007...
Estimating FDC for 05DA009...
Estimating FDC for 05DA010...
Estimating FDC for 05DB002...
Estimating FDC for 05DB006...
Estimating FDC for 05DC006...
Estimating FDC for 05DC012...
Processed 30/723 stations in 0.00 seconds per station
Estimating FDC for 05DD009...
Estimating FDC for 07AA001...
Estimating FDC for 07AA002...
Estimating FDC for 07AD002...
Estimating FDC for 07AF002...
Estimating FDC for 07AG003...
Estimating FDC for 07AG007...
Estimating FDC for 07BB002...
Estimating FDC for 07BB003...
Estimating FDC for 07BC002...
Processed 40/723 stations in 0.00 seconds per station
Estimating FDC for 07EA002...
Estimating FDC for 07EA004...
Estimating FDC for 07EA005...
Estimating FDC for 07EA007...
Estimating FDC for 07EB002...
Estimating FDC for 07EC002...
Estimating FDC for 07EC003...
Estimating FDC for 07EC004...
Estimating FDC for 07ED001...
Estimating FDC for 07ED003...
Processed 50/723 stations in 0.00 seconds per station
Estimating FDC for 07EE007...
Estimating FDC for 07EE009...
Estimating FDC for 07EE010...
Estimating FDC for 07EF004...
Estimating FDC for 07FA003...
Estimating FDC for 07FA005...
Estimating FDC for 07FA006...
Estimating FDC for 07FB001...
Estimating FDC for 07FB002...
Estimating FDC for 07FB003...
Processed 60/723 stations in 0.00 seconds per station
Estimating FDC for 07FB004...
Estimating FDC for 07FB005...
Estimating FDC for 07FB006...
Estimating FDC for 07FB008...
Estimating FDC for 07FB009...
Estimating FDC for 07FC001...
Estimating FDC for 07FC003...
Estimating FDC for 07FD001...
Estimating FDC for 07FD004...
Estimating FDC for 07FD007...
Processed 70/723 stations in 0.00 seconds per station
Estimating FDC for 07GA001...
Estimating FDC for 07GA002...
Estimating FDC for 07GD001...
Estimating FDC for 07GD003...
Estimating FDC for 07GD004...
Estimating FDC for 07GE001...
Estimating FDC for 07GF001...
Estimating FDC for 07GG001...
Estimating FDC for 07GH002...
Estimating FDC for 07GJ001...
Processed 80/723 stations in 0.00 seconds per station
Estimating FDC for 07HA005...
Estimating FDC for 07HC001...
Estimating FDC for 07OC001...
Estimating FDC for 07UC001...
Estimating FDC for 08AA008...
Estimating FDC for 08AA009...
Estimating FDC for 08AB001...
Estimating FDC for 08AB002...
Estimating FDC for 08AC001...
Estimating FDC for 08AC002...
Processed 90/723 stations in 0.00 seconds per station
Estimating FDC for 08BB001...
Estimating FDC for 08BB005...
Estimating FDC for 08CA001...
Estimating FDC for 08CA002...
Estimating FDC for 08CA003...
Estimating FDC for 08CB001...
Estimating FDC for 08CC001...
Estimating FDC for 08CC002...
Estimating FDC for 08CC003...
Estimating FDC for 08CD001...
Processed 100/723 stations in 0.00 seconds per station
Estimating FDC for 08CE001...
Estimating FDC for 08CF001...
Estimating FDC for 08CF003...
Estimating FDC for 08CG001...
Estimating FDC for 08CG004...
Estimating FDC for 08CG005...
Estimating FDC for 08DA009...
Estimating FDC for 08DA010...
Estimating FDC for 08DB001...
Estimating FDC for 08DB010...
Processed 110/723 stations in 0.00 seconds per station
Estimating FDC for 08DB012...
Estimating FDC for 08DB013...
Estimating FDC for 08DB014...
Estimating FDC for 08DC006...
Estimating FDC for 08EB003...
Estimating FDC for 08EB004...
Estimating FDC for 08EB005...
Estimating FDC for 08EC001...
Estimating FDC for 08EC013...
Estimating FDC for 08ED001...
Processed 120/723 stations in 0.00 seconds per station
Estimating FDC for 08ED002...
Estimating FDC for 08EE003...
Estimating FDC for 08EE004...
Estimating FDC for 08EE005...
Estimating FDC for 08EE008...
Estimating FDC for 08EE012...
Estimating FDC for 08EE013...
Estimating FDC for 08EE020...
Estimating FDC for 08EE025...
Estimating FDC for 08EE028...
Processed 130/723 stations in 0.00 seconds per station
Estimating FDC for 08EF001...
Estimating FDC for 08EF005...
Estimating FDC for 08EG011...
Estimating FDC for 08EG012...
Estimating FDC for 08EG017...
Estimating FDC for 08FA002...
Estimating FDC for 08FB004...
Estimating FDC for 08FB005...
Estimating FDC for 08FB006...
Estimating FDC for 08FB007...
Processed 140/723 stations in 0.00 seconds per station
Estimating FDC for 08FC003...
Estimating FDC for 08FC005...
Estimating FDC for 08FE003...
Estimating FDC for 08FF001...
Estimating FDC for 08FF002...
Estimating FDC for 08FF003...
Estimating FDC for 08FF006...
Estimating FDC for 08GA061...
Estimating FDC for 08GA065...
Estimating FDC for 08GA071...
Processed 150/723 stations in 0.00 seconds per station
Estimating FDC for 08GA072...
Estimating FDC for 08GA075...
Estimating FDC for 08GA077...
Estimating FDC for 08GA079...
Estimating FDC for 08GB013...
Estimating FDC for 08GC008...
Estimating FDC for 08GD004...
Estimating FDC for 08GD005...
Estimating FDC for 08GD006...
Estimating FDC for 08GD007...
Processed 160/723 stations in 0.00 seconds per station
Estimating FDC for 08GD008...
Estimating FDC for 08GE002...
Estimating FDC for 08GE003...
Estimating FDC for 08GF006...
Estimating FDC for 08GF007...
Estimating FDC for 08HA001...
Estimating FDC for 08HA003...
Estimating FDC for 08HA010...
Estimating FDC for 08HA016...
Estimating FDC for 08HA026...
Processed 170/723 stations in 0.00 seconds per station
Estimating FDC for 08HA068...
Estimating FDC for 08HA069...
Estimating FDC for 08HA070...
Estimating FDC for 08HA072...
Estimating FDC for 08HB014...
Estimating FDC for 08HB032...
Estimating FDC for 08HB048...
Estimating FDC for 08HB069...
Estimating FDC for 08HB074...
Estimating FDC for 08HB075...
Processed 180/723 stations in 0.00 seconds per station
Estimating FDC for 08HB086...
Estimating FDC for 08HB089...
Estimating FDC for 08HC002...
Estimating FDC for 08HD011...
Estimating FDC for 08HD015...
Estimating FDC for 08HD016...
Estimating FDC for 08HD023...
Estimating FDC for 08HE008...
Estimating FDC for 08HE009...
Estimating FDC for 08HE010...
Processed 190/723 stations in 0.00 seconds per station
Estimating FDC for 08HF004...
Estimating FDC for 08HF005...
Estimating FDC for 08HF006...
Estimating FDC for 08HF007...
Estimating FDC for 08HF008...
Estimating FDC for 08HF012...
Estimating FDC for 08HF013...
Estimating FDC for 08JA014...
Estimating FDC for 08JB002...
Estimating FDC for 08JB003...
Processed 200/723 stations in 0.00 seconds per station
Estimating FDC for 08JB012...
Estimating FDC for 08JD006...
Estimating FDC for 08JE001...
Estimating FDC for 08JE004...
Estimating FDC for 08JE005...
Estimating FDC for 08KA001...
Estimating FDC for 08KA004...
Estimating FDC for 08KA005...
Estimating FDC for 08KA007...
Estimating FDC for 08KA008...
Processed 210/723 stations in 0.00 seconds per station
Estimating FDC for 08KA009...
Estimating FDC for 08KA013...
Estimating FDC for 08KB001...
Estimating FDC for 08KB003...
Estimating FDC for 08KB006...
Estimating FDC for 08KC001...
Estimating FDC for 08KC003...
Estimating FDC for 08KD001...
Estimating FDC for 08KD006...
Estimating FDC for 08KD007...
Processed 220/723 stations in 0.00 seconds per station
Estimating FDC for 08KE009...
Estimating FDC for 08KE016...
Estimating FDC for 08KE024...
Estimating FDC for 08KF001...
Estimating FDC for 08KG001...
Estimating FDC for 08KG003...
Estimating FDC for 08KH001...
Estimating FDC for 08KH003...
Estimating FDC for 08KH006...
Estimating FDC for 08KH010...
Processed 230/723 stations in 0.00 seconds per station
Estimating FDC for 08KH019...
Estimating FDC for 08KH022...
Estimating FDC for 08KH029...
Estimating FDC for 08KH030...
Estimating FDC for 08KH031...
Estimating FDC for 08LA001...
Estimating FDC for 08LA007...
Estimating FDC for 08LA008...
Estimating FDC for 08LA018...
Estimating FDC for 08LA027...
Processed 240/723 stations in 0.00 seconds per station
Estimating FDC for 08LA028...
Estimating FDC for 08LB020...
Estimating FDC for 08LB024...
Estimating FDC for 08LB038...
Estimating FDC for 08LB047...
Estimating FDC for 08LB064...
Estimating FDC for 08LB069...
Estimating FDC for 08LB076...
Estimating FDC for 08LC040...
Estimating FDC for 08LD001...
Processed 250/723 stations in 0.00 seconds per station
Estimating FDC for 08LE024...
Estimating FDC for 08LE027...
Estimating FDC for 08LE031...
Estimating FDC for 08LE075...
Estimating FDC for 08LE077...
Estimating FDC for 08LE094...
Estimating FDC for 08LE108...
Estimating FDC for 08LF051...
Estimating FDC for 08LF080...
Estimating FDC for 08LF081...
Processed 260/723 stations in 0.00 seconds per station
Estimating FDC for 08LF084...
Estimating FDC for 08LF099...
Estimating FDC for 08LF100...
Estimating FDC for 08LG008...
Estimating FDC for 08LG016...
Estimating FDC for 08LG048...
Estimating FDC for 08LG055...
Estimating FDC for 08LG056...
Estimating FDC for 08LG066...
Estimating FDC for 08LG068...
Processed 270/723 stations in 0.00 seconds per station
Estimating FDC for 08MA001...
Estimating FDC for 08MA002...
Estimating FDC for 08MA003...
Estimating FDC for 08MA006...
Estimating FDC for 08MB005...
Estimating FDC for 08MB006...
Estimating FDC for 08MB007...
Estimating FDC for 08MC045...
Estimating FDC for 08MD035...
Estimating FDC for 08ME023...
Processed 280/723 stations in 0.00 seconds per station
Estimating FDC for 08ME025...
Estimating FDC for 08ME027...
Estimating FDC for 08ME028...
Estimating FDC for 08MF062...
Estimating FDC for 08MF065...
Estimating FDC for 08MF068...
Estimating FDC for 08MG001...
Estimating FDC for 08MG005...
Estimating FDC for 08MG013...
Estimating FDC for 08MG026...
Processed 290/723 stations in 0.00 seconds per station
Estimating FDC for 08MH001...
Estimating FDC for 08MH006...
Estimating FDC for 08MH016...
Estimating FDC for 08MH018...
Estimating FDC for 08MH029...
Estimating FDC for 08MH056...
Estimating FDC for 08MH076...
Estimating FDC for 08MH103...
Estimating FDC for 08MH104...
Estimating FDC for 08MH141...
Processed 300/723 stations in 0.00 seconds per station
Estimating FDC for 08MH147...
Estimating FDC for 08MH155...
Estimating FDC for 08MH166...
Estimating FDC for 08NA002...
Estimating FDC for 08NA006...
Estimating FDC for 08NA012...
Estimating FDC for 08NB005...
Estimating FDC for 08NB012...
Estimating FDC for 08NB014...
Estimating FDC for 08NB016...
Processed 310/723 stations in 0.00 seconds per station
Estimating FDC for 08NB018...
Estimating FDC for 08NB019...
Estimating FDC for 08NC004...
Estimating FDC for 08ND012...
Estimating FDC for 08ND013...
Estimating FDC for 08ND018...
Estimating FDC for 08ND019...
Estimating FDC for 08NE006...
Estimating FDC for 08NE008...
Estimating FDC for 08NE021...
Processed 320/723 stations in 0.00 seconds per station
Estimating FDC for 08NE039...
Estimating FDC for 08NE074...
Estimating FDC for 08NE077...
Estimating FDC for 08NE087...
Estimating FDC for 08NE110...
Estimating FDC for 08NE114...
Estimating FDC for 08NF001...
Estimating FDC for 08NF002...
Estimating FDC for 08NG012...
Estimating FDC for 08NG046...
Processed 330/723 stations in 0.00 seconds per station
Estimating FDC for 08NG051...
Estimating FDC for 08NG065...
Estimating FDC for 08NG076...
Estimating FDC for 08NG077...
Estimating FDC for 08NG078...
Estimating FDC for 08NG086...
Estimating FDC for 08NH005...
Estimating FDC for 08NH006...
Estimating FDC for 08NH007...
Estimating FDC for 08NH016...
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># plot the measurement error:</span>
<span class="n">efig</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Estimated Measurement Error Model&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">x_axis_type</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">error_points</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1e-4</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e-1</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1e1</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">,</span> <span class="mf">1e3</span><span class="p">,</span> <span class="mf">1e4</span><span class="p">,</span> <span class="mf">1e5</span><span class="p">])</span>  <span class="c1">#  Reference flow points in m^3/s</span>
<span class="n">error_values</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>
<span class="n">efig</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">error_points</span><span class="p">,</span> <span class="n">error_values</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;Measurement Error Model&#39;</span><span class="p">)</span>
<span class="n">efig</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$$\text{Flow } m^3/s$$&#39;</span>
<span class="n">efig</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$$\text{Error } [\text</span><span class="si">{x}</span><span class="s1">100\%]$$&#39;</span>
<span class="n">efig</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">background_fill_alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">efig</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">format_fig_fonts</span><span class="p">(</span><span class="n">efig</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">layout</span> <span class="o">=</span> <span class="n">gridplot</span><span class="p">([</span><span class="n">efig</span><span class="p">],</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">350</span><span class="p">)</span>
<span class="n">show</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notebooks/ss"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Non-Parametric Simulation</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#time-based-ensemble">Time-based ensemble</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#frequency-based-ensembles">Frequency-based ensembles</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#notes-on-k-nearest-neighbours">Notes on k-nearest neighbours</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#summary-set-theoretic-foundations-of-strict-k-nn-concurrency-selection">Summary: Set-Theoretic Foundations of Strict k-NN Concurrency Selection</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#set-theoretic-definition">Set-Theoretic Definition</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#related-concepts">Related Concepts</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#practical-implication">Practical Implication</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#define-a-universal-parametric-prior">Define a universal parametric prior</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#global-uniform-prior">Global Uniform Prior</a></li>
</ul>
</li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Dan Kovacek
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>