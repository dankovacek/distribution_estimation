
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Global Uniform Prior &#8212; Streamflow distribution estimation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/ss/Process_baseline_PDFs';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="Streamflow distribution estimation - Home"/>
    <script>document.write(`<img src="../../_static/logo.png" class="logo__image only-dark" alt="Streamflow distribution estimation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Introduction
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../1_data.html">Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2_Methods.html">Methods</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/dankovacek/divergence_estimation" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/dankovacek/divergence_estimation/issues/new?title=Issue%20on%20page%20%2Fnotebooks/ss/Process_baseline_PDFs.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/notebooks/ss/Process_baseline_PDFs.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Global Uniform Prior</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#kernel-density-estimator-in-1d">Kernel Density Estimator in 1D</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">time</span><span class="w"> </span><span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">cKDTree</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">xgboost</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xgb</span>
<span class="n">xgb</span><span class="o">.</span><span class="n">config_context</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">wasserstein_distance</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">laplace</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">bokeh.plotting</span><span class="w"> </span><span class="kn">import</span> <span class="n">figure</span><span class="p">,</span> <span class="n">show</span><span class="p">,</span> <span class="n">save</span><span class="p">,</span> <span class="n">output_file</span>
<span class="c1"># from bokeh.io import output_notebook</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bokeh.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearColorMapper</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">jax</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">jax.numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">jnp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">jax</span><span class="w"> </span><span class="kn">import</span> <span class="n">jit</span>

<span class="c1"># from KDEpy import FFTKDE</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">data_processing_functions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dpf</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">concurrent.futures</span><span class="w"> </span><span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">kde_estimator</span><span class="w"> </span><span class="kn">import</span> <span class="n">KDEEstimator</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="n">BASE_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ModuleNotFoundError</span><span class="g g-Whitespace">                       </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">line</span> <span class="mi">32</span>
<span class="g g-Whitespace">     </span><span class="mi">28</span> <span class="kn">import</span><span class="w"> </span><span class="nn">data_processing_functions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dpf</span>
<span class="g g-Whitespace">     </span><span class="mi">30</span> <span class="kn">from</span><span class="w"> </span><span class="nn">concurrent.futures</span><span class="w"> </span><span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>
<span class="ne">---&gt; </span><span class="mi">32</span> <span class="kn">from</span><span class="w"> </span><span class="nn">kde_estimator</span><span class="w"> </span><span class="kn">import</span> <span class="n">KDEEstimator</span>
<span class="g g-Whitespace">     </span><span class="mi">34</span> <span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="g g-Whitespace">     </span><span class="mi">35</span> <span class="n">BASE_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>

<span class="ne">ModuleNotFoundError</span>: No module named &#39;kde_estimator&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">bokeh.plotting</span><span class="w"> </span><span class="kn">import</span> <span class="n">figure</span><span class="p">,</span> <span class="n">show</span><span class="p">,</span> <span class="n">output_notebook</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bokeh.layouts</span><span class="w"> </span><span class="kn">import</span> <span class="n">gridplot</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">xyzservices.providers</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xyz</span>
<span class="n">tiles</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;USGS&#39;</span><span class="p">][</span><span class="s1">&#39;USTopo&#39;</span><span class="p">]</span>
<span class="n">output_notebook</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">    <style>
        .bk-notebook-logo {
            display: block;
            width: 20px;
            height: 20px;
            background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAOkSURBVDiNjZRtaJVlGMd/1/08zzln5zjP1LWcU9N0NkN8m2CYjpgQYQXqSs0I84OLIC0hkEKoPtiH3gmKoiJDU7QpLgoLjLIQCpEsNJ1vqUOdO7ppbuec5+V+rj4ctwzd8IIbbi6u+8f1539dt3A78eXC7QizUF7gyV1fD1Yqg4JWz84yffhm0qkFqBogB9rM8tZdtwVsPUhWhGcFJngGeWrPzHm5oaMmkfEg1usvLFyc8jLRqDOMru7AyC8saQr7GG7f5fvDeH7Ej8CM66nIF+8yngt6HWaKh7k49Soy9nXurCi1o3qUbS3zWfrYeQDTB/Qj6kX6Ybhw4B+bOYoLKCC9H3Nu/leUTZ1JdRWkkn2ldcCamzrcf47KKXdAJllSlxAOkRgyHsGC/zRday5Qld9DyoM4/q/rUoy/CXh3jzOu3bHUVZeU+DEn8FInkPBFlu3+nW3Nw0mk6vCDiWg8CeJaxEwuHS3+z5RgY+YBR6V1Z1nxSOfoaPa4LASWxxdNp+VWTk7+4vzaou8v8PN+xo+KY2xsw6une2frhw05CTYOmQvsEhjhWjn0bmXPjpE1+kplmmkP3suftwTubK9Vq22qKmrBhpY4jvd5afdRA3wGjFAgcnTK2s4hY0/GPNIb0nErGMCRxWOOX64Z8RAC4oCXdklmEvcL8o0BfkNK4lUg9HTl+oPlQxdNo3Mg4Nv175e/1LDGzZen30MEjRUtmXSfiTVu1kK8W4txyV6BMKlbgk3lMwYCiusNy9fVfvvwMxv8Ynl6vxoByANLTWplvuj/nF9m2+PDtt1eiHPBr1oIfhCChQMBw6Aw0UulqTKZdfVvfG7VcfIqLG9bcldL/+pdWTLxLUy8Qq38heUIjh4XlzZxzQm19lLFlr8vdQ97rjZVOLf8nclzckbcD4wxXMidpX30sFd37Fv/GtwwhzhxGVAprjbg0gCAEeIgwCZyTV2Z1REEW8O4py0wsjeloKoMr6iCY6dP92H6Vw/oTyICIthibxjm/DfN9lVz8IqtqKYLUXfoKVMVQVVJOElGjrnnUt9T9wbgp8AyYKaGlqingHZU/uG2NTZSVqwHQTWkx9hxjkpWDaCg6Ckj5qebgBVbT3V3NNXMSiWSDdGV3hrtzla7J+duwPOToIg42ChPQOQjspnSlp1V+Gjdged7+8UN5CRAV7a5EdFNwCjEaBR27b3W890TE7g24NAP/mMDXRWrGoFPQI9ls/MWO2dWFAar/xcOIImbbpA3zgAAAABJRU5ErkJggg==);
        }
    </style>
    <div>
        <a href="https://bokeh.org" target="_blank" class="bk-notebook-logo"></a>
        <span id="cae9773a-f727-4880-8f1c-ac158f5f797c">Loading BokehJS ...</span>
    </div>
</div><script type="application/javascript">'use strict';
(function(root) {
  function now() {
    return new Date();
  }

  const force = true;

  if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
    root._bokeh_onload_callbacks = [];
    root._bokeh_is_loading = undefined;
  }

const JS_MIME_TYPE = 'application/javascript';
  const HTML_MIME_TYPE = 'text/html';
  const EXEC_MIME_TYPE = 'application/vnd.bokehjs_exec.v0+json';
  const CLASS_NAME = 'output_bokeh rendered_html';

  /**
   * Render data to the DOM node
   */
  function render(props, node) {
    const script = document.createElement("script");
    node.appendChild(script);
  }

  /**
   * Handle when an output is cleared or removed
   */
  function handleClearOutput(event, handle) {
    function drop(id) {
      const view = Bokeh.index.get_by_id(id)
      if (view != null) {
        view.model.document.clear()
        Bokeh.index.delete(view)
      }
    }

    const cell = handle.cell;

    const id = cell.output_area._bokeh_element_id;
    const server_id = cell.output_area._bokeh_server_id;

    // Clean up Bokeh references
    if (id != null) {
      drop(id)
    }

    if (server_id !== undefined) {
      // Clean up Bokeh references
      const cmd_clean = "from bokeh.io.state import curstate; print(curstate().uuid_to_server['" + server_id + "'].get_sessions()[0].document.roots[0]._id)";
      cell.notebook.kernel.execute(cmd_clean, {
        iopub: {
          output: function(msg) {
            const id = msg.content.text.trim()
            drop(id)
          }
        }
      });
      // Destroy server and session
      const cmd_destroy = "import bokeh.io.notebook as ion; ion.destroy_server('" + server_id + "')";
      cell.notebook.kernel.execute(cmd_destroy);
    }
  }

  /**
   * Handle when a new output is added
   */
  function handleAddOutput(event, handle) {
    const output_area = handle.output_area;
    const output = handle.output;

    // limit handleAddOutput to display_data with EXEC_MIME_TYPE content only
    if ((output.output_type != "display_data") || (!Object.prototype.hasOwnProperty.call(output.data, EXEC_MIME_TYPE))) {
      return
    }

    const toinsert = output_area.element.find("." + CLASS_NAME.split(' ')[0]);

    if (output.metadata[EXEC_MIME_TYPE]["id"] !== undefined) {
      toinsert[toinsert.length - 1].firstChild.textContent = output.data[JS_MIME_TYPE];
      // store reference to embed id on output_area
      output_area._bokeh_element_id = output.metadata[EXEC_MIME_TYPE]["id"];
    }
    if (output.metadata[EXEC_MIME_TYPE]["server_id"] !== undefined) {
      const bk_div = document.createElement("div");
      bk_div.innerHTML = output.data[HTML_MIME_TYPE];
      const script_attrs = bk_div.children[0].attributes;
      for (let i = 0; i < script_attrs.length; i++) {
        toinsert[toinsert.length - 1].firstChild.setAttribute(script_attrs[i].name, script_attrs[i].value);
        toinsert[toinsert.length - 1].firstChild.textContent = bk_div.children[0].textContent
      }
      // store reference to server id on output_area
      output_area._bokeh_server_id = output.metadata[EXEC_MIME_TYPE]["server_id"];
    }
  }

  function register_renderer(events, OutputArea) {

    function append_mime(data, metadata, element) {
      // create a DOM node to render to
      const toinsert = this.create_output_subarea(
        metadata,
        CLASS_NAME,
        EXEC_MIME_TYPE
      );
      this.keyboard_manager.register_events(toinsert);
      // Render to node
      const props = {data: data, metadata: metadata[EXEC_MIME_TYPE]};
      render(props, toinsert[toinsert.length - 1]);
      element.append(toinsert);
      return toinsert
    }

    /* Handle when an output is cleared or removed */
    events.on('clear_output.CodeCell', handleClearOutput);
    events.on('delete.Cell', handleClearOutput);

    /* Handle when a new output is added */
    events.on('output_added.OutputArea', handleAddOutput);

    /**
     * Register the mime type and append_mime function with output_area
     */
    OutputArea.prototype.register_mime_type(EXEC_MIME_TYPE, append_mime, {
      /* Is output safe? */
      safe: true,
      /* Index of renderer in `output_area.display_order` */
      index: 0
    });
  }

  // register the mime type if in Jupyter Notebook environment and previously unregistered
  if (root.Jupyter !== undefined) {
    const events = require('base/js/events');
    const OutputArea = require('notebook/js/outputarea').OutputArea;

    if (OutputArea.prototype.mime_types().indexOf(EXEC_MIME_TYPE) == -1) {
      register_renderer(events, OutputArea);
    }
  }
  if (typeof (root._bokeh_timeout) === "undefined" || force === true) {
    root._bokeh_timeout = Date.now() + 5000;
    root._bokeh_failed_load = false;
  }

  const NB_LOAD_WARNING = {'data': {'text/html':
     "<div style='background-color: #fdd'>\n"+
     "<p>\n"+
     "BokehJS does not appear to have successfully loaded. If loading BokehJS from CDN, this \n"+
     "may be due to a slow or bad network connection. Possible fixes:\n"+
     "</p>\n"+
     "<ul>\n"+
     "<li>re-rerun `output_notebook()` to attempt to load from CDN again, or</li>\n"+
     "<li>use INLINE resources instead, as so:</li>\n"+
     "</ul>\n"+
     "<code>\n"+
     "from bokeh.resources import INLINE\n"+
     "output_notebook(resources=INLINE)\n"+
     "</code>\n"+
     "</div>"}};

  function display_loaded(error = null) {
    const el = document.getElementById("cae9773a-f727-4880-8f1c-ac158f5f797c");
    if (el != null) {
      const html = (() => {
        if (typeof root.Bokeh === "undefined") {
          if (error == null) {
            return "BokehJS is loading ...";
          } else {
            return "BokehJS failed to load.";
          }
        } else {
          const prefix = `BokehJS ${root.Bokeh.version}`;
          if (error == null) {
            return `${prefix} successfully loaded.`;
          } else {
            return `${prefix} <b>encountered errors</b> while loading and may not function as expected.`;
          }
        }
      })();
      el.innerHTML = html;

      if (error != null) {
        const wrapper = document.createElement("div");
        wrapper.style.overflow = "auto";
        wrapper.style.height = "5em";
        wrapper.style.resize = "vertical";
        const content = document.createElement("div");
        content.style.fontFamily = "monospace";
        content.style.whiteSpace = "pre-wrap";
        content.style.backgroundColor = "rgb(255, 221, 221)";
        content.textContent = error.stack ?? error.toString();
        wrapper.append(content);
        el.append(wrapper);
      }
    } else if (Date.now() < root._bokeh_timeout) {
      setTimeout(() => display_loaded(error), 100);
    }
  }

  function run_callbacks() {
    try {
      root._bokeh_onload_callbacks.forEach(function(callback) {
        if (callback != null)
          callback();
      });
    } finally {
      delete root._bokeh_onload_callbacks
    }
    console.debug("Bokeh: all callbacks have finished");
  }

  function load_libs(css_urls, js_urls, callback) {
    if (css_urls == null) css_urls = [];
    if (js_urls == null) js_urls = [];

    root._bokeh_onload_callbacks.push(callback);
    if (root._bokeh_is_loading > 0) {
      console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
      return null;
    }
    if (js_urls == null || js_urls.length === 0) {
      run_callbacks();
      return null;
    }
    console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
    root._bokeh_is_loading = css_urls.length + js_urls.length;

    function on_load() {
      root._bokeh_is_loading--;
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
        run_callbacks()
      }
    }

    function on_error(url) {
      console.error("failed to load " + url);
    }

    for (let i = 0; i < css_urls.length; i++) {
      const url = css_urls[i];
      const element = document.createElement("link");
      element.onload = on_load;
      element.onerror = on_error.bind(null, url);
      element.rel = "stylesheet";
      element.type = "text/css";
      element.href = url;
      console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
      document.body.appendChild(element);
    }

    for (let i = 0; i < js_urls.length; i++) {
      const url = js_urls[i];
      const element = document.createElement('script');
      element.onload = on_load;
      element.onerror = on_error.bind(null, url);
      element.async = false;
      element.src = url;
      console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
      document.head.appendChild(element);
    }
  };

  function inject_raw_css(css) {
    const element = document.createElement("style");
    element.appendChild(document.createTextNode(css));
    document.body.appendChild(element);
  }

  const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.7.2.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.7.2.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.7.2.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.7.2.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.7.2.min.js"];
  const css_urls = [];

  const inline_js = [    function(Bokeh) {
      Bokeh.set_log_level("info");
    },
function(Bokeh) {
    }
  ];

  function run_inline_js() {
    if (root.Bokeh !== undefined || force === true) {
      try {
            for (let i = 0; i < inline_js.length; i++) {
      inline_js[i].call(root, root.Bokeh);
    }

      } catch (error) {display_loaded(error);throw error;
      }if (force === true) {
        display_loaded();
      }} else if (Date.now() < root._bokeh_timeout) {
      setTimeout(run_inline_js, 100);
    } else if (!root._bokeh_failed_load) {
      console.log("Bokeh: BokehJS failed to load within specified timeout.");
      root._bokeh_failed_load = true;
    } else if (force !== true) {
      const cell = $(document.getElementById("cae9773a-f727-4880-8f1c-ac158f5f797c")).parents('.cell').data().cell;
      cell.output_area.append_execute_result(NB_LOAD_WARNING)
    }
  }

  if (root._bokeh_is_loading === 0) {
    console.debug("Bokeh: BokehJS loaded, going straight to plotting");
    run_inline_js();
  } else {
    load_libs(css_urls, js_urls, function() {
      console.debug("Bokeh: BokehJS plotting callback run at", now());
      run_inline_js();
    });
  }
}(window));</script></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># load the catchment characteristics</span>
<span class="n">rev_date</span> <span class="o">=</span> <span class="s1">&#39;20250227&#39;</span>
<span class="n">fname</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;BCUB_watershed_attributes_updated_</span><span class="si">{</span><span class="n">rev_date</span><span class="si">}</span><span class="s1">.csv&#39;</span>
<span class="n">attr_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">fname</span><span class="p">))</span>
<span class="n">attr_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">attr_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
<span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;log_drainage_area_km2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;drainage_area_km2&#39;</span><span class="p">])</span>
<span class="c1"># attr_df = attr_df[~attr_df[&#39;official_id&#39;].isin(exclude)]</span>
<span class="c1"># attr_df.columns = [c.lower() for c in attr_df.columns]</span>
<span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;tmean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;tmin&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;tmax&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
<span class="n">station_ids</span> <span class="o">=</span> <span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">station_ids</span><span class="p">)</span><span class="si">}</span><span class="s1"> monitored basins in the attribute set.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>There are 1308 monitored basins in the attribute set.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># streamflow folder from (updated) HYSETS</span>
<span class="n">HYSETS_DIR</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;/home/danbot2/code_5820/large_sample_hydrology/common_data/HYSETS_data&#39;</span><span class="p">)</span>
<span class="n">STREAMFLOW_DIR</span> <span class="o">=</span> <span class="n">HYSETS_DIR</span> <span class="o">/</span> <span class="s1">&#39;streamflow&#39;</span>

<span class="n">hs_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">HYSETS_DIR</span> <span class="o">/</span> <span class="s1">&#39;HYSETS_watershed_properties.txt&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">)</span>
<span class="n">hs_df</span> <span class="o">=</span> <span class="n">hs_df</span><span class="p">[</span><span class="n">hs_df</span><span class="p">[</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">station_ids</span><span class="p">)]</span>
<span class="n">hs_df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Watershed_ID</th>
      <th>Source</th>
      <th>Name</th>
      <th>Official_ID</th>
      <th>Centroid_Lat_deg_N</th>
      <th>Centroid_Lon_deg_E</th>
      <th>Drainage_Area_km2</th>
      <th>Drainage_Area_GSIM_km2</th>
      <th>Flag_GSIM_boundaries</th>
      <th>Flag_Artificial_Boundaries</th>
      <th>...</th>
      <th>Land_Use_Wetland_frac</th>
      <th>Land_Use_Water_frac</th>
      <th>Land_Use_Urban_frac</th>
      <th>Land_Use_Shrubs_frac</th>
      <th>Land_Use_Crops_frac</th>
      <th>Land_Use_Snow_Ice_frac</th>
      <th>Flag_Land_Use_Extraction</th>
      <th>Permeability_logk_m2</th>
      <th>Porosity_frac</th>
      <th>Flag_Subsoil_Extraction</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>846</th>
      <td>847</td>
      <td>HYDAT</td>
      <td>CROWSNEST RIVER AT FRANK</td>
      <td>05AA008</td>
      <td>49.59732</td>
      <td>-114.4106</td>
      <td>402.6522</td>
      <td>NaN</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0.0103</td>
      <td>0.0065</td>
      <td>0.0328</td>
      <td>0.0785</td>
      <td>0.0015</td>
      <td>0.0002</td>
      <td>1</td>
      <td>-15.543306</td>
      <td>0.170479</td>
      <td>1</td>
    </tr>
    <tr>
      <th>849</th>
      <td>850</td>
      <td>HYDAT</td>
      <td>CASTLE RIVER NEAR BEAVER MINES</td>
      <td>05AA022</td>
      <td>49.48866</td>
      <td>-114.1444</td>
      <td>820.6510</td>
      <td>NaN</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0.0058</td>
      <td>0.0023</td>
      <td>0.0105</td>
      <td>0.1156</td>
      <td>0.0246</td>
      <td>0.0000</td>
      <td>1</td>
      <td>-15.929747</td>
      <td>0.150196</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>2 rows × 29 columns</p>
</div></div></div>
</div>
<section id="global-uniform-prior">
<h1>Global Uniform Prior<a class="headerlink" href="#global-uniform-prior" title="Link to this heading">#</a></h1>
<div class="math notranslate nohighlight">
\[f(x) = \frac{1}{b-a}, \quad x\in (a, b) \text{ and } f(x) = 0 \text{ otherwise.}\]</div>
<div class="math notranslate nohighlight">
\[\int_a^b f(x)\text{dx} = 1\]</div>
<p>Given the target range is a sub interval <span class="math notranslate nohighlight">\((c, d) \subseteq (a, b)\)</span>, then the <strong>total</strong> prior probability mass over (c, d) is:</p>
<div class="math notranslate nohighlight">
\[M_\text{target} = \int_c^d \frac{1}{b-a}\text{dx} = \frac{d-c}{b-a}\]</div>
<p>Over the set of intervals <span class="math notranslate nohighlight">\(\Delta x_i\)</span> covering the <strong>target range</strong>, the probability mass associated with each interval (bin) is given by:</p>
<div class="math notranslate nohighlight">
\[\Delta x_i \frac{d-c}{b-a}\]</div>
<p>A desirable property of the prior is that it reflects the strength of belief in the model (data), where a smaller prior reflects stronger belief in the data/model and vice versa.  Dividing by the number of observations has such an effect, however it also makes for very small priors.  The consequence of very small priors is they have negligible effect on models that provide complete support coverage, and they severely penalize models that do not, resulting in a form of instability.  The very small prior creates a heavy tail in the distribution of a large sample of KL divergences, with further downstream effects in optimization.</p>
<p>A method that uses a prior with negligible effect on a model with complete support coverage and a very big effect on one without can be interpreted in a few ways:</p>
<ol class="arabic simple">
<li><p>Incomplete support coverage, or underspecification, is very heavily penalized.  The method does not tolerate a model that cannot predict the full observed range.</p></li>
<li><p>A <strong>proper</strong> probability distribution sums (discrete) or integrates (continuous) to 1.  Very small probabilities are in a sense associated with a high degree of certainty since they reflect the expectation of the system being observed in a particular state.</p></li>
<li><p>The penalty of underestimating a state frequency is that storing and transmitting information about the state requires (the log ratio) more bandwidth/disk space because it is assigned a longer bit string than the actual frequency calls for under optimal encoding.</p></li>
<li><p>Assigning a very small probability to a state …</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_overlap_matrix</span><span class="p">(</span><span class="n">mask_jax</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">mask_jax</span><span class="p">,</span> <span class="n">mask_jax</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FDCEstimationContext</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_load_catchment_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_and_filter_hysets_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LN_param_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ln_params</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_to_idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_to_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_tree_idx_mappers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_network_trees</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_attribute_indexers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_concurrent_overlap_dict</span><span class="p">()</span>
        
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_load_and_filter_hysets_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">hs_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">HYSETS_DIR</span> <span class="o">/</span> <span class="s1">&#39;HYSETS_watershed_properties.txt&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">)</span>
        
        <span class="n">hs_df</span> <span class="o">=</span> <span class="n">hs_df</span><span class="p">[</span><span class="n">hs_df</span><span class="p">[</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">study_ids</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_start_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="s1">&#39;1950-01-01&#39;</span><span class="p">)</span> <span class="c1"># Hysets streamflow starts 1950-01-01</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hs_df</span> <span class="o">=</span> <span class="n">hs_df</span>
        <span class="c1"># load the updated HYSETS data</span>

        <span class="n">updated_filename</span> <span class="o">=</span> <span class="s1">&#39;HYSETS_2023_update_QC_stations.nc&#39;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">HYSETS_DIR</span> <span class="o">/</span> <span class="n">updated_filename</span><span class="p">)</span>

        <span class="c1"># Get valid IDs as a NumPy array</span>
        <span class="n">selected_ids</span> <span class="o">=</span> <span class="n">hs_df</span><span class="p">[</span><span class="s1">&#39;Watershed_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># Get boolean index where watershedID in selected_set</span>
        <span class="c1"># safely access watershedID as a variable first</span>
        <span class="n">ws_ids</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;watershedID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># or .values if you prefer</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">ws_ids</span><span class="p">,</span> <span class="n">selected_ids</span><span class="p">)</span>

        <span class="c1"># Apply mask to data</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">watershed</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="c1"># Step 1: Promote &#39;watershedID&#39; to a coordinate on the &#39;watershed&#39; dimension</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">watershedID</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;watershed&quot;</span><span class="p">,</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;watershedID&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

        <span class="c1"># filter the timeseries by the global start date</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_start_date</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="c1"># Step 2: Set &#39;watershedID&#39; as the index for the &#39;watershed&#39; dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">watershed</span><span class="o">=</span><span class="s2">&quot;watershedID&quot;</span><span class="p">)</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_load_catchment_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf_fpath</span><span class="p">)</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">study_ids</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        
        <span class="c1"># import the license water extraction points</span>
        <span class="n">dam_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;data/Dam_Points_20240103.gpkg&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="n">dam_gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="s2">&quot;CRS of catchment and dam dataframes do not match&quot;</span>
        <span class="n">joined</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">dam_gdf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;contains&quot;</span><span class="p">)</span>
        <span class="n">joined</span> <span class="o">=</span> <span class="n">joined</span><span class="p">[</span><span class="n">joined</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">study_ids</span><span class="p">)]</span>
        <span class="c1"># Create a new boolean column &#39;contains_dam&#39; in catchment_gdf.</span>
        <span class="c1"># If a polygon&#39;s index appears in the joined result, it means it contains at least one point.</span>
        <span class="n">regulated</span> <span class="o">=</span> <span class="n">joined</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">regulated</span><span class="p">)</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s1"> catchments contain withdrawal licenses&#39;</span><span class="p">)</span>
                
        <span class="c1"># create dict structures for easier access of attributes and geometries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">da_dict</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[[</span><span class="s1">&#39;official_id&#39;</span><span class="p">,</span> <span class="s1">&#39;drainage_area_km2&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;official_id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()[</span><span class="s1">&#39;drainage_area_km2&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polygon_dict</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[[</span><span class="s1">&#39;official_id&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;official_id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
        
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_dict</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">centroid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">attr_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">centroids</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
        <span class="n">attr_gdf</span><span class="p">[</span><span class="s2">&quot;contains_dam&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr_gdf</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">regulated</span><span class="p">)</span>
        <span class="n">attr_gdf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf</span> <span class="o">=</span> <span class="n">attr_gdf</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_build_network_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute_cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;log_drainage_area_km2&#39;</span><span class="p">,</span> <span class="s1">&#39;elevation_m&#39;</span><span class="p">,</span> <span class="s1">&#39;prcp&#39;</span><span class="p">,</span> <span class="s1">&#39;tmean&#39;</span><span class="p">,</span> <span class="s1">&#39;swe&#39;</span><span class="p">,</span> <span class="s1">&#39;srad&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;centroid_lon_deg_e&#39;</span><span class="p">,</span> <span class="s1">&#39;centroid_lat_deg_n&#39;</span><span class="p">,</span> <span class="s1">&#39;land_use_forest_frac_2010&#39;</span><span class="p">,</span> <span class="s1">&#39;land_use_snow_ice_frac_2010&#39;</span><span class="p">,</span>
                            <span class="c1">#  , &#39;land_use_wetland_frac_2010&#39;, &#39;land_use_water_frac_2010&#39;, </span>
                            <span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">geom</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">geom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

        <span class="c1"># Create mapping from official_id to index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_to_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">oid</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">oid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf</span><span class="p">[</span><span class="s2">&quot;official_id&quot;</span><span class="p">])}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_to_id</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">oid</span> <span class="k">for</span> <span class="n">oid</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_to_index</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>  <span class="c1"># Reverse mapping</span>

        <span class="c1"># Extract values (excluding &#39;official_id&#39; since it&#39;s categorical)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf</span><span class="p">[</span><span class="s1">&#39;tmean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf</span><span class="p">[</span><span class="s1">&#39;tmin&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf</span><span class="p">[</span><span class="s1">&#39;tmax&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf</span><span class="p">[</span><span class="s1">&#39;log_drainage_area_km2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf</span><span class="p">[</span><span class="s1">&#39;drainage_area_km2&#39;</span><span class="p">])</span>
        <span class="n">attr_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf</span><span class="p">[</span><span class="n">attribute_cols</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalized_attr_values</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">attr_values</span><span class="p">)</span>
        <span class="c1"># Construct the KDTree for the attribute space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attribute_tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normalized_attr_values</span><span class="p">)</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_set_tree_idx_mappers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the index mappers for the official_id to index and vice versa.</span>
<span class="sd">        This is for the network TREES&quot;&quot;&quot;</span>
        <span class="n">id_to_idx</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)}</span>
        <span class="n">idx_to_id</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="nb">id</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)}</span>

        <span class="k">return</span> <span class="n">id_to_idx</span><span class="p">,</span> <span class="n">idx_to_id</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_attribute_indexers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># map keys to their </span>
        <span class="c1"># overlap_dict[1].keys()</span>
        <span class="c1"># create a dictionary where the keys are Watershed_ID and the values are Official_ID</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">watershed_id_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;Watershed_ID&#39;</span><span class="p">]:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hs_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()}</span>
        <span class="c1"># and the inverse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">official_id_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">]:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Watershed_ID&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hs_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()}</span>
        <span class="c1"># also for drainage areas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">da_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">]:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Drainage_Area_km2&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hs_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()}</span>
        

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_ln_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve log-normal parameters for a station.&quot;&quot;&quot;</span>
        <span class="n">target_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mean_uar&#39;</span><span class="p">,</span> <span class="s1">&#39;sd_uar&#39;</span><span class="p">,</span> <span class="s1">&#39;mean_logx&#39;</span><span class="p">,</span> <span class="s1">&#39;sd_logx&#39;</span><span class="p">]</span>

        <span class="n">predicted_param_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">target_columns</span><span class="p">:</span>
            <span class="n">fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_prediction_results_folder</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;best_out_of_sample_</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">_predictions.csv&#39;</span><span class="p">)</span>
            <span class="n">rdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="s1">&#39;official_id&#39;</span><span class="p">)</span>
            <span class="n">rdf</span> <span class="o">=</span> <span class="n">rdf</span><span class="p">[[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">rdf</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Unnamed:&#39;</span><span class="p">)]]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;official_id&#39;</span><span class="p">)</span>
            <span class="n">predicted_param_dict</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdf</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">predicted_param_dict</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_12_month_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">months</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">index</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;MS&#39;</span><span class="p">)</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">months</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span> <span class="o">-</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">months</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">windows</span> <span class="k">if</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">index</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_is_window_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">window</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">grouped</span> <span class="o">=</span> <span class="n">window</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">month</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">grouped</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">grouped</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_station_valid_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">windows</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_window_valid</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">]</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_count_valid_shared_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">valid_i</span><span class="p">,</span> <span class="n">valid_j</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">valid_i</span><span class="p">,</span> <span class="n">valid_j</span><span class="p">))</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_concurrent_overlap_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="s1">&#39;discharge&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the concurrent overlap of monitored watersheds in the dataset.</span>
<span class="sd">        Threshold years represent the minimum number of days of overlap </span>
<span class="sd">        (ignoring continuity) for a watershed to be considered concurrent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overlap_dict_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;record_overlap_dict.json&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">overlap_dict_file</span><span class="p">):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">overlap_dict_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">overlap_dict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    ...overlap dict loaded from </span><span class="si">{</span><span class="n">overlap_dict_file</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">overlap_dict</span>
        
        <span class="n">watershed_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="s1">&#39;watershed&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">load</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># (N, T)</span>
        <span class="n">threshold_years</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_concurrent_years</span>

        <span class="c1"># Compute mask on GPU</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span> <span class="c1"># </span>
        <span class="n">O</span> <span class="o">=</span> <span class="n">compute_overlap_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># number of sites</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># number of time steps</span>
        <span class="n">connectivity_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">O</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Connectivity factor: </span><span class="si">{</span><span class="n">connectivity_factor</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Build output</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">watershed_ids</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    ...building overlap dict for N=</span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s1"> monitored watersheds in the network.&#39;</span><span class="p">)</span>
        <span class="n">thresholds_days</span> <span class="o">=</span> <span class="mi">365</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">threshold_years</span><span class="p">)</span> 
        <span class="n">overlap_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">threshold_years</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">t_years</span><span class="p">,</span> <span class="n">t_days</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">threshold_years</span><span class="p">,</span> <span class="n">thresholds_days</span><span class="p">):</span>
            <span class="n">over_thresh</span> <span class="o">=</span> <span class="n">O</span> <span class="o">&gt;=</span> <span class="n">t_days</span>
            <span class="n">over_thresh</span> <span class="o">=</span> <span class="n">over_thresh</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">over_thresh_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">over_thresh</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">ws</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">watershed_ids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">overlap_dict</span><span class="p">[</span><span class="n">t_years</span><span class="p">][</span><span class="n">ws</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">watershed_ids</span><span class="p">[</span><span class="n">over_thresh_np</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

        <span class="c1"># Save the overlap dictionary to a JSON file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">overlap_dict_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">overlap_dict</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    ...overlap dict saved to </span><span class="si">{</span><span class="n">overlap_dict_file</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">overlap_dict</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">StationData</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">stn</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span> <span class="o">=</span> <span class="n">stn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">attr_gdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LN_param_dict</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">LN_param_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_grid_points</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">n_grid_points</span>
        <span class="c1"># self.catchments = catchments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_flow</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">min_flow</span> <span class="c1"># don&#39;t allow flows below this value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">divergence_measures</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">divergence_measures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">met_forcings_folder</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">LSTM_forcings_folder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LSTM_ensemble_result_folder</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">LSTM_ensemble_result_folder</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">target_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">attr_gdf</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">stn</span><span class="p">][</span><span class="s1">&#39;drainage_area_km2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_target_streamflow_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_global_range</span><span class="p">(</span><span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_grid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_divergence_measure_functions</span><span class="p">()</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">retrieve_timeseries_discharge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stn</span><span class="p">):</span>
        <span class="n">watershed_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">official_id_dict</span><span class="p">[</span><span class="n">stn</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="s1">&#39;discharge&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">watershed</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">watershed_id</span><span class="p">))</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;discharge&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)[[</span><span class="s1">&#39;discharge&#39;</span><span class="p">]]</span>
        <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># clip minimum flow to 1e-4</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;discharge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;discharge&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">min_flow</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;discharge&#39;</span><span class="p">:</span> <span class="n">stn</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1">_uar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">df</span><span class="p">[</span><span class="n">stn</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">da_dict</span><span class="p">[</span><span class="n">stn</span><span class="p">]</span>      
        <span class="k">return</span> <span class="n">df</span>
        

    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_target_streamflow_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># self.stn_df = dpf.get_timeseries_data(self.target_stn)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stn_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retrieve_timeseries_discharge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uar_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">_uar&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_observations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stn_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">uar_label</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">())</span>  
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>        
        <span class="c1"># self.baseline_log_grid = np.linspace(np.log(adjusted_min_uar), np.log(max_uar), self.n_grid_points)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseline_log_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_grid_points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseline_lin_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
        <span class="c1"># max_step_size = self.baseline_lin_grid[-1] - self.baseline_lin_grid[-2]</span>
        <span class="c1"># print(f&#39;    max step size = {max_step_size:.1f} L/s/km^2 for n={self.n_grid_points:.1e} grid points&#39;)        </span>
        
        
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_global_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xminglobal</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span> <span class="n">xmaxglobal</span><span class="o">=</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        xminglobal should be expressed in terms that equate to </span>
<span class="sd">        a minimum flow of 0.1 L/s, or 1e-4 m^3/s must be divided by area to make UAR</span>
<span class="sd">        NOTE: xmaxglobal is already expressed in unit area (100m^3/s/km^2 = 1e5 L/s/km^2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># shift the minimum flow by a small amount to force the left interval bound</span>
        <span class="c1"># to include the assumed global minimum flow (1e-4 m^/3) or 0.1 L/s) </span>
        <span class="c1"># expressed in unit area terms on a site-specific basis</span>
        <span class="n">gmin_uar</span> <span class="o">=</span> <span class="p">(</span><span class="n">xminglobal</span> <span class="o">-</span> <span class="n">epsilon</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_da</span>
        <span class="c1"># w_global = np.log(xmaxglobal) - np.log(gmin_uar)</span>
        <span class="c1"># check to make sure that the maximum UAR contains the max observed value</span>
        <span class="n">max_uar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stn_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">uar_label</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">max_uar</span> <span class="o">&lt;=</span> <span class="n">xmaxglobal</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;max UAR &gt; max global assumption </span><span class="si">{</span><span class="n">max_uar</span><span class="si">:</span><span class="s1">.1e</span><span class="si">}</span><span class="s1"> &gt; </span><span class="si">{</span><span class="n">xmaxglobal</span><span class="si">:</span><span class="s1">.1e</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xmaxglobal</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gmin_uar</span><span class="p">)</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_adjust_Q_pdf_with_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjusts the simulated PDF Q(x), originally defined on x_sim, by incorporating a Dirichlet prior,</span>
<span class="sd">        to produce an adjusted (posterior) PDF Q_mod on x_target.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure the target grid lies within the global range.</span>
        <span class="c1"># Compute the global log-width.</span>
                        
        <span class="c1"># Convert Q_interp (a PDF) into effective &quot;counts&quot; using the number of observations.</span>
        <span class="c1"># counts_Q = N_obs * Q</span>
        
        <span class="c1"># Convert the prior density into pseudo-counts.</span>
        <span class="c1"># years_equiv = n_series * (N_obs / 365.25)</span>
        <span class="c1"># counts_prior = (self.pdf_prior / years_equiv) * dx</span>
        <span class="c1"># prior_pdf_interp = jnp.interp(self.baseline_log_grid, self.ba, prior_pdf, left=0, right=0)</span>
        <span class="n">prior_pseudo_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;prior&#39;</span><span class="p">]</span>
        <span class="n">n_observations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;n_obs&#39;</span><span class="p">]</span>
        
        <span class="c1"># Combine the counts from Q and the prior.</span>
        <span class="n">Q_mod</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">*</span> <span class="n">n_observations</span> <span class="o">+</span> <span class="n">prior_pseudo_counts</span>
        <span class="c1"># Renormalize to obtain the adjusted PDF (discrete PMF) on x_target.</span>
        <span class="n">Q_mod</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Q_mod</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Q_mod</span><span class="p">)),</span> <span class="s1">&#39;Q_mod is messed up&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Q_mod</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Q_mod min:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Q_mod</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Q_mod sum:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Q_mod</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Q_mod:&#39;</span><span class="p">,</span> <span class="n">Q_mod</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Q:&#39;</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;prior_pseudo_counts:&#39;</span><span class="p">,</span> <span class="n">prior_pseudo_counts</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n_observations:&#39;</span><span class="p">,</span> <span class="n">n_observations</span><span class="p">)</span>
            <span class="n">Q_mod</span> <span class="o">+=</span> <span class="mf">1e-18</span>
            <span class="n">Q_mod</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Q_mod</span><span class="p">)</span>
            <span class="c1"># raise ValueError(f&#39;Q_mod min &lt; 0: {np.min(Q_mod)}&#39;)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Q_mod</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;qmod_i &lt; 0 (</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Q_mod</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Q_mod</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Q_mod doesn&#39;t sum to 1: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Q_mod</span><span class="p">)</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">q_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">Q</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">prior_bias</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">q_mask</span><span class="p">,</span> <span class="n">Q</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">Q</span> <span class="o">/</span> <span class="n">Q_mod</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">prior_bias</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.0001</span><span class="p">:</span>
            <span class="n">prior_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;prior&#39;</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;prior pmf sum =&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">prior_pdf</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Q_sum = &#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Q_mod sum = &#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Q_mod</span><span class="p">))</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;    Prior bias </span><span class="si">{</span><span class="n">prior_bias</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> bits/sample bias&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">Q_mod</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_emd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;sum P = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">q</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;min q_i &lt; 0: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">emd</span> <span class="o">=</span> <span class="n">wasserstein_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">emd</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="c1">#, {&#39;bias&#39;: None, &#39;unsupported_mass&#39;: None, &#39;pct_of_signal&#39;: None}</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_kld</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># assert p and q are 1d</span>
        <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;p is not 1D: </span><span class="si">{</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;q is not 1D: </span><span class="si">{</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="c1"># Ensure q is at least 2D for consistent broadcasting</span>
        <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;sum P = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;sum Q = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">q</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;min q_i &lt; 0: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;min p_i &lt; 0: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">p_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">dkl</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">p_mask</span><span class="p">,</span> <span class="n">p</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">p</span> <span class="o">/</span> <span class="n">q</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">dkl</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_set_divergence_measure_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">divergence_functions</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">divergence_measures</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">dm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">divergence_measures</span><span class="p">:</span>
            <span class="c1"># set the divergence measure functions</span>
            <span class="k">if</span> <span class="n">dm</span> <span class="o">==</span> <span class="s1">&#39;DKL&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">divergence_functions</span><span class="p">[</span><span class="n">dm</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_kld</span>
            <span class="k">elif</span> <span class="n">dm</span> <span class="o">==</span> <span class="s1">&#39;EMD&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">divergence_functions</span><span class="p">[</span><span class="n">dm</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_emd</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;only KL divergence (DKL) and Earth Mover&#39;s Distance (EMD) are implemented&quot;</span><span class="p">)</span>
            

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_bias_from_eps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pmf</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">divergence_measure</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute KL divergence between original PMF and PMF + eps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pmf : jnp.ndarray</span>
<span class="sd">            The original PMF (should sum to 1).</span>
<span class="sd">        eps : float</span>
<span class="sd">            Small value added to avoid zero bins.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            D_KL(pmf || pmf_eps) representing the bias introduced by smoothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pmf_eps</span> <span class="o">=</span> <span class="n">pmf</span> <span class="o">+</span> <span class="n">eps</span>
        <span class="n">pmf_eps</span> <span class="o">/=</span> <span class="n">pmf_eps</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">divergence_functions</span><span class="p">[</span><span class="n">divergence_measure</span><span class="p">](</span><span class="n">pmf</span><span class="p">,</span> <span class="n">pmf_eps</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">kNNFDCEstimator</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">target_stn</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span> <span class="o">=</span> <span class="n">target_stn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">k_nearest</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_schemes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ID1&#39;</span><span class="p">,</span> <span class="s1">&#39;ID2&#39;</span><span class="p">]</span> <span class="c1">#inverse distance and inverse square distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_find_k_nearest_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_index</span><span class="p">,</span> <span class="n">tree_type</span><span class="p">,</span> <span class="n">overlapping_tree_idxs</span><span class="p">):</span>
        <span class="c1"># Query the k+1 nearest neighbors because the first neighbor is the target point itself</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapping_tree_idxs</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span> 
            <span class="n">max_search</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapping_tree_idxs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_search</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max_to_check</span>

        <span class="k">if</span> <span class="n">tree_type</span> <span class="o">==</span> <span class="s1">&#39;spatial_dist&#39;</span><span class="p">:</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">spatial_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">target_index</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">max_search</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">distances</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="k">elif</span> <span class="n">tree_type</span> <span class="o">==</span> <span class="s1">&#39;attribute_dist&#39;</span><span class="p">:</span>
            <span class="c1"># Example query: Find the nearest neighbors for the first point</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">attribute_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">normalized_attr_values</span><span class="p">[</span><span class="n">target_index</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">max_search</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;tree type not identified, must be one of spatial_dist, or attribute_dist.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Remove target (self) from the results</span>
        <span class="n">self_index</span> <span class="o">=</span> <span class="n">target_index</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">!=</span> <span class="n">self_index</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>

        <span class="c1"># Filter by the pre-processed overlapping tree indices</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapping_tree_idxs</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">overlap_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">overlapping_tree_idxs</span><span class="p">)</span>
            <span class="n">filtered</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">overlap_set</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filtered</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">distances</span><span class="p">))</span>

        <span class="n">neighbour_indices</span><span class="p">,</span> <span class="n">neighbour_distances</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">filtered</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neighbour_indices</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neighbour_distances</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_time_series_completeness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeseries</span><span class="p">):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">timeseries</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">timeseries</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;_uar&#39;</span><span class="p">)])</span>
        <span class="c1"># print(f&#39;           After dropping len={len(df)}, {df.index.min()} - {df.index.max()}&#39;)</span>
        <span class="c1"># compute the total number of observations per month</span>
        <span class="c1"># we want to ensure the simulation period is not seasonal</span>
        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;month&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">month</span>
        <span class="n">days_by_month</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;month&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="c1"># Check that all 12 months are present</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">days_by_month</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    Not all months represented year.  Skipping.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">min_days</span> <span class="o">=</span> <span class="n">days_by_month</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="c1"># Check that every month has at least 10 unique days</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">min_days</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    At least one month is not represented by at least ten days, skipping comparison.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># count the number of complete years of record</span>
        <span class="k">return</span> <span class="kc">True</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_effective_k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">max_k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">T</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">max_k</span> <span class="o">=</span> <span class="n">max_k</span> <span class="ow">or</span> <span class="n">K</span>

        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">sorted_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">row_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">T</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">effective_k</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mean_furthest</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ks</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">sorted_idx</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">nan_mask</span><span class="p">[</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">valid_count</span> <span class="o">=</span> <span class="n">valid</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">effective_k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valid_count</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
            <span class="n">furthest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">mean_furthest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">furthest_idx</span><span class="p">[</span><span class="n">valid_count</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">valid_count</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;effective_k&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">effective_k</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="s1">&#39;mean_furthest_idx&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">mean_furthest</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">},</span> <span class="n">index</span><span class="o">=</span><span class="n">ks</span><span class="p">)</span>

        
    <span class="k">def</span><span class="w"> </span><span class="nf">_check_neighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stn</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">concurrent</span><span class="p">,</span> <span class="n">target_df</span><span class="p">,</span> <span class="n">min_years</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="c1"># proxy_df = dpf.get_timeseries_data(stn)</span>
        <span class="n">proxy_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">retrieve_timeseries_discharge</span><span class="p">(</span><span class="n">stn</span><span class="p">)[[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1">_uar&#39;</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">concurrent</span> <span class="o">==</span> <span class="s1">&#39;concurrent&#39;</span><span class="p">:</span>
            <span class="n">proxy_df</span> <span class="o">=</span> <span class="n">proxy_df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">target_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="n">full_year_represented</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_time_series_completeness</span><span class="p">(</span><span class="n">proxy_df</span><span class="p">)</span>
        <span class="n">n_years</span> <span class="o">=</span> <span class="n">proxy_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">365</span>
        <span class="k">if</span> <span class="n">n_years</span> <span class="o">&lt;</span> <span class="n">min_years</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">full_year_represented</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    Skipping </span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1">: &lt;1 year or incomplete.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">stn</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">n_years</span><span class="p">,</span> <span class="n">proxy_df</span><span class="p">]</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_query_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">id1</span><span class="p">,</span> <span class="n">id2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Query distance between two points in a tree using official_id.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">id1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_index</span> <span class="ow">or</span> <span class="n">id2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_index</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;One or both IDs (</span><span class="si">{</span><span class="n">id1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">id2</span><span class="si">}</span><span class="s2">) not found.&quot;</span><span class="p">)</span>
    
        <span class="c1"># Get indices from ID mapping</span>
        <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_index</span><span class="p">[</span><span class="n">id1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_index</span><span class="p">[</span><span class="n">id2</span><span class="p">]</span>        
        <span class="c1"># Query the distance</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index2</span><span class="p">])</span>  <span class="c1"># Euclidean distance</span>
        <span class="k">return</span> <span class="n">distance</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_retrieve_nearest_nbr_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_type</span><span class="p">,</span> <span class="n">concurrent</span><span class="p">,</span> <span class="n">min_concurrent_years</span><span class="p">):</span>
        <span class="n">tree_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">]</span>
        <span class="c1"># get the pre-screened concurrent stations</span>
        <span class="n">target_ws_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">official_id_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">]</span>

        <span class="n">max_nbrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max_to_check</span>

        <span class="c1"># use the pre-computed overlap dictionary to find the concurrent stations</span>
        <span class="n">overlapping_tree_idxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">concurrent</span> <span class="o">==</span> <span class="s1">&#39;concurrent&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">min_concurrent_years</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;concurrent min years must be &gt; 0, not </span><span class="si">{</span><span class="n">min_concurrent_years</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">overlapping_ws_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">overlap_dict</span><span class="p">[</span><span class="n">min_concurrent_years</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">target_ws_id</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">overlapping_stn_official_ids</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">watershed_id_dict</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">overlapping_ws_ids</span><span class="p">]</span>

            <span class="n">existing_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">overlapping_stn_official_ids</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_index</span><span class="p">]</span>
            <span class="n">overlapping_tree_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_index</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">existing_keys</span><span class="p">]</span>
            <span class="n">overlapping_tree_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">overlapping_tree_idxs</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">neighbour_idxs</span><span class="p">,</span> <span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_k_nearest_neighbors</span><span class="p">(</span><span class="n">tree_idx</span><span class="p">,</span> <span class="n">tree_type</span><span class="p">,</span> <span class="n">overlapping_tree_idxs</span><span class="p">)</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">index_to_id</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">neighbour_idxs</span><span class="o">.</span><span class="n">tolist</span><span class="p">()][:</span><span class="n">max_nbrs</span><span class="p">]</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">neighbours</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1"> is in the list of neighbours: </span><span class="si">{</span><span class="n">neighbours</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">concurrent_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">concurrent</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbours</span><span class="p">)</span>
        <span class="n">df_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">stn_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbours</span><span class="p">)</span>

        <span class="c1"># don&#39;t need to recheck neighbours</span>
        <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>  <span class="c1"># Adjust max workers</span>
            <span class="n">checked_neighbours</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_neighbours</span><span class="p">,</span> <span class="n">neighbours</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">concurrent_inputs</span><span class="p">,</span> <span class="n">df_inputs</span><span class="p">))</span>
        
        <span class="n">good_nbrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">checked_neighbours</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;     ...found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">good_nbrs</span><span class="p">)</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">tree_type</span><span class="si">}</span><span class="s1"> tree) neighbours (</span><span class="si">{</span><span class="n">concurrent</span><span class="si">}</span><span class="s1">) for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1"> from </span><span class="si">{</span><span class="n">max_nbrs</span><span class="si">}</span><span class="s1"> nearest neighbours&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_nbrs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   need&#39;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_nbrs</span><span class="p">),</span> <span class="s1">&#39;  more good records&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max_to_check</span> <span class="o">+=</span> <span class="mi">50</span>
            <span class="n">max_nbrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max_to_check</span>
            <span class="k">if</span> <span class="n">max_nbrs</span> <span class="o">&lt;=</span> <span class="mi">600</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieve_nearest_nbr_data</span><span class="p">(</span><span class="n">tree_type</span><span class="p">,</span> <span class="n">concurrent</span><span class="p">,</span> <span class="n">min_concurrent_years</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">good_nbrs</span><span class="p">)</span><span class="si">}</span><span class="s1">/10 suitable nearest neighbours found (</span><span class="si">{</span><span class="n">max_nbrs</span><span class="si">}</span><span class="s1"> searched)&#39;</span><span class="p">)</span>

        <span class="n">complement_dist</span> <span class="o">=</span> <span class="s1">&#39;attribute_dist&#39;</span> <span class="k">if</span> <span class="n">tree_type</span> <span class="o">==</span> <span class="s1">&#39;spatial_dist&#39;</span> <span class="k">else</span> <span class="s1">&#39;spatial_dist&#39;</span> 
        <span class="c1"># set the OPPOSITE tree to the current tree type</span>
        <span class="n">complement_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">attribute_tree</span> <span class="k">if</span> <span class="n">tree_type</span> <span class="o">==</span> <span class="s1">&#39;spatial_dist&#39;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">spatial_tree</span> 
        <span class="c1"># the multiplier should reflect conversion to km from m for spatial distance </span>
        <span class="n">multiplier</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">1000</span> <span class="k">if</span> <span class="n">complement_dist</span> <span class="o">==</span> <span class="s1">&#39;spatial_dist&#39;</span> <span class="k">else</span> <span class="mi">1</span> 

        <span class="c1"># sort the neighbours by distance</span>
        <span class="c1"># output is [&#39;official_id&#39;, &#39;distance&#39;, &#39;n_years&#39;, &#39;timeseries df&#39;]</span>
        <span class="n">good_nbrs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">good_nbrs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tup</span><span class="p">:</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>        
        <span class="n">nbr_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">good_nbrs</span><span class="p">],</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Align with target index if concurrent, leave as is if async.</span>
        <span class="k">if</span> <span class="n">concurrent</span> <span class="o">==</span> <span class="s1">&#39;concurrent&#39;</span><span class="p">:</span>
            <span class="n">target_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">stn_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">_uar&#39;</span><span class="p">])</span>
            <span class="n">nbr_df</span> <span class="o">=</span> <span class="n">nbr_df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">target_series</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="n">nbr_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">e</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">good_nbrs</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="s1">&#39;n_years&#39;</span><span class="p">])</span>  
        <span class="n">nbr_data</span><span class="p">[</span><span class="n">complement_dist</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nbr_data</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_distance</span><span class="p">(</span><span class="n">complement_tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">))</span> <span class="o">*</span> <span class="n">multiplier</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="n">effective_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_effective_k</span><span class="p">(</span><span class="n">nbr_df</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span><span class="p">,</span> <span class="n">effective_k</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_contributing_ensemble_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbr_data</span><span class="p">,</span> <span class="n">min_years</span><span class="p">,</span> <span class="n">previous_ids</span><span class="p">,</span> <span class="n">min_years_prev</span><span class="p">):</span>
        <span class="n">current_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nbr_data</span><span class="o">.</span><span class="n">columns</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">previous_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current_ids</span> <span class="o">==</span> <span class="n">previous_ids</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    No change in neighbor set between </span><span class="si">{</span><span class="n">min_years_prev</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">min_years</span><span class="si">}</span><span class="s2"> years.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">added</span> <span class="o">=</span> <span class="n">current_ids</span> <span class="o">-</span> <span class="n">previous_ids</span>
                <span class="n">removed</span> <span class="o">=</span> <span class="n">previous_ids</span> <span class="o">-</span> <span class="n">current_ids</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Change detected for min_concurrent_years </span><span class="si">{</span><span class="n">min_years_prev</span><span class="si">}</span><span class="s2"> → </span><span class="si">{</span><span class="n">min_years</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">added</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    + Added:   </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">added</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">removed</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    - Removed: </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">removed</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">previous_ids</span> <span class="o">=</span> <span class="n">current_ids</span>
        <span class="n">min_years_prev</span> <span class="o">=</span> <span class="n">min_years</span>
        <span class="k">return</span> <span class="n">previous_ids</span><span class="p">,</span> <span class="n">min_years_prev</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_nearest_neighbour_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate nearest neighbours for spatial and attribute selected k-nearest neighbours for both concurrent and asynchronous records.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    ...initializing </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max_to_check</span><span class="si">}</span><span class="s1"> nearest neighbours with minimum concurrent record.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbr_dfs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="n">tree_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;spatial_dist&#39;</span><span class="p">,</span> <span class="s1">&#39;attribute_dist&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">concurrent</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;concurrent&#39;</span><span class="p">,</span> <span class="s1">&#39;async&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">LSTM_concurrent_network</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">concurrent</span> <span class="o">==</span> <span class="s1">&#39;concurrent&#39;</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    Skipping concurrent check for non-LSTM concurrent network.&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">concurrent</span> <span class="o">==</span> <span class="s1">&#39;async&#39;</span><span class="p">:</span>
                    <span class="n">min_concurrent_years</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">min_concurrent_years</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">minimum_concurrent_years</span>
                <span class="n">previous_ids</span><span class="p">,</span> <span class="n">min_years_prev</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">min_overlap</span> <span class="ow">in</span> <span class="n">min_concurrent_years</span><span class="p">:</span>
                    <span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span><span class="p">,</span> <span class="n">effective_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieve_nearest_nbr_data</span><span class="p">(</span><span class="n">tree_type</span><span class="p">,</span> <span class="n">concurrent</span><span class="p">,</span> <span class="n">min_overlap</span><span class="p">)</span>
                    <span class="n">previous_ids</span><span class="p">,</span> <span class="n">min_years_prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contributing_ensemble_check</span><span class="p">(</span><span class="n">nbr_df</span><span class="p">,</span> <span class="n">min_overlap</span><span class="p">,</span> <span class="n">previous_ids</span><span class="p">,</span> <span class="n">min_years_prev</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="n">nbr_df</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tree_type</span><span class="si">}</span><span class="s1"> attr concurrent=</span><span class="si">{</span><span class="n">concurrent</span><span class="si">}</span><span class="s1"> nbr df empty&#39;</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;       &#39;</span><span class="p">,</span> <span class="n">tree_type</span><span class="p">,</span> <span class="n">concurrent</span><span class="p">,</span> <span class="n">min_overlap</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nbr_df</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nbr_dfs</span><span class="p">[</span><span class="n">tree_type</span><span class="p">][</span><span class="n">concurrent</span><span class="p">][</span><span class="n">min_overlap</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;nbr_df&#39;</span><span class="p">:</span> <span class="n">nbr_df</span><span class="p">,</span>
                        <span class="s1">&#39;nbr_data&#39;</span><span class="p">:</span> <span class="n">nbr_data</span><span class="p">,</span>
                        <span class="s1">&#39;effective_k&#39;</span><span class="p">:</span> <span class="n">effective_k</span>
                    <span class="p">}</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_run_spatial_knn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_neighbours</span><span class="p">,</span> <span class="n">time_type</span><span class="p">,</span> <span class="n">weight_scheme</span><span class="p">):</span>
        <span class="n">target_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_idx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_neighbours</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">sim_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">NN_</span><span class="si">{</span><span class="n">time_type</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">weight_scheme</span><span class="si">}</span><span class="s1">&#39;</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute normalized inverse (square) distance weights to a given power.&quot;&quot;&quot;</span>

        <span class="n">distances</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distances</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="s1">&#39;ID1&#39;</span><span class="p">:</span>
            <span class="n">power</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s1">&#39;ID2&#39;</span><span class="p">:</span>
            <span class="n">power</span> <span class="o">=</span> <span class="mf">2.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown weighting method: </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">.  Only ID1 (inverse distance) or ID2 (inverse square distance) are implemented.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inv_weights</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">**</span> <span class="n">power</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">inv_weights</span> <span class="o">/</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">inv_weights</span><span class="p">)</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_prior_from_laplace_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicted_uar</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_prior</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">scale_factor</span><span class="o">=</span><span class="mf">1.05</span><span class="p">,</span> <span class="n">recursion_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a Laplace distribution to the simulation and define a </span>
<span class="sd">        pdf across a pre-determined &quot;global&quot; range to avoid data</span>
<span class="sd">        leakage.  &quot;Normalize&quot; by setting the total prior mass to</span>
<span class="sd">        integrate to a factor related to the number of observations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># assert no nan values</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">predicted_uar</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;NaN values in predicted_uar: </span><span class="si">{</span><span class="n">predicted_uar</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="c1"># assert all positive values</span>
        <span class="c1"># assert np.all(predicted_uar &gt; 0), f&#39;Negative values in predicted_uar: {np.min(predicted_uar)}&#39;</span>
        <span class="c1"># replace anything &lt;= 0 with 1e-4 scaled by the drainage area</span>
        <span class="n">predicted_uar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">predicted_uar</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mf">1e-4</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">target_da</span><span class="p">,</span> <span class="n">predicted_uar</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">predicted_uar</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;Negative values in predicted_uar: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">predicted_uar</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="c1"># print(&#39;min/max: &#39;, np.min(predicted_uar), np.max(predicted_uar))</span>
        <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">laplace</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">predicted_uar</span><span class="p">))</span>       

        <span class="c1"># Apply scale factor in case of recursion</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">original_scale</span> <span class="o">=</span> <span class="n">scale</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">scale_factor</span> <span class="o">**</span> <span class="n">recursion_depth</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;   Adjusting scale from </span><span class="si">{</span><span class="n">original_scale</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">scale</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> for recursion depth </span><span class="si">{</span><span class="n">recursion_depth</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">prior_pdf</span> <span class="o">=</span> <span class="n">laplace</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">prior_check</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">prior_pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
        <span class="n">prior_pdf</span> <span class="o">/=</span> <span class="n">prior_check</span>

        <span class="c1"># Check for zeros</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">prior_pdf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">prior_pdf</span><span class="p">)):</span>
            <span class="c1"># Prevent scale from being too small</span>
            <span class="k">if</span> <span class="n">recursion_depth</span> <span class="o">&gt;=</span> <span class="n">max_depth</span><span class="p">:</span>
                <span class="c1"># set a very small prior</span>
                <span class="n">prior_pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Recursion limit reached. Scale=</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2">, setting default prior to 1 pseudo-count uniform distribution.&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">prior_pdf</span>
                <span class="c1"># raise ValueError(err_msg)</span>
            <span class="c1"># print(f&quot;Recursion {recursion_depth}: Zero values detected. Increasing scale to {scale:.6f}&quot;)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_prior_from_laplace_fit</span><span class="p">(</span><span class="n">predicted_uar</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="n">n_cols</span><span class="p">,</span> <span class="n">recursion_depth</span><span class="o">=</span><span class="n">recursion_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="n">second_check</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">prior_pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">second_check</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">2e-4</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;prior check != 1, </span><span class="si">{</span><span class="n">second_check</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1"> N=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted_uar</span><span class="p">)</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">predicted_uar</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">prior_pdf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;min prior == 0, scale=</span><span class="si">{</span><span class="n">scale</span><span class="si">:</span><span class="s1">.5f</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="c1"># convert prior PDF to PMF (pseudo-count mass function)</span>
        <span class="n">prior_pmf</span> <span class="o">=</span> <span class="n">prior_pdf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>

        <span class="c1"># scale the number of pseudo-counts based on years of record  (365 / n_observations)</span>
        <span class="c1"># and number of models in the ensemble (given by n_cols)</span>
        <span class="n">prior_pseudo_counts</span> <span class="o">=</span> <span class="n">prior_pmf</span> <span class="o">*</span> <span class="p">(</span><span class="mi">365</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted_uar</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_cols</span><span class="p">))</span>
        
        <span class="c1"># return weighted_prior_pdf</span>
        <span class="k">return</span> <span class="n">prior_pseudo_counts</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_frequency_ensemble_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdfs</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function computes the weighted ensemble distribution estimates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Normalize distance weights</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  <span class="c1"># Ensure 1D array</span>
            <span class="n">pdf_est</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pdfs</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">@</span> <span class="n">weights</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pdf_est</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pdfs</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>


        <span class="c1"># Check integral before normalization</span>
        <span class="n">pdf_check</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">pdf_est</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
        <span class="n">normalized_pdf</span> <span class="o">=</span> <span class="n">pdf_est</span> <span class="o">/</span> <span class="n">pdf_check</span>
        <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">normalized_pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;ensemble pdf does not integrate to 1: </span><span class="si">{</span><span class="n">pdf_check</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span>
                
        <span class="c1"># Compute PMF</span>
        <span class="n">pmf_est</span> <span class="o">=</span> <span class="n">normalized_pdf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>
        <span class="n">pmf_est</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf_est</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pmf_est</span><span class="p">,</span> <span class="n">pdf_est</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_ensemble_member_distribution_estimates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the ensemble distribution estimates based on the KNN dataframe.</span>
<span class="sd">        &quot;&quot;&quot;</span>    
        <span class="n">pdfs</span><span class="p">,</span> <span class="n">prior_biases</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(),</span> <span class="p">{}</span>
        <span class="c1"># initialize a kde estimator object</span>
        <span class="n">kde</span> <span class="o">=</span> <span class="n">KDEEstimator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span> 
            <span class="c1"># evaluate the laplace on the prediction as a prior</span>
            <span class="c1"># drop the nan values</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
            <span class="n">obs_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;0 values for </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s1">&#39;</span>

            <span class="c1"># compute the pdf and pmf using kde</span>
            <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;NaN values in </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">values</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>

            <span class="n">kde_pmf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">kde</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span>
                <span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">target_da</span>
            <span class="p">)</span>

            <span class="n">prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_prior_from_laplace_fit</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># priors are expressed in pseudo-counts</span>
            <span class="c1"># convert the pdf to counts and apply the prior</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">kde_pmf</span> <span class="o">*</span> <span class="n">obs_count</span> <span class="o">+</span> <span class="n">prior</span>

            <span class="c1"># re-normalize the pmf</span>
            <span class="n">pmf</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            <span class="n">pdf</span> <span class="o">=</span> <span class="n">pmf</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>

            <span class="n">pdf_check</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
            <span class="n">pdf</span> <span class="o">/=</span> <span class="n">pdf_check</span>
            <span class="c1"># pdf /= pdf_check</span>
            <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;pdf does not integrate to 1 in compute_ensemble_member_distribution_estimates: </span><span class="si">{</span><span class="n">pdf_check</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">pdfs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdf</span>

            <span class="c1"># convert the pdf to pmf</span>
            <span class="n">pmf</span> <span class="o">=</span> <span class="n">pdf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>
            <span class="n">pmf</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf</span><span class="p">)</span>
            <span class="c1"># assert np.isclose(np.sum(pmf), 1, atol=1e-4), f&#39;pmf does not sum to 1 in compute_ensemble_member_distribution_estimates: {np.sum(pmf):.5f}&#39;</span>
            
            <span class="c1"># compute the bias added by the prior</span>
            <span class="n">prior_biases</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;DKL&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_kld</span><span class="p">(</span><span class="n">kde_pmf</span><span class="p">,</span> <span class="n">pmf</span><span class="p">),</span> <span class="s1">&#39;EMD&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_emd</span><span class="p">(</span><span class="n">kde_pmf</span><span class="p">,</span> <span class="n">pmf</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">pdfs</span><span class="p">,</span> <span class="n">prior_biases</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_frequency_ensemble_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">knn_df_all</span><span class="p">,</span> <span class="n">knn_data_all</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">,</span> <span class="n">concurrent</span><span class="p">,</span> <span class="n">ensemble_pdfs</span><span class="p">,</span> <span class="n">min_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For asynchronous comparisons, we estimate pdfs for ensemble members, then compute the mean in the time domain</span>
<span class="sd">        to represent the FDC simulation.  We do not do temporal averaging in this case.</span>
<span class="sd">        Default min_overlap is 0 for asynchronous comparisons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># distances_all = knn_data_all[&#39;distance&#39;].values[:self.k_nearest]</span>
        <span class="c1"># nbr_ids_all = knn_data_all[&#39;official_id&#39;].values[:self.k_nearest]</span>
        
        <span class="c1"># distances = jnp.array(nbr_data[&#39;distance&#39;].astype(float).values)</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">pdfs</span><span class="p">,</span> <span class="n">pmfs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">all_distances</span> <span class="o">=</span> <span class="n">knn_data_all</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">all_ids</span> <span class="o">=</span> <span class="n">knn_data_all</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># prior_bias_df = pd.DataFrame(prior_bias_dict)</span>
        <span class="k">for</span> <span class="n">wm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_schemes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">distances</span> <span class="o">=</span> <span class="n">all_distances</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>
                <span class="n">nbr_ids</span> <span class="o">=</span> <span class="n">all_ids</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>
                <span class="n">knn_pdfs</span> <span class="o">=</span> <span class="n">ensemble_pdfs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">_NN_</span><span class="si">{</span><span class="n">min_overlap</span><span class="si">}</span><span class="s1">_minYears_</span><span class="si">{</span><span class="n">concurrent</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">distance_type</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">wm</span><span class="si">}</span><span class="s1">_freqEnsemble&#39;</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_weights</span><span class="p">(</span><span class="n">wm</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
                <span class="n">pmf_est</span><span class="p">,</span> <span class="n">pdf_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_frequency_ensemble_mean</span><span class="p">(</span><span class="n">knn_pdfs</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">pmf_est</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;pmf_est is None for </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">&#39;</span>
            
                <span class="c1"># compute the mean number of observations (non-nan values) per row</span>
                <span class="n">mean_obs_per_timestep</span> <span class="o">=</span> <span class="n">knn_df_all</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">mean_obs_per_proxy</span> <span class="o">=</span> <span class="n">knn_df_all</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

                <span class="c1"># max_prior_bias = prior_bias_df.iloc[:k].max(axis=0)                </span>
                <span class="c1"># compute the frequency-based ensemble pdf estimate</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span> <span class="s1">&#39;n_obs&#39;</span><span class="p">:</span> <span class="n">mean_obs_per_proxy</span><span class="p">,</span>
                                                <span class="s1">&#39;mean_obs_per_timestep&#39;</span><span class="p">:</span> <span class="n">mean_obs_per_timestep</span><span class="p">,</span>
                                                <span class="s1">&#39;nbrs&#39;</span><span class="p">:</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nbr_ids</span><span class="p">)}</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;DKL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_kld</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">,</span> <span class="n">pmf_est</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;EMD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_emd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">,</span> <span class="n">pmf_est</span><span class="p">)</span>

                <span class="c1"># print(k, wm, label, self.knn_simulation_data[label][&#39;DKL&#39;])</span>
                
                <span class="n">pdfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pdf_est</span><span class="p">))</span>
                <span class="n">pmfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pmf_est</span><span class="p">))</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="c1"># create a dataframe of labels(columns) for each pdf</span>
        <span class="n">knn_pdfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pdfs</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">knn_pmfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pmfs</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># Filter out already existing columns to avoid duplication</span>
        <span class="n">new_pdf_cols</span> <span class="o">=</span> <span class="n">knn_pdfs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">new_pmf_cols</span> <span class="o">=</span> <span class="n">knn_pmfs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="c1"># Concat only new columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="p">,</span> <span class="n">knn_pdfs</span><span class="p">[</span><span class="n">new_pdf_cols</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span><span class="p">,</span> <span class="n">knn_pmfs</span><span class="p">[</span><span class="n">new_pmf_cols</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_run_async_knn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
        <span class="n">min_overlap</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nbr_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbr_dfs</span><span class="p">[</span><span class="n">dist</span><span class="p">][</span><span class="s1">&#39;async&#39;</span><span class="p">][</span><span class="n">min_overlap</span><span class="p">][</span><span class="s1">&#39;nbr_df&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">nbr_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbr_dfs</span><span class="p">[</span><span class="n">dist</span><span class="p">][</span><span class="s1">&#39;async&#39;</span><span class="p">][</span><span class="n">min_overlap</span><span class="p">][</span><span class="s1">&#39;nbr_data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">knn_df_all</span> <span class="o">=</span> <span class="n">nbr_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">knn_data_all</span> <span class="o">=</span> <span class="n">nbr_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">frequency_ensemble_pdfs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_ensemble_member_distribution_estimates</span><span class="p">(</span><span class="n">knn_df_all</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_frequency_ensemble_distribution</span><span class="p">(</span><span class="n">knn_df_all</span><span class="p">,</span> <span class="n">knn_data_all</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="s1">&#39;async&#39;</span><span class="p">,</span> <span class="n">frequency_ensemble_pdfs</span><span class="p">)</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_delta_spike_pmf_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span> <span class="n">log_grid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a spike PMF and compatible PDF centered at the only value in the input.</span>
<span class="sd">        The spike is placed at the nearest log_grid point to log(single_val).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log_val</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">single_val</span><span class="p">)</span>
        <span class="n">spike_idx</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">log_grid</span> <span class="o">-</span> <span class="n">log_val</span><span class="p">))</span>
        
        <span class="n">pmf</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">log_grid</span><span class="p">)</span>
        <span class="n">pmf</span> <span class="o">=</span> <span class="n">pmf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">spike_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">log_grid</span><span class="p">)</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="n">pmf</span> <span class="o">/</span> <span class="n">dx</span>  <span class="c1"># assign all mass to one bin</span>

        <span class="k">return</span> <span class="n">pmf</span><span class="p">,</span> <span class="n">pdf</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_nse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the Nash-Sutcliffe Efficiency (NSE) between observed and simulated values.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;NaN values in obs: </span><span class="si">{</span><span class="n">obs</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;NaN values in sim: </span><span class="si">{</span><span class="n">sim</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">obs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;Negative values in obs: </span><span class="si">{</span><span class="n">obs</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">sim</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;Negative values in sim: </span><span class="si">{</span><span class="n">sim</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="c1"># Compute the NSE</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">obs</span> <span class="o">-</span> <span class="n">sim</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">obs</span> <span class="o">-</span> <span class="n">obs</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">nse</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nse</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_KGE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the Kling-Gupta Efficiency (KGE) between observed and simulated values.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;NaN values in obs: </span><span class="si">{</span><span class="n">obs</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;NaN values in sim: </span><span class="si">{</span><span class="n">sim</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">obs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;Negative values in obs: </span><span class="si">{</span><span class="n">obs</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">sim</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;Negative values in sim: </span><span class="si">{</span><span class="n">sim</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="c1"># Compute the KGE</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">sim</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">/</span> <span class="n">obs</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">/</span> <span class="n">obs</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
        <span class="n">kge</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kge</span>
    
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_ensemble_contribution_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
        
        <span class="c1"># Mean number of valid values per row</span>
        <span class="n">mean_valid_per_row</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="c1"># Normalized weights per row, masking NaNs</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">masked_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">weight_sums</span> <span class="o">=</span> <span class="n">masked_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">weight_sums</span><span class="p">[</span><span class="n">weight_sums</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">normalized_weights</span> <span class="o">=</span> <span class="n">masked_weights</span> <span class="o">/</span> <span class="n">weight_sums</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># Average contribution per column across all rows</span>
        <span class="n">mean_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">normalized_weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">effective_n</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">mean_w</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mean_valid_per_row</span><span class="p">,</span> <span class="n">effective_n</span>
    
    
    
    
   
    <span class="k">def</span><span class="w"> </span><span class="nf">run_estimators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">divergence_measures</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">baseline_pmf</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_nearest_neighbour_data</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;spatial_dist&#39;</span><span class="p">,</span> <span class="s1">&#39;attribute_dist&#39;</span><span class="p">]:</span>            
            <span class="bp">self</span><span class="o">.</span><span class="n">_run_async_knn</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> 
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">LSTM_concurrent_network</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    Skipping concurrent check for non-LSTM concurrent network.&#39;</span><span class="p">)</span>
                <span class="k">continue</span> 
            <span class="k">for</span> <span class="n">min_concurrent_years</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">minimum_concurrent_years</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># go from most to least minimum required concurrent years </span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_concurrent_ensemble_inputs</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">min_concurrent_years</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_results</span><span class="p">()</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_make_json_serializable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;tolist&quot;</span><span class="p">):</span>
                <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">output</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_process_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>        
        <span class="n">pmf_labels</span><span class="p">,</span> <span class="n">pdf_labels</span><span class="p">,</span> <span class="n">sim_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># assert label sets are the same</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">pmf_labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">pdf_labels</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;pmf_labels </span><span class="si">{</span><span class="n">pmf_labels</span><span class="si">}</span><span class="s1"> != pdf_labels </span><span class="si">{</span><span class="n">pdf_labels</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">pmf_labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">sim_labels</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;pmf_labels </span><span class="si">{</span><span class="n">pmf_labels</span><span class="si">}</span><span class="s1"> != sim_labels </span><span class="si">{</span><span class="n">sim_labels</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">pmf_labels</span><span class="p">:</span>
            <span class="c1"># add the pmf and pdf in a json serializable format</span>
            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;pmf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;pdf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_json_serializable</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">results</span>
        
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">PDFEstimatorRunner</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stn_id</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">methods</span><span class="p">,</span> <span class="n">k_nearest</span><span class="p">,</span> <span class="n">max_to_check</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span> <span class="o">=</span> <span class="n">stn_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">methods</span> <span class="o">=</span> <span class="n">methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span> <span class="o">=</span> <span class="n">k_nearest</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_to_check</span> <span class="o">=</span> <span class="n">max_to_check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_min_overlap</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_results_folders</span><span class="p">()</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_create_results_folders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># create a results foder for each method if it doesn&#39;t exist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;pdf_estimates&#39;</span><span class="p">,)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results_folder</span><span class="p">)</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_process_ground_truth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kde</span> <span class="o">=</span> <span class="n">KDEEstimator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kde</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">stn_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">uar_label</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">target_da</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">baseline_pmf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline_pmf</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_save_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_check_min_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">min_years</span><span class="p">,</span> <span class="n">cdict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">overlap_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">min_concurrent_stns</span> <span class="o">=</span> <span class="mf">1e6</span>
            <span class="n">n_less_than_ten</span><span class="p">,</span> <span class="n">lonely_stns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Processing </span><span class="si">{</span><span class="n">min_years</span><span class="si">}</span><span class="s1"> years of concurrent record&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">stn</span><span class="p">,</span> <span class="n">concurrent_ids</span> <span class="ow">in</span> <span class="n">cdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">n_stns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">concurrent_ids</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n_stns</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="n">n_less_than_ten</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">lonely_stns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n_stns</span> <span class="o">&lt;</span> <span class="n">min_concurrent_stns</span><span class="p">:</span>
                    <span class="n">min_concurrent_stns</span> <span class="o">=</span> <span class="n">n_stns</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">n_less_than_ten</span><span class="si">}</span><span class="s2"> stations do not have at least 10 viable sensors in the network with at least </span><span class="si">{</span><span class="n">min_years</span><span class="si">}</span><span class="s2"> years of concurrent record.&quot;</span><span class="p">)</span>

 
    <span class="k">def</span><span class="w"> </span><span class="nf">run_selected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># check the minimum number of years of overlap for all stations in self.ctx.overlap_dict</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">result_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results_folder</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span><span class="si">}</span><span class="s1">_estimated_pdfs.json&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result_file</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">StationData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span><span class="p">)</span>
            <span class="c1"># self.data.k_nearest = self.k_nearest</span>
            <span class="c1"># self.data.max_to_check = self.max_to_check</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_ground_truth</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">EstimatorClass</span> <span class="o">=</span> <span class="n">ESTIMATOR_CLASSES</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
            <span class="n">estimator</span> <span class="o">=</span> <span class="n">EstimatorClass</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">run_estimators</span><span class="p">(</span>
                <span class="n">divergence_measures</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">divergence_measures</span><span class="p">,</span> 
                <span class="n">eps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
                <span class="n">baseline_pmf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> estimator failed for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># from utils import FDCEstimationContext</span>
<span class="n">rev_date</span> <span class="o">=</span> <span class="s1">&#39;20250227&#39;</span>
<span class="n">attr_gdf_fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;BCUB_watershed_attributes_updated_</span><span class="si">{</span><span class="n">rev_date</span><span class="si">}</span><span class="s1">.geojson&#39;</span><span class="p">)</span>
<span class="n">LSTM_forcings_folder</span> <span class="o">=</span> <span class="s1">&#39;/home/danbot2/code_5820/neuralhydrology/data/BCUB_catchment_mean_met_forcings_20250320&#39;</span>
<span class="n">LSTM_ensemble_result_folder</span> <span class="o">=</span> <span class="s1">&#39;/home/danbot2/code_5820/neuralhydrology/data/ensemble_results&#39;</span>
<span class="n">parameter_prediction_results_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;parameter_prediction_results&#39;</span><span class="p">)</span>

<span class="c1"># methods = (&#39;parametric&#39;, &#39;lstm&#39;,)</span>
<span class="n">methods</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;parametric&#39;</span><span class="p">,</span> <span class="s1">&#39;lstm&#39;</span><span class="p">,</span> <span class="s1">&#39;knn&#39;</span><span class="p">,)</span>
<span class="n">methods</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;knn&#39;</span><span class="p">,)</span>

<span class="n">processed</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">ESTIMATOR_CLASSES</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">}</span>
<span class="n">input_data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;attr_gdf_fpath&#39;</span><span class="p">:</span> <span class="n">attr_gdf_fpath</span><span class="p">,</span>
    <span class="s1">&#39;LSTM_forcings_folder&#39;</span><span class="p">:</span> <span class="n">LSTM_forcings_folder</span><span class="p">,</span>
    <span class="s1">&#39;LSTM_ensemble_result_folder&#39;</span><span class="p">:</span> <span class="n">LSTM_ensemble_result_folder</span><span class="p">,</span>
    <span class="s1">&#39;LSTM_concurrent_network&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># use only stations with data 1980-present concurrent with Daymet</span>
    <span class="s1">&#39;parameter_prediction_results_folder&#39;</span><span class="p">:</span> <span class="n">parameter_prediction_results_folder</span><span class="p">,</span>
    <span class="s1">&#39;streamflow_dir&#39;</span><span class="p">:</span> <span class="n">STREAMFLOW_DIR</span><span class="p">,</span>
    <span class="c1"># &#39;predicted_param_sample&#39;: predicted_param_sample,</span>
    <span class="s1">&#39;divergence_measures&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;DKL&#39;</span><span class="p">,</span> <span class="s1">&#39;EMD&#39;</span><span class="p">],</span>
    <span class="s1">&#39;minimum_concurrent_years&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
    <span class="s1">&#39;eps&#39;</span><span class="p">:</span> <span class="mf">1e-12</span><span class="p">,</span>
    <span class="s1">&#39;min_flow&#39;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">,</span>
    <span class="s1">&#39;n_grid_points&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="mi">12</span><span class="p">,</span>
    <span class="s1">&#39;min_overlap_years&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">FDCEstimationContext</span><span class="p">(</span><span class="o">**</span><span class="n">input_data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2889/1324 catchments contain withdrawal licenses
    ...overlap dict loaded from data/record_overlap_dict.json
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_network_records</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">if</span> <span class="n">plot_network_records</span><span class="p">:</span>
    <span class="n">discharge</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="s1">&#39;discharge&#39;</span><span class="p">]</span>
    <span class="c1"># mask = (~np.isnan(discharge)).astype(int)</span>
    <span class="n">output_file</span><span class="p">(</span><span class="s2">&quot;images/data_availability_matrix.html&quot;</span><span class="p">)</span>
    <span class="c1"># Step 1: Convert to DataArray and group by week</span>
    <span class="c1"># Convert time coordinate to Pandas Index first</span>
    <span class="n">time_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">discharge</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="c1"># Convert to weekly periods and back to timestamps (start of week)</span>
    <span class="n">week</span> <span class="o">=</span> <span class="n">time_index</span><span class="o">.</span><span class="n">to_period</span><span class="p">(</span><span class="s2">&quot;W&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_timestamp</span><span class="p">()</span>

    <span class="c1"># Assign &#39;week&#39; as a new coordinate aligned with time</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="s1">&#39;discharge&#39;</span><span class="p">]</span>  <span class="c1"># shape: (w, time)</span>

    <span class="n">d</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;week&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">week</span><span class="p">)</span>
    <span class="c1"># Count non-NaNs per watershed/week</span>
    <span class="n">weekly_counts</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;week&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">))</span>

    <span class="c1"># Boolean: weeks with ≥3 days of data</span>
    <span class="n">weekly_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">weekly_counts</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;watershed&quot;</span><span class="p">,</span> <span class="s2">&quot;week&quot;</span><span class="p">)</span>
    <span class="n">week_dt</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">weekly_mask</span><span class="p">[</span><span class="s1">&#39;week&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> 
    <span class="c1"># Convert to float and flip for plotting</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">weekly_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="c1">#[::-1, :]</span>

    <span class="n">watershed_ids</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">watershed</span><span class="o">.</span><span class="n">values</span>
    <span class="n">x_start</span><span class="p">,</span> <span class="n">x_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">watershed_ids</span><span class="p">)</span>
    <span class="n">y_start</span><span class="p">,</span> <span class="n">y_end</span> <span class="o">=</span> <span class="n">week_dt</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">week_dt</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">output_file</span><span class="p">(</span><span class="s2">&quot;images/weekly_data_availability_matrix.html&quot;</span><span class="p">)</span>
    <span class="c1"># Assume weekly_mask is a DataArray: dimensions (&#39;watershed&#39;, &#39;week&#39;)</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">weekly_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># shape: (ny, nx)</span>

    <span class="c1"># Get the datetime values for the weekly bins</span>
    <span class="n">week_dt</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">weekly_mask</span><span class="p">[</span><span class="s1">&#39;week&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>  <span class="c1"># len = nx</span>
    <span class="n">watersheds</span> <span class="o">=</span> <span class="n">weekly_mask</span><span class="p">[</span><span class="s1">&#39;watershed&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>          <span class="c1"># len = ny</span>


    <span class="n">p</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span>
        <span class="n">width</span><span class="o">=</span><span class="mi">1200</span><span class="p">,</span>
        <span class="n">height</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
        <span class="n">y_axis_type</span><span class="o">=</span><span class="s2">&quot;datetime&quot;</span><span class="p">,</span>
        <span class="n">y_range</span><span class="o">=</span><span class="p">(</span><span class="n">week_dt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">week_dt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">x_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">watersheds</span><span class="p">)),</span>
        <span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="c1"># toolbar_location=None,</span>
        <span class="c1"># title=&quot;Weekly Data Availability Matrix (≥3 days/week)&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Define color mapper</span>
    <span class="n">mapper</span> <span class="o">=</span> <span class="n">LinearColorMapper</span><span class="p">(</span><span class="n">palette</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;#ffffff&quot;</span><span class="p">,</span> <span class="s2">&quot;#444444&quot;</span><span class="p">],</span> <span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Use image glyph; Bokeh handles datetime x when x is a datetime64</span>
    <span class="n">p</span><span class="o">.</span><span class="n">image</span><span class="p">(</span>
        <span class="n">image</span><span class="o">=</span><span class="p">[</span><span class="n">img</span><span class="p">],</span>
        <span class="n">y</span><span class="o">=</span><span class="n">week_dt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">dh</span><span class="o">=</span><span class="p">(</span><span class="n">week_dt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">week_dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="c1">#.astype(&#39;timedelta64[D]&#39;).astype(int),  # width in days</span>
        <span class="n">dw</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">watersheds</span><span class="p">),</span>
        <span class="n">color_mapper</span><span class="o">=</span><span class="n">mapper</span>
    <span class="p">)</span>

    <span class="c1"># Format ticks to show only years</span>
    <span class="c1"># p.xaxis.formatter = DatetimeTickFormatter(years=&quot;%Y&quot;)</span>

    <span class="c1"># Minimalist style</span>
    <span class="n">p</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="s1">&#39;Watershed ID&#39;</span>
    <span class="n">p</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="s1">&#39;Date&#39;</span>
    <span class="n">p</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">visible</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">p</span><span class="o">.</span><span class="n">outline_line_color</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">save</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">processed</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">stn</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">official_ids</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
    <span class="n">runner</span> <span class="o">=</span> <span class="n">PDFEstimatorRunner</span><span class="p">(</span><span class="n">stn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">methods</span><span class="p">,</span> <span class="n">k_nearest</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_to_check</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">runner</span><span class="o">.</span><span class="n">run_selected</span><span class="p">()</span>
    <span class="n">processed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="n">elapsed</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="n">unit_time</span> <span class="o">=</span> <span class="n">elapsed</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Processed </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">official_ids</span><span class="p">)</span><span class="si">}</span><span class="s1"> stations in </span><span class="si">{</span><span class="n">unit_time</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds per station&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">AttributeError</span><span class="g g-Whitespace">                            </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">94</span><span class="p">],</span> <span class="n">line</span> <span class="mi">3</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="n">processed</span> <span class="o">=</span> <span class="p">[]</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
<span class="ne">----&gt; </span><span class="mi">3</span> <span class="k">for</span> <span class="n">stn</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">official_ids</span><span class="p">:</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span>     <span class="nb">print</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">5</span>     <span class="n">runner</span> <span class="o">=</span> <span class="n">PDFEstimatorRunner</span><span class="p">(</span><span class="n">stn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">methods</span><span class="p">,</span> <span class="n">k_nearest</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_to_check</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="ne">AttributeError</span>: &#39;FDCEstimationContext&#39; object has no attribute &#39;official_ids&#39;
</pre></div>
</div>
</div>
</div>
<section id="kernel-density-estimator-in-1d">
<h2>Kernel Density Estimator in 1D<a class="headerlink" href="#kernel-density-estimator-in-1d" title="Link to this heading">#</a></h2>
<div class="math notranslate nohighlight">
\[\hat g (x) = \frac{1}{N} \sum_{i=1}^{N} \frac{1}{h(x_i)} K \left[ \frac{x-x_i}{h(x_i)} \right]\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(N\)</span> is the number of data points</p></li>
<li><p><span class="math notranslate nohighlight">\(x_i\)</span> is the <span class="math notranslate nohighlight">\(i^\text{th}\)</span> data point</p></li>
<li><p><span class="math notranslate nohighlight">\(K(x)\)</span> is the kernel function, normalized to 1.</p></li>
<li><p><span class="math notranslate nohighlight">\(h\)</span> is the bandwidth, in this case it is a function of x.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># plot the measurement error:</span>

<span class="n">efig</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Estimated Measurement Error Model&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">x_axis_type</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">error_points</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1e-4</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e-1</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1e1</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">,</span> <span class="mf">1e3</span><span class="p">,</span> <span class="mf">1e4</span><span class="p">,</span> <span class="mf">1e5</span><span class="p">])</span>  <span class="c1">#  Reference flow points in m^3/s</span>
<span class="n">error_values</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>
<span class="n">efig</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">error_points</span><span class="p">,</span> <span class="n">error_values</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;Measurement Error Model&#39;</span><span class="p">)</span>
<span class="n">efig</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$$\text{Flow } m^3/s$$&#39;</span>
<span class="n">efig</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$$\text{Error } [\text</span><span class="si">{x}</span><span class="s1">100\%]$$&#39;</span>
<span class="n">efig</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">background_fill_alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">efig</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">format_fig_fonts</span><span class="p">(</span><span class="n">efig</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

<span class="n">layout</span> <span class="o">=</span> <span class="n">gridplot</span><span class="p">([</span><span class="n">efig</span><span class="p">],</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">350</span><span class="p">)</span>
<span class="n">show</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notebooks/ss"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#kernel-density-estimator-in-1d">Kernel Density Estimator in 1D</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Dan Kovacek
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>