
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>5. FDC Estimation &#8212; Streamflow Distribution Estimation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/5_FDC_Estimation';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6. Large Sample Comparison Results" href="6_Large_Sample_Results_Comparison.html" />
    <link rel="prev" title="4. Reference Distributions" href="4_Reference_Distributions.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Streamflow Distribution Estimation - Home"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Streamflow Distribution Estimation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Introduction
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="1_data.html">1. Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_Methods.html">2. Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_Predict_Runoff_Statistics.html">3. Predict Runoff Statistics from Catchment Attributes</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_Reference_Distributions.html">4. Reference Distributions</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">5. FDC Estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="6_Large_Sample_Results_Comparison.html">6. Large Sample Comparison Results</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/dankovacek/divergence_estimation" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/dankovacek/divergence_estimation/issues/new?title=Issue%20on%20page%20%2Fnotebooks/5_FDC_Estimation.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/notebooks/5_FDC_Estimation.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>FDC Estimation</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#non-parametric-simulation">5.1. Non-Parametric Simulation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#time-based-ensemble">5.1.1. Time-based ensemble</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#frequency-based-ensembles">5.1.2. Frequency-based ensembles</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#notes-on-k-nearest-neighbours">5.2. Notes on k-nearest neighbours</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#summary-set-theoretic-foundations-of-strict-k-nn-concurrency-selection">5.2.1. Summary: Set-Theoretic Foundations of Strict k-NN Concurrency Selection</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#set-theoretic-definition">5.2.1.1. Set-Theoretic Definition</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#related-concepts">5.2.1.2. Related Concepts</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#practical-implication">5.2.1.3. Practical Implication</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#define-a-universal-parametric-prior">5.3. Define a universal parametric prior</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#global-uniform-prior">5.3.1. Global Uniform Prior</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="fdc-estimation">
<h1><span class="section-number">5. </span>FDC Estimation<a class="headerlink" href="#fdc-estimation" title="Link to this heading">#</a></h1>
<p>This notebook contains the main code for computing FDCs by the different methods.</p>
<p>It requires the runoff statistics to have been computed, and the results of the XGBoost prediction model (catchment attributes <span class="math notranslate nohighlight">\(\rightarrow\)</span> hydrologic signatures / runoff statistics) to have been processed in Notebook 3.  It also requires the pre-processing of reference (baseline) distributions by KDE for validation from Notebook 4.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">time</span><span class="w"> </span><span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">xgboost</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xgb</span>
<span class="n">xgb</span><span class="o">.</span><span class="n">config_context</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">laplace</span><span class="p">,</span> <span class="n">genextreme</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">cpu_count</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">jax</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">jax.numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">jnp</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">kde_estimator</span><span class="w"> </span><span class="kn">import</span> <span class="n">KDEEstimator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">fdc_estimator_context</span><span class="w"> </span><span class="kn">import</span> <span class="n">FDCEstimationContext</span> 
<span class="kn">from</span><span class="w"> </span><span class="nn">fdc_data</span><span class="w"> </span><span class="kn">import</span> <span class="n">StationData</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">evaluation_metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">EvaluationMetrics</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">data_processing_functions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dpf</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="n">BASE_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">bokeh.plotting</span><span class="w"> </span><span class="kn">import</span> <span class="n">figure</span><span class="p">,</span> <span class="n">show</span><span class="p">,</span> <span class="n">output_notebook</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bokeh.layouts</span><span class="w"> </span><span class="kn">import</span> <span class="n">gridplot</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">xyzservices.providers</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xyz</span>
<span class="n">tiles</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;USGS&#39;</span><span class="p">][</span><span class="s1">&#39;USTopo&#39;</span><span class="p">]</span>
<span class="n">output_notebook</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">    <style>
        .bk-notebook-logo {
            display: block;
            width: 20px;
            height: 20px;
            background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAOkSURBVDiNjZRtaJVlGMd/1/08zzln5zjP1LWcU9N0NkN8m2CYjpgQYQXqSs0I84OLIC0hkEKoPtiH3gmKoiJDU7QpLgoLjLIQCpEsNJ1vqUOdO7ppbuec5+V+rj4ctwzd8IIbbi6u+8f1539dt3A78eXC7QizUF7gyV1fD1Yqg4JWz84yffhm0qkFqBogB9rM8tZdtwVsPUhWhGcFJngGeWrPzHm5oaMmkfEg1usvLFyc8jLRqDOMru7AyC8saQr7GG7f5fvDeH7Ej8CM66nIF+8yngt6HWaKh7k49Soy9nXurCi1o3qUbS3zWfrYeQDTB/Qj6kX6Ybhw4B+bOYoLKCC9H3Nu/leUTZ1JdRWkkn2ldcCamzrcf47KKXdAJllSlxAOkRgyHsGC/zRday5Qld9DyoM4/q/rUoy/CXh3jzOu3bHUVZeU+DEn8FInkPBFlu3+nW3Nw0mk6vCDiWg8CeJaxEwuHS3+z5RgY+YBR6V1Z1nxSOfoaPa4LASWxxdNp+VWTk7+4vzaou8v8PN+xo+KY2xsw6une2frhw05CTYOmQvsEhjhWjn0bmXPjpE1+kplmmkP3suftwTubK9Vq22qKmrBhpY4jvd5afdRA3wGjFAgcnTK2s4hY0/GPNIb0nErGMCRxWOOX64Z8RAC4oCXdklmEvcL8o0BfkNK4lUg9HTl+oPlQxdNo3Mg4Nv175e/1LDGzZen30MEjRUtmXSfiTVu1kK8W4txyV6BMKlbgk3lMwYCiusNy9fVfvvwMxv8Ynl6vxoByANLTWplvuj/nF9m2+PDtt1eiHPBr1oIfhCChQMBw6Aw0UulqTKZdfVvfG7VcfIqLG9bcldL/+pdWTLxLUy8Qq38heUIjh4XlzZxzQm19lLFlr8vdQ97rjZVOLf8nclzckbcD4wxXMidpX30sFd37Fv/GtwwhzhxGVAprjbg0gCAEeIgwCZyTV2Z1REEW8O4py0wsjeloKoMr6iCY6dP92H6Vw/oTyICIthibxjm/DfN9lVz8IqtqKYLUXfoKVMVQVVJOElGjrnnUt9T9wbgp8AyYKaGlqingHZU/uG2NTZSVqwHQTWkx9hxjkpWDaCg6Ckj5qebgBVbT3V3NNXMSiWSDdGV3hrtzla7J+duwPOToIg42ChPQOQjspnSlp1V+Gjdged7+8UN5CRAV7a5EdFNwCjEaBR27b3W890TE7g24NAP/mMDXRWrGoFPQI9ls/MWO2dWFAar/xcOIImbbpA3zgAAAABJRU5ErkJggg==);
        }
    </style>
    <div>
        <a href="https://bokeh.org" target="_blank" class="bk-notebook-logo"></a>
        <span id="b83decab-536b-4a8d-9275-9e297827a1c7">Loading BokehJS ...</span>
    </div>
</div><script type="application/javascript">'use strict';
(function(root) {
  function now() {
    return new Date();
  }

  const force = true;

  if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
    root._bokeh_onload_callbacks = [];
    root._bokeh_is_loading = undefined;
  }

const JS_MIME_TYPE = 'application/javascript';
  const HTML_MIME_TYPE = 'text/html';
  const EXEC_MIME_TYPE = 'application/vnd.bokehjs_exec.v0+json';
  const CLASS_NAME = 'output_bokeh rendered_html';

  /**
   * Render data to the DOM node
   */
  function render(props, node) {
    const script = document.createElement("script");
    node.appendChild(script);
  }

  /**
   * Handle when an output is cleared or removed
   */
  function handleClearOutput(event, handle) {
    function drop(id) {
      const view = Bokeh.index.get_by_id(id)
      if (view != null) {
        view.model.document.clear()
        Bokeh.index.delete(view)
      }
    }

    const cell = handle.cell;

    const id = cell.output_area._bokeh_element_id;
    const server_id = cell.output_area._bokeh_server_id;

    // Clean up Bokeh references
    if (id != null) {
      drop(id)
    }

    if (server_id !== undefined) {
      // Clean up Bokeh references
      const cmd_clean = "from bokeh.io.state import curstate; print(curstate().uuid_to_server['" + server_id + "'].get_sessions()[0].document.roots[0]._id)";
      cell.notebook.kernel.execute(cmd_clean, {
        iopub: {
          output: function(msg) {
            const id = msg.content.text.trim()
            drop(id)
          }
        }
      });
      // Destroy server and session
      const cmd_destroy = "import bokeh.io.notebook as ion; ion.destroy_server('" + server_id + "')";
      cell.notebook.kernel.execute(cmd_destroy);
    }
  }

  /**
   * Handle when a new output is added
   */
  function handleAddOutput(event, handle) {
    const output_area = handle.output_area;
    const output = handle.output;

    // limit handleAddOutput to display_data with EXEC_MIME_TYPE content only
    if ((output.output_type != "display_data") || (!Object.prototype.hasOwnProperty.call(output.data, EXEC_MIME_TYPE))) {
      return
    }

    const toinsert = output_area.element.find("." + CLASS_NAME.split(' ')[0]);

    if (output.metadata[EXEC_MIME_TYPE]["id"] !== undefined) {
      toinsert[toinsert.length - 1].firstChild.textContent = output.data[JS_MIME_TYPE];
      // store reference to embed id on output_area
      output_area._bokeh_element_id = output.metadata[EXEC_MIME_TYPE]["id"];
    }
    if (output.metadata[EXEC_MIME_TYPE]["server_id"] !== undefined) {
      const bk_div = document.createElement("div");
      bk_div.innerHTML = output.data[HTML_MIME_TYPE];
      const script_attrs = bk_div.children[0].attributes;
      for (let i = 0; i < script_attrs.length; i++) {
        toinsert[toinsert.length - 1].firstChild.setAttribute(script_attrs[i].name, script_attrs[i].value);
        toinsert[toinsert.length - 1].firstChild.textContent = bk_div.children[0].textContent
      }
      // store reference to server id on output_area
      output_area._bokeh_server_id = output.metadata[EXEC_MIME_TYPE]["server_id"];
    }
  }

  function register_renderer(events, OutputArea) {

    function append_mime(data, metadata, element) {
      // create a DOM node to render to
      const toinsert = this.create_output_subarea(
        metadata,
        CLASS_NAME,
        EXEC_MIME_TYPE
      );
      this.keyboard_manager.register_events(toinsert);
      // Render to node
      const props = {data: data, metadata: metadata[EXEC_MIME_TYPE]};
      render(props, toinsert[toinsert.length - 1]);
      element.append(toinsert);
      return toinsert
    }

    /* Handle when an output is cleared or removed */
    events.on('clear_output.CodeCell', handleClearOutput);
    events.on('delete.Cell', handleClearOutput);

    /* Handle when a new output is added */
    events.on('output_added.OutputArea', handleAddOutput);

    /**
     * Register the mime type and append_mime function with output_area
     */
    OutputArea.prototype.register_mime_type(EXEC_MIME_TYPE, append_mime, {
      /* Is output safe? */
      safe: true,
      /* Index of renderer in `output_area.display_order` */
      index: 0
    });
  }

  // register the mime type if in Jupyter Notebook environment and previously unregistered
  if (root.Jupyter !== undefined) {
    const events = require('base/js/events');
    const OutputArea = require('notebook/js/outputarea').OutputArea;

    if (OutputArea.prototype.mime_types().indexOf(EXEC_MIME_TYPE) == -1) {
      register_renderer(events, OutputArea);
    }
  }
  if (typeof (root._bokeh_timeout) === "undefined" || force === true) {
    root._bokeh_timeout = Date.now() + 5000;
    root._bokeh_failed_load = false;
  }

  const NB_LOAD_WARNING = {'data': {'text/html':
     "<div style='background-color: #fdd'>\n"+
     "<p>\n"+
     "BokehJS does not appear to have successfully loaded. If loading BokehJS from CDN, this \n"+
     "may be due to a slow or bad network connection. Possible fixes:\n"+
     "</p>\n"+
     "<ul>\n"+
     "<li>re-rerun `output_notebook()` to attempt to load from CDN again, or</li>\n"+
     "<li>use INLINE resources instead, as so:</li>\n"+
     "</ul>\n"+
     "<code>\n"+
     "from bokeh.resources import INLINE\n"+
     "output_notebook(resources=INLINE)\n"+
     "</code>\n"+
     "</div>"}};

  function display_loaded(error = null) {
    const el = document.getElementById("b83decab-536b-4a8d-9275-9e297827a1c7");
    if (el != null) {
      const html = (() => {
        if (typeof root.Bokeh === "undefined") {
          if (error == null) {
            return "BokehJS is loading ...";
          } else {
            return "BokehJS failed to load.";
          }
        } else {
          const prefix = `BokehJS ${root.Bokeh.version}`;
          if (error == null) {
            return `${prefix} successfully loaded.`;
          } else {
            return `${prefix} <b>encountered errors</b> while loading and may not function as expected.`;
          }
        }
      })();
      el.innerHTML = html;

      if (error != null) {
        const wrapper = document.createElement("div");
        wrapper.style.overflow = "auto";
        wrapper.style.height = "5em";
        wrapper.style.resize = "vertical";
        const content = document.createElement("div");
        content.style.fontFamily = "monospace";
        content.style.whiteSpace = "pre-wrap";
        content.style.backgroundColor = "rgb(255, 221, 221)";
        content.textContent = error.stack ?? error.toString();
        wrapper.append(content);
        el.append(wrapper);
      }
    } else if (Date.now() < root._bokeh_timeout) {
      setTimeout(() => display_loaded(error), 100);
    }
  }

  function run_callbacks() {
    try {
      root._bokeh_onload_callbacks.forEach(function(callback) {
        if (callback != null)
          callback();
      });
    } finally {
      delete root._bokeh_onload_callbacks
    }
    console.debug("Bokeh: all callbacks have finished");
  }

  function load_libs(css_urls, js_urls, callback) {
    if (css_urls == null) css_urls = [];
    if (js_urls == null) js_urls = [];

    root._bokeh_onload_callbacks.push(callback);
    if (root._bokeh_is_loading > 0) {
      console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
      return null;
    }
    if (js_urls == null || js_urls.length === 0) {
      run_callbacks();
      return null;
    }
    console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
    root._bokeh_is_loading = css_urls.length + js_urls.length;

    function on_load() {
      root._bokeh_is_loading--;
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
        run_callbacks()
      }
    }

    function on_error(url) {
      console.error("failed to load " + url);
    }

    for (let i = 0; i < css_urls.length; i++) {
      const url = css_urls[i];
      const element = document.createElement("link");
      element.onload = on_load;
      element.onerror = on_error.bind(null, url);
      element.rel = "stylesheet";
      element.type = "text/css";
      element.href = url;
      console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
      document.body.appendChild(element);
    }

    for (let i = 0; i < js_urls.length; i++) {
      const url = js_urls[i];
      const element = document.createElement('script');
      element.onload = on_load;
      element.onerror = on_error.bind(null, url);
      element.async = false;
      element.src = url;
      console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
      document.head.appendChild(element);
    }
  };

  function inject_raw_css(css) {
    const element = document.createElement("style");
    element.appendChild(document.createTextNode(css));
    document.body.appendChild(element);
  }

  const js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-3.7.3.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-3.7.3.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-3.7.3.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-3.7.3.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-mathjax-3.7.3.min.js"];
  const css_urls = [];

  const inline_js = [    function(Bokeh) {
      Bokeh.set_log_level("info");
    },
function(Bokeh) {
    }
  ];

  function run_inline_js() {
    if (root.Bokeh !== undefined || force === true) {
      try {
            for (let i = 0; i < inline_js.length; i++) {
      inline_js[i].call(root, root.Bokeh);
    }

      } catch (error) {display_loaded(error);throw error;
      }if (force === true) {
        display_loaded();
      }} else if (Date.now() < root._bokeh_timeout) {
      setTimeout(run_inline_js, 100);
    } else if (!root._bokeh_failed_load) {
      console.log("Bokeh: BokehJS failed to load within specified timeout.");
      root._bokeh_failed_load = true;
    } else if (force !== true) {
      const cell = $(document.getElementById("b83decab-536b-4a8d-9275-9e297827a1c7")).parents('.cell').data().cell;
      cell.output_area.append_execute_result(NB_LOAD_WARNING)
    }
  }

  if (root._bokeh_is_loading === 0) {
    console.debug("Bokeh: BokehJS loaded, going straight to plotting");
    run_inline_js();
  } else {
    load_libs(css_urls, js_urls, function() {
      console.debug("Bokeh: BokehJS plotting callback run at", now());
      run_inline_js();
    });
  }
}(window));</script></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># load the catchment characteristics</span>
<span class="n">fname</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;catchment_attributes_with_runoff_stats.csv&#39;</span>
<span class="n">attr_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">fname</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;official_id&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;drainage_area_km2&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">})</span>
<span class="n">attr_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">attr_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
<span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;log_drainage_area_km2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;drainage_area_km2&#39;</span><span class="p">])</span>
<span class="c1"># attr_df = attr_df[~attr_df[&#39;official_id&#39;].isin(exclude)]</span>
<span class="c1"># attr_df.columns = [c.lower() for c in attr_df.columns]</span>
<span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;tmean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;tmin&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;tmax&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
<span class="n">station_ids</span> <span class="o">=</span> <span class="n">attr_df</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
<span class="c1"># assert &#39;12414900&#39; in station_ids</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">station_ids</span><span class="p">)</span><span class="si">}</span><span class="s1"> monitored basins in the attribute set.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>There are 1098 monitored basins in the attribute set.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># streamflow folder from (updated) HYSETS</span>
<span class="n">HYSETS_DIR</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;/home/danbot/code/common_data/HYSETS&#39;</span><span class="p">)</span>
<span class="c1"># STREAMFLOW_DIR = HYSETS_DIR / &#39;streamflow&#39;</span>

<span class="n">hs_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;data/HYSETS_watershed_properties.txt&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})</span>
<span class="n">hs_df</span> <span class="o">=</span> <span class="n">hs_df</span><span class="p">[</span><span class="n">hs_df</span><span class="p">[</span><span class="s1">&#39;Official_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">station_ids</span><span class="p">)]</span>
<span class="n">hs_df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Watershed_ID</th>
      <th>Source</th>
      <th>Name</th>
      <th>Official_ID</th>
      <th>Centroid_Lat_deg_N</th>
      <th>Centroid_Lon_deg_E</th>
      <th>Drainage_Area_km2</th>
      <th>Drainage_Area_GSIM_km2</th>
      <th>Flag_GSIM_boundaries</th>
      <th>Flag_Artificial_Boundaries</th>
      <th>...</th>
      <th>Land_Use_Wetland_frac</th>
      <th>Land_Use_Water_frac</th>
      <th>Land_Use_Urban_frac</th>
      <th>Land_Use_Shrubs_frac</th>
      <th>Land_Use_Crops_frac</th>
      <th>Land_Use_Snow_Ice_frac</th>
      <th>Flag_Land_Use_Extraction</th>
      <th>Permeability_logk_m2</th>
      <th>Porosity_frac</th>
      <th>Flag_Subsoil_Extraction</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>846</th>
      <td>847</td>
      <td>HYDAT</td>
      <td>CROWSNEST RIVER AT FRANK</td>
      <td>05AA008</td>
      <td>49.59732</td>
      <td>-114.4106</td>
      <td>402.6522</td>
      <td>NaN</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0.0103</td>
      <td>0.0065</td>
      <td>0.0328</td>
      <td>0.0785</td>
      <td>0.0015</td>
      <td>0.0002</td>
      <td>1</td>
      <td>-15.543306</td>
      <td>0.170479</td>
      <td>1</td>
    </tr>
    <tr>
      <th>849</th>
      <td>850</td>
      <td>HYDAT</td>
      <td>CASTLE RIVER NEAR BEAVER MINES</td>
      <td>05AA022</td>
      <td>49.48866</td>
      <td>-114.1444</td>
      <td>820.6510</td>
      <td>NaN</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0.0058</td>
      <td>0.0023</td>
      <td>0.0105</td>
      <td>0.1156</td>
      <td>0.0246</td>
      <td>0.0000</td>
      <td>1</td>
      <td>-15.929747</td>
      <td>0.150196</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>2 rows Ã— 29 columns</p>
</div></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># load the baseline PMFs from the previous notebook</span>
<span class="n">pmf_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span> <span class="o">/</span> <span class="s1">&#39;data&#39;</span> <span class="o">/</span> <span class="s1">&#39;results&#39;</span> <span class="o">/</span> <span class="s1">&#39;baseline_distributions&#39;</span> <span class="o">/</span> <span class="sa">f</span><span class="s1">&#39;bcub_pmfs.csv&#39;</span>
<span class="n">pmf_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">pmf_path</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">pmf_stations</span> <span class="o">=</span> <span class="n">pmf_df</span><span class="o">.</span><span class="n">columns</span>
<span class="n">station_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">station_ids</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pmf_stations</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">station_ids</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1097
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># retrieve LSTM ensemble predictions</span>
<span class="n">lstm_result_folder</span> <span class="o">=</span> <span class="s1">&#39;/home/danbot/code/neuralhydrology/data/ensemble_results_20250514&#39;</span>
<span class="n">lstm_result_files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">lstm_result_folder</span><span class="p">)</span>
<span class="n">lstm_result_stns</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">lstm_result_files</span><span class="p">]</span>
<span class="k">assert</span> <span class="s1">&#39;12414900&#39;</span> <span class="ow">in</span> <span class="n">lstm_result_stns</span>

<span class="c1"># find any non-matching station ids in the lstm result files</span>
<span class="k">for</span> <span class="n">stn</span> <span class="ow">in</span> <span class="n">lstm_result_stns</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">stn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">station_ids</span><span class="p">:</span>
        <span class="c1"># try adding a leading zero</span>
        <span class="n">ending_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">station_ids</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">stn</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ending_in</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">stn</span><span class="p">,</span> <span class="s1">&#39;matches&#39;</span><span class="p">,</span> <span class="n">ending_in</span><span class="p">)</span>
        <span class="n">modified_stn</span> <span class="o">=</span> <span class="n">stn</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">modified_stn</span> <span class="ow">in</span> <span class="n">station_ids</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found modified station id: </span><span class="si">{</span><span class="n">modified_stn</span><span class="si">}</span><span class="s1"> for </span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Warning: </span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1"> is in LSTM results but not in the station attributes.&#39;</span><span class="p">)</span>

<span class="c1"># filter for the common stations between BCUB region and LSTM-compatible (i.e. 1980-)</span>
<span class="n">daymet_concurrent_stations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">station_ids</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">lstm_result_stns</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">pmf_stations</span><span class="p">))</span>
<span class="c1"># assert &#39;12414900&#39; in daymet_concurrent_stations</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">daymet_concurrent_stations</span><span class="p">)</span><span class="si">}</span><span class="s1"> monitored basins concurrent with LSTM ensemble results.&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">pmf_stations</span><span class="p">)</span><span class="si">}</span><span class="s1"> monitored basins with baseline PMFs.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Warning: 12414900 is in LSTM results but not in the station attributes.
Warning: 15056030 is in LSTM results but not in the station attributes.
There are 723 monitored basins concurrent with LSTM ensemble results.
There are 1097 monitored basins with baseline PMFs.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># import updated catchment polygons</span>
<span class="c1"># poly_fpath = os.path.join(os.path.join(&#39;data&#39;, f&#39;BCUB_watershed_attributes_updated_{rev_date}.csv&#39;))</span>
<span class="c1"># catchment_gdf = pd.read_csv(poly_fpath)</span>
<span class="c1"># catchment</span>
<span class="c1"># catchment_gdf = catchment_gdf[catchment_gdf[&#39;Official_ID&#39;].isin(station_ids)]</span>
<span class="c1"># print(len(catchment_gdf), &#39;catchments in the polygon set&#39;)</span>

<span class="c1"># import the license water extraction points</span>
<span class="c1"># dam_gdf = gpd.read_file(&#39;data/Dam_Points_20240103.gpkg&#39;)</span>
<span class="c1"># assert dam_gdf.crs == catchment_gdf.crs, &quot;Catchment and dam geometries must have the same CRS&quot;</span>
<span class="c1"># joined = gpd.sjoin(catchment_gdf, dam_gdf, how=&quot;inner&quot;, predicate=&quot;contains&quot;)</span>
<span class="c1"># Create a new boolean column &#39;contains_dam&#39; in catchment_gdf.</span>
<span class="c1"># If a polygon&#39;s index appears in the joined result, it means it contains at least one point.</span>
<span class="c1"># regulated = joined[&#39;Official_ID&#39;].values</span>
<span class="c1"># catchment_gdf[&quot;contains_dam&quot;] = catchment_gdf[&#39;Official_ID&#39;].apply(lambda x: x in regulated)</span>
<span class="c1"># n_regulated = catchment_gdf[&#39;contains_dam&#39;].sum()</span>
<span class="c1"># print(f&#39;{n_regulated}/{len(catchment_gdf)} catchments contain withdrawal licenses&#39;)</span>

<span class="c1"># # create dicts for easier access to &#39;official_id&#39;: &#39;drainage area&#39;, geometry, regulation status</span>
<span class="c1"># da_dict = attr_df[[&#39;official_id&#39;, &#39;drainage_area_km2&#39;]].copy().set_index(&#39;official_id&#39;).to_dict()[&#39;drainage_area_km2&#39;]</span>
<span class="c1"># dam_dict = catchment_gdf[[&#39;Official_ID&#39;, &#39;contains_dam&#39;]].copy().set_index(&#39;Official_ID&#39;).to_dict()[&#39;contains_dam&#39;]</span>
<span class="c1"># polygon_dict = catchment_gdf[[&#39;Official_ID&#39;, &#39;geometry&#39;]].copy().set_index(&#39;Official_ID&#39;).to_dict()[&#39;geometry&#39;]</span>

<span class="c1"># # add the centroid point geometry to the attributes dataframe</span>
<span class="c1"># attr_df = attr_df[attr_df[&#39;official_id&#39;].isin(catchment_gdf[&#39;Official_ID&#39;].values)].copy()</span>
<span class="c1"># centroids = attr_df.apply(lambda x: polygon_dict[x[&#39;official_id&#39;]].centroid, axis=1)</span>
<span class="c1"># attr_gdf = gpd.GeoDataFrame(attr_df, geometry=centroids, crs=catchment_gdf.crs)</span>
<span class="c1"># attr_gdf[&quot;contains_dam&quot;] = attr_gdf[&#39;official_id&#39;].apply(lambda x: dam_dict[x] if x in dam_dict else False)</span>
<span class="c1"># add the concurrency status as a boolean column</span>
<span class="c1"># attr_df[&#39;LSTM_concurrent&#39;] = attr_df[&#39;official_id&#39;].apply(lambda x: x in daymet_concurrent_stations)</span>
<span class="c1"># attr_df.reset_index(inplace=True, drop=True)</span>
<span class="c1"># print(f&#39;N network stations={len(attr_df)}&#39;)</span>
</pre></div>
</div>
</div>
</div>
<section id="non-parametric-simulation">
<h2><span class="section-number">5.1. </span>Non-Parametric Simulation<a class="headerlink" href="#non-parametric-simulation" title="Link to this heading">#</a></h2>
<section id="time-based-ensemble">
<h3><span class="section-number">5.1.1. </span>Time-based ensemble<a class="headerlink" href="#time-based-ensemble" title="Link to this heading">#</a></h3>
<p>A probability distribution <span class="math notranslate nohighlight">\(\hat p = f(\tilde x(t))\)</span> is estimated for a target (ungauged location) by a weighted mean of runoff time-series from k nearest neighbour stations, <span class="math notranslate nohighlight">\(\tilde x(t) = \textbf{X}(t)\cdot w\)</span> where <span class="math notranslate nohighlight">\(X(t) \in \mathbb{R}^{N \times k}\)</span> and <span class="math notranslate nohighlight">\(w \in \mathbb{R}^{k\times 1}\)</span> is a vector of k weights.  So <span class="math notranslate nohighlight">\(\hat p = f(\textbf{X}(t) \cdot w )\)</span>  Weights <span class="math notranslate nohighlight">\(w\)</span> are computed in three ways, described in the next subsection, and k-nearest neighbours are selected using the criteria defined below.  Each gauged station in the monitoring network is treated as an ungauged location to generate a large sample of simulations across hydrologically diverse catchments, or rather as many catchments as can be tested.</p>
</section>
<section id="frequency-based-ensembles">
<h3><span class="section-number">5.1.2. </span>Frequency-based ensembles<a class="headerlink" href="#frequency-based-ensembles" title="Link to this heading">#</a></h3>
<p>A simulated probability density function is estimated from observations of k nearest neighbour stations.  First, k simulated series are generated by equal unit area runoff , <span class="math notranslate nohighlight">\(\hat p = \hat P \cdot w\)</span> where <span class="math notranslate nohighlight">\(\hat P = [\hat p_1, \hat p_2, \cdots, \hat p_k]\)</span> and each <span class="math notranslate nohighlight">\(\hat p_i = f(X_i(t))\)</span>.</p>
<p>In both cases, the function <span class="math notranslate nohighlight">\(f \rightarrow \hat p(x)\)</span> represents kernel density estimation, which defines the probability density as $<span class="math notranslate nohighlight">\(\hat p(x) = \frac{1}{n \cdot h(x)} \sum_{i=1}^{n}K\left( \frac{x-x_i}{h(x)}\right)\)</span>$</p>
<p>Where <span class="math notranslate nohighlight">\(h(x)\)</span> reflects an adaptive kernel bandwidth that addresses vestiges of precision in the observed data to reflect the nature of streamflow as a continuous variable, and additionally incorporates piecewise linear model to represent overall measurement uncertainty.</p>
</section>
</section>
<section id="notes-on-k-nearest-neighbours">
<h2><span class="section-number">5.2. </span>Notes on k-nearest neighbours<a class="headerlink" href="#notes-on-k-nearest-neighbours" title="Link to this heading">#</a></h2>
<p>Time series streamflow records vary widely in their temporal coverage, and finding k-nearest neighbours presents a tradeoff between selecting nearest neighbours and maximizing the number of observations concurrent with the target.  From the literature, concurrency is assured by pre-selecting a subset of stations with continuous records over a common period of record, or by infilling gaps with k-nearest neighbours simulation.  Some kind of tradeoff must be made, and we aim to use a method that maximizes information content while minimizing the number of assumptions.  The following notes are intended to clarify the implications of using k-nearest neighbours to fill gaps in the time series.</p>
<ol class="arabic simple">
<li><p><strong>Infilled-by-kNN != Independent Proxy</strong>: If a gap in an observation record is inferred from neighbors, it becomes redundant in the ensemble and increases the weight of the other (k minus n) neighbours.  So at that time step, its influence is non-unique, and including it in the ensemble is functionally equivalent to using the same set of other proxies directly, or just reducing the ensemble size.</p></li>
<li><p><strong>Inflated Ensemble Size</strong>: Filling gaps by â€œnestedâ€ k-nearest neighbours inflates the expresed number of independent neighbors.  Comparing the effectiveness of ensemble simulations as a function of k is then misleading because the effective number of independent proxies is <em>at most</em> k.</p></li>
<li><p><strong>Information leakage risk</strong>: If you repeatedly use kNN to fill missing data from within the same pool, especially when simulating extreme values, you risk suppressing variability by biasing toward the central tendency of the ensemble.  This defeats one of the core motivations for kNN: to preserve structure and variability from observations at neighboring stations.</p></li>
</ol>
<p>To address the nuance above, we propose three time-based methods for selecting k-nearest neighbours beyond strictly nodes in the network.  The problem is related to the set-cover problem where the goal is to select a subset of stations that maximizes the intersection of their data availability over a specified time period.  The following sections outline the three methods for selecting k-nearest neighbours based on availability of concurrent data.</p>
<section id="summary-set-theoretic-foundations-of-strict-k-nn-concurrency-selection">
<h3><span class="section-number">5.2.1. </span>Summary: Set-Theoretic Foundations of Strict k-NN Concurrency Selection<a class="headerlink" href="#summary-set-theoretic-foundations-of-strict-k-nn-concurrency-selection" title="Link to this heading">#</a></h3>
<p>This problem is closely related to classic combinatorial and set-theoretic optimization problems.</p>
<section id="set-theoretic-definition">
<h4><span class="section-number">5.2.1.1. </span>Set-Theoretic Definition<a class="headerlink" href="#set-theoretic-definition" title="Link to this heading">#</a></h4>
<p>Let each column <span class="math notranslate nohighlight">\(( S_i \subseteq T )\)</span> represent the set of timestamps where station <span class="math notranslate nohighlight">\(( i )\)</span> has valid (non-NaN) data.<br />
Let <span class="math notranslate nohighlight">\(( \mathcal{S} = \{ S_1, S_2, \dots, S_n \} )\)</span> be the collection of all such subsets, sorted by proximity (e.g., distance or attribute similarity).<br />
The goal is to select a subset <span class="math notranslate nohighlight">\(( \mathcal{K} \subset \mathcal{S} )\)</span> such that:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(( |\mathcal{K}| = k )\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(( \bigcap_{S \in \mathcal{K}} S )\)</span> satisfies a temporal completeness constraint (e.g., â‰¥5 years with â‰¥10 observations in each of 12 months)</p></li>
</ul>
<p>This is a constrained subset selection problem on the intersection of sets.</p>
</section>
<section id="related-concepts">
<h4><span class="section-number">5.2.1.2. </span>Related Concepts<a class="headerlink" href="#related-concepts" title="Link to this heading">#</a></h4>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Concept</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Set Intersection Selection</p></td>
<td><p>Select ( k ) sets whose intersection satisfies a completeness constraint.</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum Coverage under Cardinality Constraint</p></td>
<td><p>Choose ( k ) sets to maximize the coverage (or completeness) of their intersection.</p></td>
</tr>
<tr class="row-even"><td><p>Recursive k-Subset Validation</p></td>
<td><p>If the initial ( k ) sets fail, iteratively add more candidates and evaluate all ( \binom{k+1}{k} ) combinations, and so on.</p></td>
</tr>
<tr class="row-odd"><td><p>NP-Hard Nature</p></td>
<td><p>This problem is computationally hard and shares structure with the Set Cover and Maximum Coverage problems.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="practical-implication">
<h4><span class="section-number">5.2.1.3. </span>Practical Implication<a class="headerlink" href="#practical-implication" title="Link to this heading">#</a></h4>
<p>This formulation justifies using greedy or approximate subset selection strategies when exhaustively testing all combinations becomes computationally infeasible.</p>
</section>
</section>
</section>
<section id="define-a-universal-parametric-prior">
<h2><span class="section-number">5.3. </span>Define a universal parametric prior<a class="headerlink" href="#define-a-universal-parametric-prior" title="Link to this heading">#</a></h2>
<p>In order to fairly test how parametric and non-parametric pdf estimation methods compare to each other, we need a consistent way to deal with indeterminate cases where the simulated distribution does not provide support coverage of the â€œground truthâ€ observations.  I feel two ways about this: the KL divergence is the culprit here, and the problem could be avoided by choosing another divergence measure.  However the definintion of KL divergence in information theoretic terms of compression make it seem more foundational than other measures, but ultimately is this true?  Should we look to math statistics to make more direct links between f-divergences and what we use as a discriminant for a particular application?  Should we be more concerned about â€œBayesian consistencyâ€ of the discriminant (or surrogate loss function) with the choice of divergence measure?</p>
<ol class="arabic simple">
<li><p><strong>Quantify the distribution of unsupported mass across all models</strong>.  It is important to describe the extent of the problem across the sample <strong>and</strong> across various methods.  i.e. discrete distributions have the issue of support coverage, but so do all methods!</p></li>
<li><p>Even in kNN / ensemble simulation approaches, the problem of incomplete support coverage necessitates assuming some prior probability.  The issue is that setting a uniform prior over the observed range takes advantage of information about the observed range.</p></li>
</ol>
<section id="global-uniform-prior">
<h3><span class="section-number">5.3.1. </span>Global Uniform Prior<a class="headerlink" href="#global-uniform-prior" title="Link to this heading">#</a></h3>
<div class="math notranslate nohighlight">
\[f(x) = \frac{1}{b-a}, \quad x\in (a, b) \text{ and } f(x) = 0 \text{ otherwise.}\]</div>
<div class="math notranslate nohighlight">
\[\int_a^b f(x)\text{dx} = 1\]</div>
<p>Given the target range is a sub interval <span class="math notranslate nohighlight">\((c, d) \subseteq (a, b)\)</span>, then the <strong>total</strong> prior probability mass over (c, d) is:</p>
<div class="math notranslate nohighlight">
\[M_\text{target} = \int_c^d \frac{1}{b-a}\text{dx} = \frac{d-c}{b-a}\]</div>
<p>Over the set of intervals <span class="math notranslate nohighlight">\(\Delta x_i\)</span> covering the <strong>target range</strong>, the probability mass associated with each interval (bin) is given by:</p>
<div class="math notranslate nohighlight">
\[\Delta x_i \frac{d-c}{b-a}\]</div>
<p>A desirable property of the prior is that it reflects the strength of belief in the model (data), where a smaller prior reflects stronger belief in the data/model and vice versa.  Dividing by the number of observations has such an effect, however it also makes for very small priors.  The consequence of very small priors is they have negligible effect on models that provide complete support coverage, and they severely penalize models that do not, resulting in a form of instability.  The very small prior creates a heavy tail in the distribution of a large sample of KL divergences, with further downstream effects in optimization.</p>
<p>A method that uses a prior with negligible effect on a model with complete support coverage and a very big effect on one without can be interpreted in a few ways:</p>
<ol class="arabic simple">
<li><p>Incomplete support coverage, or underspecification, is very heavily penalized.  The method does not tolerate a model that cannot predict the full observed range.</p></li>
<li><p>A <strong>proper</strong> probability distribution sums (discrete) or integrates (continuous) to 1.  Very small probabilities are in a sense associated with a high degree of certainty since they reflect the expectation of the system being observed in a particular state.</p></li>
<li><p>The penalty of underestimating a state frequency is that storing and transmitting information about the state requires (the log ratio) more bandwidth/disk space because it is assigned a longer bit string than the actual frequency calls for under optimal encoding.</p></li>
<li><p>Assigning a very small probability to a state â€¦</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># load the predicted parameter results</span>
<span class="n">parameter_prediction_results_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;results&#39;</span><span class="p">,</span> <span class="s1">&#39;parameter_prediction_results&#39;</span><span class="p">,</span> <span class="p">)</span>
<span class="n">predicted_params_fpath</span>   <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parameter_prediction_results_folder</span><span class="p">,</span> <span class="s1">&#39;mean_parameter_predictions.csv&#39;</span><span class="p">)</span>
<span class="n">rdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">predicted_params_fpath</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;official_id&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})</span>
<span class="n">predicted_param_dict</span> <span class="o">=</span> <span class="n">rdf</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="n">predicted_param_dict</span><span class="p">[</span><span class="s1">&#39;0212414900&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>dict_keys([&#39;uar_mean_mean_predicted&#39;, &#39;uar_mean_actual&#39;, &#39;uar_std_mean_predicted&#39;, &#39;uar_std_actual&#39;, &#39;uar_median_mean_predicted&#39;, &#39;uar_median_actual&#39;, &#39;uar_mad_mean_predicted&#39;, &#39;uar_mad_actual&#39;, &#39;log_uar_mean_mean_predicted&#39;, &#39;log_uar_mean_actual&#39;, &#39;log_uar_std_mean_predicted&#39;, &#39;log_uar_std_actual&#39;, &#39;log_uar_median_mean_predicted&#39;, &#39;log_uar_median_actual&#39;, &#39;log_uar_mad_mean_predicted&#39;, &#39;log_uar_mad_actual&#39;])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plots</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">predicted_param_sample</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">al</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;log_uar_mean_mean_predicted&#39;</span><span class="p">,</span> <span class="s1">&#39;log_uar_std_mean_predicted&#39;</span><span class="p">],</span> <span class="p">[</span><span class="sa">r</span><span class="s1">&#39;$$\text{Log Mean UAR }(L/s/\text</span><span class="si">{km}</span><span class="s1">^2)$$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$$\text{Log SD UAR }(L/s/\text</span><span class="si">{km}</span><span class="s1">^2)$$&#39;</span><span class="p">]):</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">predicted_param_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="n">predicted_param_sample</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>
    <span class="c1"># plot the histogram of the mean_uar values</span>
    <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># create a scatter plot of the predicted parameter vs the target parameter</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Predicted </span><span class="si">{</span><span class="n">l</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">top</span><span class="o">=</span><span class="n">hist</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">fill_color</span><span class="o">=</span><span class="s1">&#39;lightblue&#39;</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="n">al</span>
    <span class="n">f</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$$P(x)$$&#39;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">format_fig_fonts</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">plots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="c1"># retrieve all the mean_uar values </span>

<span class="n">lt</span> <span class="o">=</span> <span class="n">gridplot</span><span class="p">(</span><span class="n">plots</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
<span class="n">show</span><span class="p">(</span><span class="n">lt</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
  <div id="d9190cac-0b45-4e70-a1df-029eeffbc492" data-root-id="p1102" style="display: contents;"></div>
</div><script type="application/javascript">(function(root) {
  function embed_document(root) {
  const docs_json = {"124e5b31-bf2d-4cbc-bb0e-9a1d3a8696cd":{"version":"3.7.3","title":"Bokeh Application","roots":[{"type":"object","name":"GridPlot","id":"p1102","attributes":{"rows":null,"cols":null,"toolbar":{"type":"object","name":"Toolbar","id":"p1101","attributes":{"tools":[{"type":"object","name":"ToolProxy","id":"p1095","attributes":{"tools":[{"type":"object","name":"PanTool","id":"p1025"},{"type":"object","name":"PanTool","id":"p1071"}]}},{"type":"object","name":"ToolProxy","id":"p1096","attributes":{"tools":[{"type":"object","name":"WheelZoomTool","id":"p1026","attributes":{"renderers":"auto"}},{"type":"object","name":"WheelZoomTool","id":"p1072","attributes":{"renderers":"auto"}}]}},{"type":"object","name":"ToolProxy","id":"p1097","attributes":{"tools":[{"type":"object","name":"BoxZoomTool","id":"p1027","attributes":{"dimensions":"both","overlay":{"type":"object","name":"BoxAnnotation","id":"p1028","attributes":{"syncable":false,"line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","handles":{"type":"object","name":"BoxInteractionHandles","id":"p1034","attributes":{"all":{"type":"object","name":"AreaVisuals","id":"p1033","attributes":{"fill_color":"white","hover_fill_color":"lightgray"}}}}}}}},{"type":"object","name":"BoxZoomTool","id":"p1073","attributes":{"dimensions":"both","overlay":{"type":"object","name":"BoxAnnotation","id":"p1074","attributes":{"syncable":false,"line_color":"black","line_alpha":1.0,"line_width":2,"line_dash":[4,4],"fill_color":"lightgrey","fill_alpha":0.5,"level":"overlay","visible":false,"left":{"type":"number","value":"nan"},"right":{"type":"number","value":"nan"},"top":{"type":"number","value":"nan"},"bottom":{"type":"number","value":"nan"},"left_units":"canvas","right_units":"canvas","top_units":"canvas","bottom_units":"canvas","handles":{"type":"object","name":"BoxInteractionHandles","id":"p1080","attributes":{"all":{"type":"object","name":"AreaVisuals","id":"p1079","attributes":{"fill_color":"white","hover_fill_color":"lightgray"}}}}}}}}]}},{"type":"object","name":"SaveTool","id":"p1098"},{"type":"object","name":"ToolProxy","id":"p1099","attributes":{"tools":[{"type":"object","name":"ResetTool","id":"p1036"},{"type":"object","name":"ResetTool","id":"p1082"}]}},{"type":"object","name":"ToolProxy","id":"p1100","attributes":{"tools":[{"type":"object","name":"HelpTool","id":"p1037"},{"type":"object","name":"HelpTool","id":"p1083"}]}}]}},"children":[[{"type":"object","name":"Figure","id":"p1003","attributes":{"width":400,"height":400,"x_range":{"type":"object","name":"DataRange1d","id":"p1004"},"y_range":{"type":"object","name":"DataRange1d","id":"p1005"},"x_scale":{"type":"object","name":"LinearScale","id":"p1013"},"y_scale":{"type":"object","name":"LinearScale","id":"p1014"},"title":{"type":"object","name":"Title","id":"p1006","attributes":{"text":"Predicted log_uar_mean_mean_predicted"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p1044","attributes":{"data_source":{"type":"object","name":"ColumnDataSource","id":"p1038","attributes":{"selected":{"type":"object","name":"Selection","id":"p1039","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p1040"},"data":{"type":"map","entries":[["top",{"type":"ndarray","array":{"type":"bytes","data":"IPle8xx7hz8q+V7zHHt3P+A6h7ZVnJE/2DqHtlWcoT8l+V7zHHuXPwAAAAAAAAAA2DqHtlWckT8q+V7zHHunP01LUeejJLA/aiq9hQcUsz8g+V7zHHunPyr5XvMce6c/TUtR56MksD9dtzYw5Fm9PwanbP+V0b4/dLc2MORZvT9yKr2FBxTDPzwiWG3gz8M/O9jKkYBqyj8Y0GV5WSbLP+A6h7ZVnNE/oo1bsH6l1T+rZGI2u1DZPyr5XvMce9c/V6aK+fNx0z/z8Pna9TbYP0V9kX8wHdc/xDqHtlWc0T8Gp2z/ldHOP9CeB+dujc8/Bqds/5XRzj9hAcQLRL/GPz6v0Re9Fc4/PCJYbeDP0z9Xpor583HTP+LHAGEy4ss/NEtR56MksD8q+V7zHHuXPyr5XvMce4c/Kvle8xx7hz8="},"shape":[40],"dtype":"float64","order":"little"}],["left",{"type":"ndarray","array":{"type":"bytes","data":"h8+MNKeh+L8itiaj6xb2v76cwBEwjPO/WoNagHQB8b/q0+jdce3svyGhHLv61+e/WG5QmIPC4r8cdwjrGFrbv4wRcKUqL9G/8K9ef/EQvL/AzAUujzWpP1g+slZAo8o/vITxcI581z8m9URbvtPgP/InEX416eU/ulrdoKz+6j/BxtThEQrwPyXgOnPNlPI/ifmgBIkf9T/vEgeWRKr3P1MsbScANfo/t0XTuLu//D8dXzlKd0r/P0C8z22Z6gBA8siCNvcvAkCk1TX/VHUDQFbi6MeyugRACO+bkBAABkC8+05ZbkUHQG4IAiLMighAIBW16inQCUDSIWizhxULQIQuG3zlWgxANjvOREOgDUDoR4ENoeUOQE0qGmt/FRBAprBzTy64EEAAN80z3VoRQFm9JhiM/RFAskOA/DqgEkA="},"shape":[40],"dtype":"float64","order":"little"}],["right",{"type":"ndarray","array":{"type":"bytes","data":"IrYmo+sW9r++nMARMIzzv1qDWoB0AfG/6tPo3XHt7L8hoRy7+tfnv1huUJiDwuK/HHcI6xha27+MEXClKi/Rv/CvXn/xELy/wMwFLo81qT9YPrJWQKPKP7yE8XCOfNc/JvVEW77T4D/yJxF+NenlP7pa3aCs/uo/wcbU4REK8D8l4DpzzZTyP4n5oASJH/U/7xIHlkSq9z9TLG0nADX6P7dF07i7v/w/HV85SndK/z9AvM9tmeoAQPLIgjb3LwJApNU1/1R1A0BW4ujHsroEQAjvm5AQAAZAvPtOWW5FB0BuCAIizIoIQCAVteop0AlA0iFos4cVC0CELht85VoMQDY7zkRDoA1A6EeBDaHlDkBNKhprfxUQQKawc08uuBBAADfNM91aEUBZvSYYjP0RQLJDgPw6oBJAC8rZ4OlCE0A="},"shape":[40],"dtype":"float64","order":"little"}]]}}},"view":{"type":"object","name":"CDSView","id":"p1045","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p1046"}}},"glyph":{"type":"object","name":"Quad","id":"p1041","attributes":{"left":{"type":"field","field":"left"},"right":{"type":"field","field":"right"},"bottom":{"type":"value","value":0},"top":{"type":"field","field":"top"},"fill_color":{"type":"value","value":"lightblue"}}},"nonselection_glyph":{"type":"object","name":"Quad","id":"p1042","attributes":{"left":{"type":"field","field":"left"},"right":{"type":"field","field":"right"},"bottom":{"type":"value","value":0},"top":{"type":"field","field":"top"},"line_alpha":{"type":"value","value":0.1},"fill_color":{"type":"value","value":"lightblue"},"fill_alpha":{"type":"value","value":0.1},"hatch_alpha":{"type":"value","value":0.1}}},"muted_glyph":{"type":"object","name":"Quad","id":"p1043","attributes":{"left":{"type":"field","field":"left"},"right":{"type":"field","field":"right"},"bottom":{"type":"value","value":0},"top":{"type":"field","field":"top"},"line_alpha":{"type":"value","value":0.2},"fill_color":{"type":"value","value":"lightblue"},"fill_alpha":{"type":"value","value":0.2},"hatch_alpha":{"type":"value","value":0.2}}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p1012","attributes":{"tools":[{"id":"p1025"},{"id":"p1026"},{"id":"p1027"},{"type":"object","name":"SaveTool","id":"p1035"},{"id":"p1036"},{"id":"p1037"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p1020","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1021","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1022"},"axis_label":"$$P(x)$$","axis_label_text_font":"Bitstream Charter","axis_label_text_font_size":"14pt","major_label_policy":{"type":"object","name":"AllLabels","id":"p1023"},"major_label_text_font":"Bitstream Charter","major_label_text_font_size":"12pt"}}],"below":[{"type":"object","name":"LinearAxis","id":"p1015","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1016","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1017"},"axis_label":"$$\\text{Log Mean UAR }(L/s/\\text{km}^2)$$","axis_label_text_font":"Bitstream Charter","axis_label_text_font_size":"14pt","major_label_policy":{"type":"object","name":"AllLabels","id":"p1018"},"major_label_text_font":"Bitstream Charter","major_label_text_font_size":"12pt"}}],"center":[{"type":"object","name":"Grid","id":"p1019","attributes":{"axis":{"id":"p1015"}}},{"type":"object","name":"Grid","id":"p1024","attributes":{"dimension":1,"axis":{"id":"p1020"}}},{"type":"object","name":"Legend","id":"p1047","attributes":{"items":[{"type":"object","name":"LegendItem","id":"p1048","attributes":{"label":{"type":"value","value":""},"renderers":[{"id":"p1044"}]}}]}}]}},0,0],[{"type":"object","name":"Figure","id":"p1049","attributes":{"width":400,"height":400,"x_range":{"type":"object","name":"DataRange1d","id":"p1050"},"y_range":{"type":"object","name":"DataRange1d","id":"p1051"},"x_scale":{"type":"object","name":"LinearScale","id":"p1059"},"y_scale":{"type":"object","name":"LinearScale","id":"p1060"},"title":{"type":"object","name":"Title","id":"p1052","attributes":{"text":"Predicted log_uar_std_mean_predicted"}},"renderers":[{"type":"object","name":"GlyphRenderer","id":"p1090","attributes":{"data_source":{"type":"object","name":"ColumnDataSource","id":"p1084","attributes":{"selected":{"type":"object","name":"Selection","id":"p1085","attributes":{"indices":[],"line_indices":[]}},"selection_policy":{"type":"object","name":"UnionRenderers","id":"p1086"},"data":{"type":"map","entries":[["top",{"type":"ndarray","array":{"type":"bytes","data":"8FgmWx7mqT+zwlzElmzTPw0kiybiIt0/iPYWWM014j+qih6tSbvsPxJAKrKIe/g/crwW/3SQ/z+uUCwK6hgBQEDW80gQ9f4/Cnamh8o48z+jwJqCi3jnP4739/jSL+A/x43Bj1qp1j/0j4PRZZ3SP/tYJlse5sk/x43Bj1qptj+PiT0MRMHOP7vCXMSWbLM/3I3Bj1qptj/kWCZbHuapPwAAAAAAAAAAAAAAAAAAAAARWSZbHuaZP+RYJlse5pk/q8JcxJZsoz8RWSZbHuaJP+RYJlse5pk/5FgmWx7miT/kWCZbHuaZPwAAAAAAAAAA5FgmWx7miT8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAORYJlse5ok/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5FgmWx7miT8="},"shape":[40],"dtype":"float64","order":"little"}],["left",{"type":"ndarray","array":{"type":"bytes","data":"TL8rH9Wy4j83v7WhzwDlPyK/PyTKTuc/Db/JpsSc6T/4vlMpv+rrP+O+3au5OO4/Z98zF1pD8D9c33hYV2rxP1LfvZlUkfI/SN8C21G48z8930ccT9/0PzLfjF1MBvY/KN/Rnkkt9z8e3xbgRlT4PxPfWyFEe/k/CN+gYkGi+j/+3uWjPsn7P/TeKuU78Pw/6d5vJjkX/j/e3rRnNj7/P2rvfNSZMgBAZW8fdRjGAEBg78EVl1kBQFpvZLYV7QFAVe8GV5SAAkBQb6n3EhQDQErvS5iRpwNARW/uOBA7BEBA75DZjs4EQDtvM3oNYgVANe/VGoz1BUAwb3i7CokGQCvvGlyJHAdAJm+9/AewB0Ah71+dhkMIQBtvAj4F1whAFu+k3oNqCUARb0d/Av4JQAvv6R+BkQpABm+MwP8kC0A="},"shape":[40],"dtype":"float64","order":"little"}],["right",{"type":"ndarray","array":{"type":"bytes","data":"N7+1oc8A5T8ivz8kyk7nPw2/yabEnOk/+L5TKb/q6z/jvt2ruTjuP2ffMxdaQ/A/XN94WFdq8T9S372ZVJHyP0jfAttRuPM/Pd9HHE/f9D8y34xdTAb2Pyjf0Z5JLfc/Ht8W4EZU+D8T31shRHv5PwjfoGJBovo//t7loz7J+z/03irlO/D8P+nebyY5F/4/3t60ZzY+/z9q73zUmTIAQGVvH3UYxgBAYO/BFZdZAUBab2S2Fe0BQFXvBleUgAJAUG+p9xIUA0BK70uYkacDQEVv7jgQOwRAQO+Q2Y7OBEA7bzN6DWIFQDXv1RqM9QVAMG94uwqJBkAr7xpciRwHQCZvvfwHsAdAIe9fnYZDCEAbbwI+BdcIQBbvpN6DaglAEW9HfwL+CUAL7+kfgZEKQAZvjMD/JAtAAe8uYX64C0A="},"shape":[40],"dtype":"float64","order":"little"}]]}}},"view":{"type":"object","name":"CDSView","id":"p1091","attributes":{"filter":{"type":"object","name":"AllIndices","id":"p1092"}}},"glyph":{"type":"object","name":"Quad","id":"p1087","attributes":{"left":{"type":"field","field":"left"},"right":{"type":"field","field":"right"},"bottom":{"type":"value","value":0},"top":{"type":"field","field":"top"},"fill_color":{"type":"value","value":"lightblue"}}},"nonselection_glyph":{"type":"object","name":"Quad","id":"p1088","attributes":{"left":{"type":"field","field":"left"},"right":{"type":"field","field":"right"},"bottom":{"type":"value","value":0},"top":{"type":"field","field":"top"},"line_alpha":{"type":"value","value":0.1},"fill_color":{"type":"value","value":"lightblue"},"fill_alpha":{"type":"value","value":0.1},"hatch_alpha":{"type":"value","value":0.1}}},"muted_glyph":{"type":"object","name":"Quad","id":"p1089","attributes":{"left":{"type":"field","field":"left"},"right":{"type":"field","field":"right"},"bottom":{"type":"value","value":0},"top":{"type":"field","field":"top"},"line_alpha":{"type":"value","value":0.2},"fill_color":{"type":"value","value":"lightblue"},"fill_alpha":{"type":"value","value":0.2},"hatch_alpha":{"type":"value","value":0.2}}}}}],"toolbar":{"type":"object","name":"Toolbar","id":"p1058","attributes":{"tools":[{"id":"p1071"},{"id":"p1072"},{"id":"p1073"},{"type":"object","name":"SaveTool","id":"p1081"},{"id":"p1082"},{"id":"p1083"}]}},"toolbar_location":null,"left":[{"type":"object","name":"LinearAxis","id":"p1066","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1067","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1068"},"axis_label":"$$P(x)$$","axis_label_text_font":"Bitstream Charter","axis_label_text_font_size":"14pt","major_label_policy":{"type":"object","name":"AllLabels","id":"p1069"},"major_label_text_font":"Bitstream Charter","major_label_text_font_size":"12pt"}}],"below":[{"type":"object","name":"LinearAxis","id":"p1061","attributes":{"ticker":{"type":"object","name":"BasicTicker","id":"p1062","attributes":{"mantissas":[1,2,5]}},"formatter":{"type":"object","name":"BasicTickFormatter","id":"p1063"},"axis_label":"$$\\text{Log SD UAR }(L/s/\\text{km}^2)$$","axis_label_text_font":"Bitstream Charter","axis_label_text_font_size":"14pt","major_label_policy":{"type":"object","name":"AllLabels","id":"p1064"},"major_label_text_font":"Bitstream Charter","major_label_text_font_size":"12pt"}}],"center":[{"type":"object","name":"Grid","id":"p1065","attributes":{"axis":{"id":"p1061"}}},{"type":"object","name":"Grid","id":"p1070","attributes":{"dimension":1,"axis":{"id":"p1066"}}},{"type":"object","name":"Legend","id":"p1093","attributes":{"items":[{"type":"object","name":"LegendItem","id":"p1094","attributes":{"label":{"type":"value","value":""},"renderers":[{"id":"p1090"}]}}]}}]}},0,1]]}}]}};
  const render_items = [{"docid":"124e5b31-bf2d-4cbc-bb0e-9a1d3a8696cd","roots":{"p1102":"d9190cac-0b45-4e70-a1df-029eeffbc492"},"root_ids":["p1102"]}];
  void root.Bokeh.embed.embed_items_notebook(docs_json, render_items);
  }
  if (root.Bokeh !== undefined) {
    embed_document(root);
  } else {
    let attempts = 0;
    const timer = setInterval(function(root) {
      if (root.Bokeh !== undefined) {
        clearInterval(timer);
        embed_document(root);
      } else {
        attempts++;
        if (attempts > 100) {
          clearInterval(timer);
          console.log("Bokeh: ERROR: Unable to run BokehJS code because BokehJS library is missing");
        }
      }
    }, 10, root)
  }
})(window);</script></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">FDCEstimatorRunner</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stn_id</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">methods</span><span class="p">,</span> <span class="n">k_nearest</span><span class="p">,</span> <span class="n">parametric_target_cols</span><span class="p">,</span> <span class="n">estimator_classes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span> <span class="o">=</span> <span class="n">stn_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">methods</span> <span class="o">=</span> <span class="n">methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span> <span class="o">=</span> <span class="n">k_nearest</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parametric_target_cols</span> <span class="o">=</span> <span class="n">parametric_target_cols</span>
        <span class="c1"># self._check_min_overlap()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_results_folders</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_readme</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ESTIMATOR_CLASSES</span> <span class="o">=</span> <span class="n">estimator_classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prior_strength</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">prior_strength</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_results_folders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># create a results foder for each method if it doesn&#39;t exist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;results&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;fdc_estimation_results&#39;</span><span class="p">,)</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">methods</span><span class="p">:</span>
            <span class="n">method_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results_folder</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">method_folder</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">method_folder</span><span class="p">)</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_readme</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># create a readme file in the results folder to list constraints</span>
        <span class="n">readme_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results_folder</span><span class="p">,</span> <span class="s1">&#39;README.txt&#39;</span><span class="p">)</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">readme_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;This folder contains the results of the FDC estimation.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Methods evaluated: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">methods</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># add the concurrency constraint and number of stations represented in the network</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">official_ids</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">LSTM_concurrent_network</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Uses only stations within Daymet input period of record / LSTM results: N=</span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s1"> stations in the network.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Global start date on streamflow data: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">global_start_date</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Uses all available network stations in the BCUB region (1950-2024): N=</span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s1"> stationsin the network.&#39;</span><span class="p">)</span>
                

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_reference_distributions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kde</span> <span class="o">=</span> <span class="n">KDEEstimator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_pdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">baseline_pmf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline_pmf</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_save_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

 
    <span class="k">def</span><span class="w"> </span><span class="nf">run_selected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># check the minimum number of years of overlap for all stations in self.ctx.overlap_dict</span>
        
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">methods</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results_folder</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span><span class="si">}</span><span class="s1">_fdc_results.json&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result_file</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">StationData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">k_nearest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">parametric_target_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parametric_target_cols</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load_reference_distributions</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">EstimatorClass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ESTIMATOR_CLASSES</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
                <span class="n">estimator</span> <span class="o">=</span> <span class="n">EstimatorClass</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
                <span class="p">)</span>                
                <span class="n">eval_metrics</span> <span class="o">=</span> <span class="n">EvaluationMetrics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">run_estimators</span><span class="p">(</span>
                    <span class="n">eval_metrics</span><span class="o">=</span><span class="n">eval_metrics</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_save_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> estimator failed for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stn_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ParametricFDCEstimator</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">target_stn</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># super().__init__(*args, **kwargs)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span> <span class="o">=</span> <span class="n">target_stn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="c1"># self.data = data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">predicted_param_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_lognorm_pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">pdf</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
        <span class="n">pmf</span> <span class="o">=</span> <span class="n">pdf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>
        <span class="n">pmf</span> <span class="o">/=</span> <span class="n">pmf</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pmf</span><span class="p">,</span> <span class="n">pdf</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_GEV_pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="c1"># assert values are within the valid range for GEV</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">+</span> <span class="mf">1e-12</span><span class="p">)</span>  <span class="c1"># clip xi to avoid numerical issues</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>  <span class="c1"># ensure sigma is positive</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="n">genextreme</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">pdf</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
        <span class="n">pmf</span> <span class="o">=</span> <span class="n">pdf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>
        <span class="n">pmf</span> <span class="o">/=</span> <span class="n">pmf</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># normalize raw PMF</span>
        <span class="k">return</span> <span class="n">pmf</span><span class="p">,</span> <span class="n">pdf</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_estimate_from_mle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">log_mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">][</span><span class="s1">&#39;log_uar_mean_actual&#39;</span><span class="p">]</span>
        <span class="n">log_sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">][</span><span class="s1">&#39;log_uar_std_actual&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_lognorm_pmf</span><span class="p">(</span><span class="n">log_mu</span><span class="p">,</span> <span class="n">log_sigma</span><span class="p">)</span>


    <span class="c1"># def _estimate_from_observed_lmoments_gev(self):</span>
    <span class="c1">#     # compute the GEV parameters from the L-moments</span>
    <span class="c1">#     xi = self.data.LN_param_dict[&#39;logx_lmom_xi&#39;][self.target_stn][&#39;actual&#39;]</span>
    <span class="c1">#     loc = self.data.LN_param_dict[&#39;logx_lmom_loc&#39;][self.target_stn][&#39;actual&#39;]</span>
    <span class="c1">#     scale = self.data.LN_param_dict[&#39;logx_lmom_scale&#39;][self.target_stn][&#39;actual&#39;]</span>
    <span class="c1">#     return self._compute_GEV_pmf(xi, loc, scale)</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_estimate_from_predicted_log_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">][</span><span class="s1">&#39;log_uar_mean_mean_predicted&#39;</span><span class="p">]</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">][</span><span class="s1">&#39;log_uar_std_mean_predicted&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_lognorm_pmf</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
        
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_estimate_from_predicted_linear_mom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mean_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">][</span><span class="s1">&#39;uar_mean_mean_predicted&#39;</span><span class="p">]</span>
        <span class="n">sd_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">][</span><span class="s1">&#39;uar_std_mean_predicted&#39;</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">sd_x</span> <span class="o">/</span> <span class="n">mean_x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mean_x</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">v</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_lognorm_pmf</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_estimate_LN_from_randomly_drawn_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># randomly draw from the predicted parameters</span>
        <span class="n">random_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_df</span><span class="p">))</span>
        <span class="n">random_stn_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">random_idx</span><span class="p">]</span>
        <span class="n">mu_random</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="n">random_stn_idx</span><span class="p">][</span><span class="s1">&#39;log_uar_mean_mean_predicted&#39;</span><span class="p">]</span>
        <span class="n">sigma_random</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_param_dict</span><span class="p">[</span><span class="n">random_stn_idx</span><span class="p">][</span><span class="s1">&#39;log_uar_std_mean_predicted&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_lognorm_pmf</span><span class="p">(</span><span class="n">mu_random</span><span class="p">,</span> <span class="n">sigma_random</span><span class="p">)</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">run_estimators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_metrics</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">fns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_from_mle</span><span class="p">,</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_from_predicted_log_params</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_from_predicted_linear_mom</span><span class="p">,</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_LN_from_randomly_drawn_params</span><span class="p">,</span>
            <span class="c1"># self._estimate_from_observed_lmoments_gev,</span>
            <span class="c1"># self._estimate_from_predicted_lmoments_gev, </span>
            <span class="c1"># self._estimate_LMOM_gev_from_randomly_drawn_params</span>
            <span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;MLE&#39;</span><span class="p">,</span> <span class="s1">&#39;PredictedLog&#39;</span><span class="p">,</span> <span class="s1">&#39;PredictedMOM&#39;</span><span class="p">,</span> <span class="s1">&#39;RandomDraw&#39;</span><span class="p">,</span> 
                  <span class="c1">#&#39;ObsLMomentsGEV&#39;, &#39;PredictedLMomentsGEV&#39;, &#39;LMomentsGEVRandomDraw&#39;,</span>
                  <span class="p">]</span>
        <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fns</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
            <span class="n">pmf</span><span class="p">,</span> <span class="n">pdf</span> <span class="o">=</span> <span class="n">fn</span><span class="p">()</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">pmf_posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_posterior_with_laplace_prior</span><span class="p">(</span><span class="n">pmf</span><span class="p">)</span>            
            <span class="k">if</span> <span class="s1">&#39;Moments&#39;</span> <span class="ow">in</span> <span class="n">label</span><span class="p">:</span>
                <span class="c1"># assert no nan values in the pmf</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pmf</span><span class="p">)),</span> <span class="sa">f</span><span class="s1">&#39;PMF contains NaN values for </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">pmf</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>

            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;pmf_posterior&#39;</span><span class="p">:</span> <span class="n">pmf_posterior</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="s1">&#39;pmf&#39;</span><span class="p">:</span> <span class="n">pmf</span><span class="o">.</span><span class="n">tolist</span><span class="p">()}</span>

            <span class="n">estimation_metrics</span> <span class="o">=</span> <span class="n">eval_metrics</span><span class="o">.</span><span class="n">_evaluate_fdc_metrics_from_pmf</span><span class="p">(</span><span class="n">pmf_posterior</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;eval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">estimation_metrics</span>

            <span class="c1"># compute the bias</span>
            <span class="n">bias_metrics</span> <span class="o">=</span> <span class="n">eval_metrics</span><span class="o">.</span><span class="n">_evaluate_fdc_metrics_from_pmf</span><span class="p">(</span><span class="n">pmf_posterior</span><span class="p">,</span> <span class="n">pmf</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;bias&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bias_metrics</span>
                
        <span class="c1"># compute the bias from the eps</span>
        <span class="k">return</span> <span class="n">results</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">LSTMFDCEstimator</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">target_stn</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># super().__init__(*args, **kwargs)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span> <span class="o">=</span> <span class="n">target_stn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="c1"># self.data = data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LSTM_forcings_folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">LSTM_forcings_folder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LSTM_ensemble_result_folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">LSTM_ensemble_result_folder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_ensemble_result</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_for_complete_years</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim_cols</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;streamflow_sim_&#39;</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kde</span> <span class="o">=</span> <span class="n">KDEEstimator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span><span class="p">)</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_load_ensemble_result</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">LSTM_ensemble_result_folder</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">_ensemble.csv&#39;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span>
        <span class="c1"># rename &#39;Unnamed: 0&#39; to &#39;time&#39; and set to index</span>
        <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Unnamed: 0&#39;</span><span class="p">:</span> <span class="s1">&#39;time&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>
        <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_filter_for_complete_years</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Convert to datetime only if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">date_column</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">date_column</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">date_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">date_column</span><span class="p">])</span>

        <span class="c1"># Filter out missing values first</span>
        <span class="n">valid_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>

        <span class="c1"># Extract year and month</span>
        <span class="n">valid_data</span><span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_data</span><span class="p">[</span><span class="n">date_column</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span>
        <span class="n">valid_data</span><span class="p">[</span><span class="s1">&#39;month&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_data</span><span class="p">[</span><span class="n">date_column</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span>
        <span class="n">valid_data</span><span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_data</span><span class="p">[</span><span class="n">date_column</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">day</span>
        
        <span class="c1"># Count total and missing days per year-month group</span>
        <span class="n">month_counts</span> <span class="o">=</span> <span class="n">valid_data</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">])[</span><span class="s1">&#39;day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span>
        
        <span class="c1"># Identify complete months (at least 20 observations)</span>
        <span class="n">complete_months</span> <span class="o">=</span> <span class="p">(</span><span class="n">month_counts</span> <span class="o">&gt;=</span> <span class="mi">20</span><span class="p">)</span>

        <span class="c1"># count how many complete months per year</span>
        <span class="n">complete_month_counts</span> <span class="o">=</span> <span class="n">complete_months</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        
        <span class="n">complete_years</span> <span class="o">=</span> <span class="n">complete_month_counts</span><span class="p">[</span><span class="n">complete_month_counts</span> <span class="o">==</span> <span class="mi">12</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complete_years</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">complete_years</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="n">valid_data</span> <span class="o">=</span> <span class="n">valid_data</span><span class="p">[</span><span class="n">valid_data</span><span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">complete_years</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># drop the year column</span>
        <span class="k">return</span> <span class="n">valid_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">,</span> <span class="s1">&#39;day&#39;</span><span class="p">])</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_load_LSTM_forcing_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># retrieve LSTM forcing data</span>
        <span class="c1"># read the forcing data from the LSTM forcing file</span>
        <span class="c1"># and return a dataframe with the same index as the LSTM results</span>
        <span class="n">ldf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">met_forcings_folder</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">_forcing.csv&#39;</span><span class="p">))</span>
        <span class="n">ldf</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Unnamed: 0&#39;</span><span class="p">:</span> <span class="s1">&#39;time&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ldf</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">ldf</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>
        <span class="n">ldf</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ldf</span> <span class="o">=</span> <span class="n">ldf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stn_df</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        <span class="c1"># convert to unit area runoff (L/s/km2)</span>
        <span class="n">ldf</span><span class="p">[</span><span class="s1">&#39;uar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">ldf</span><span class="p">[</span><span class="s1">&#39;discharge&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_da</span>
        <span class="k">return</span> <span class="n">ldf</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_plot_pmfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pmf_time</span><span class="p">,</span> <span class="n">pmf_freq</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">):</span>
        <span class="c1"># plot using bokeh</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="n">pmf_time</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;Time Ensemble&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="n">line_dash</span><span class="p">)</span>
        <span class="c1"># f.line(self.data.baseline_log_grid, pmf1, line_width=2, color=&#39;red&#39;, legend_label=&#39;T_MeanLinEns PMF&#39;, line_dash=line_dash)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="n">pmf_freq</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;purple&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;Frequency Ensemble&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="n">line_dash</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;Observed&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="n">line_dash</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="s1">&#39;Log UAR (L/s/km2)&#39;</span>
        <span class="n">f</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="s1">&#39;PMF&#39;</span>
        <span class="n">f</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="s1">&#39;top_left&#39;</span>
        <span class="n">f</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">background_fill_alpha</span> <span class="o">=</span> <span class="mf">0.25</span>
        <span class="n">f</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">click_policy</span> <span class="o">=</span> <span class="s1">&#39;hide&#39;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">dpf</span><span class="o">.</span><span class="n">format_fig_fonts</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
        <span class="n">show</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_time_ensemble_pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_cols</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">temporal_ensemble_log</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># this is still in log space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temporal_ensemble</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">temporal_ensemble_log</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">pmf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kde</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">temporal_ensemble</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">target_da</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">pmf_posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_posterior_with_laplace_prior</span><span class="p">(</span><span class="n">pmf</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pmf</span><span class="p">,</span> <span class="n">pmf_posterior</span><span class="p">)</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_frequency_ensemble_pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_cols</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">data</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># compute the frequency ensemble PMF</span>
        <span class="c1"># initialize a len(data) x n_sim_cols array</span>
        <span class="n">pmfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kde</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">target_da</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_cols</span>
        <span class="p">])</span>
        <span class="c1"># average the pmfs over the ensemble </span>
        <span class="n">pmf</span> <span class="o">=</span> <span class="n">pmfs</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pmf</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;len(pmfs) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">pmfs</span><span class="p">)</span><span class="si">}</span><span class="s1"> != len(baseline_log_grid) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span> 
        <span class="n">_</span><span class="p">,</span> <span class="n">pmf_posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_posterior_with_laplace_prior</span><span class="p">(</span><span class="n">pmf</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pmf</span><span class="p">,</span> <span class="n">pmf_posterior</span><span class="p">)</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_ensemble_distribution_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ensemble_type</span><span class="p">,</span> <span class="n">eval_metrics</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ensemble_type</span> <span class="o">==</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span>
            <span class="n">pmf</span><span class="p">,</span> <span class="n">pmf_posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_time_ensemble_pmf</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">ensemble_type</span> <span class="o">==</span> <span class="s1">&#39;frequency&#39;</span><span class="p">:</span>
            <span class="n">pmf</span><span class="p">,</span> <span class="n">pmf_posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_frequency_ensemble_pmf</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown ensemble type: </span><span class="si">{</span><span class="n">ensemble_type</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="c1"># compute the divergence measures</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;eval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eval_metrics</span><span class="o">.</span><span class="n">_evaluate_fdc_metrics_from_pmf</span><span class="p">(</span><span class="n">pmf_posterior</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;bias&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eval_metrics</span><span class="o">.</span><span class="n">_evaluate_fdc_metrics_from_pmf</span><span class="p">(</span><span class="n">pmf_posterior</span><span class="p">,</span> <span class="n">pmf</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">run_estimators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_metrics</span><span class="p">):</span>
        <span class="c1"># met_forcing = self._load_LSTM_forcing_file()  # Load LSTM forcing data</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ensemble_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;frequency&#39;</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;     Processing </span><span class="si">{</span><span class="n">ensemble_type</span><span class="si">}</span><span class="s1"> ensemble for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_ensemble_distribution_estimate</span><span class="p">(</span><span class="n">ensemble_type</span><span class="p">,</span> <span class="n">eval_metrics</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="n">ensemble_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">results</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">kNNFDCEstimator</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">target_stn</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span> <span class="o">=</span> <span class="n">target_stn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">k_nearest</span>
        <span class="c1"># self.max_to_check_start = data.max_to_check</span>
        <span class="c1"># self.max_to_check = data.max_to_check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_schemes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="c1">#inverse distance and inverse square distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_find_k_nearest_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_type</span><span class="p">,</span> <span class="n">max_to_check</span><span class="p">):</span>
        <span class="c1"># Query the k+1 nearest neighbors because the first neighbor is the target point itself</span>
        <span class="n">target_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_idx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tree_type</span> <span class="o">==</span> <span class="s1">&#39;spatial_dist&#39;</span><span class="p">:</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">spatial_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">target_idx</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">max_to_check</span><span class="p">)</span>
            <span class="n">distances</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="k">elif</span> <span class="n">tree_type</span> <span class="o">==</span> <span class="s1">&#39;attribute_dist&#39;</span><span class="p">:</span>
            <span class="c1"># Example query: Find the nearest neighbors for the first point</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">attribute_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">normalized_attr_values</span><span class="p">[</span><span class="n">target_idx</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">max_to_check</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;tree type not identified, must be one of spatial_dist, or attribute_dist.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Remove target (self) from the results</span>
        <span class="n">self_index</span> <span class="o">=</span> <span class="n">target_idx</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">!=</span> <span class="n">self_index</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">indices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_effective_k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">max_k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">T</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">max_k</span> <span class="o">=</span> <span class="n">max_k</span> <span class="ow">or</span> <span class="n">K</span>

        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">sorted_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">row_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">T</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">effective_k</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mean_furthest</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ks</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">sorted_idx</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">nan_mask</span><span class="p">[</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">valid_count</span> <span class="o">=</span> <span class="n">valid</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">effective_k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valid_count</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
            <span class="n">furthest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">mean_furthest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">furthest_idx</span><span class="p">[</span><span class="n">valid_count</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">valid_count</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;effective_k&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">effective_k</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="s1">&#39;mean_furthest_idx&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">mean_furthest</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">},</span> <span class="n">index</span><span class="o">=</span><span class="n">ks</span><span class="p">)</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_query_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">id1</span><span class="p">,</span> <span class="n">id2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Query distance between two points in a tree using official_id.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">id1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_idx</span> <span class="ow">or</span> <span class="n">id2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_idx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;One or both IDs (</span><span class="si">{</span><span class="n">id1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">id2</span><span class="si">}</span><span class="s2">) not found.&quot;</span><span class="p">)</span>
    
        <span class="c1"># Get indices from ID mapping</span>
        <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_idx</span><span class="p">[</span><span class="n">id1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">id_to_idx</span><span class="p">[</span><span class="n">id2</span><span class="p">]</span>
        <span class="c1"># Query the distance</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index2</span><span class="p">])</span>  <span class="c1"># Euclidean distance</span>
        <span class="k">return</span> <span class="n">distance</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_neighbor</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process a single neighbor to retrieve its data and compute the number of complete years.</span>
<span class="sd">        This function is designed to be used with multiprocessing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nbr_id</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">retrieve_fn</span><span class="p">,</span> <span class="n">find_complete_fn</span> <span class="o">=</span> <span class="n">args</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">retrieve_fn</span><span class="p">(</span><span class="n">nbr_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">or</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="n">proxy_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">nbr_id</span><span class="si">}</span><span class="s1">_uar&#39;</span><span class="p">]]</span>
            <span class="n">complete_years</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">find_complete_fn</span><span class="p">(</span><span class="n">proxy_df</span><span class="p">))</span>
            <span class="n">n_years</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">complete_years</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">nbr_id</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">n_years</span><span class="p">,</span> <span class="n">proxy_df</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to process </span><span class="si">{</span><span class="n">nbr_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_retrieve_nearest_nbr_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_type</span><span class="p">):</span>
        <span class="n">MAX_CHECK</span> <span class="o">=</span> <span class="mi">700</span>
        <span class="n">REQUIRED_GOOD</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="c1"># Get the index of the target station</span>
        
        <span class="c1"># Query once for all potential neighbors</span>
        <span class="n">nbr_idxs</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_k_nearest_neighbors</span><span class="p">(</span><span class="n">tree_type</span><span class="p">,</span> <span class="n">MAX_CHECK</span><span class="p">)</span>
        <span class="n">nbr_ids</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">idx_to_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nbr_idxs</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">idx_to_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">]</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nbr_idxs</span><span class="p">,</span> <span class="n">dists</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">idx_to_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">]</span>

        <span class="n">good_nbrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sorted_nbrs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nbr_ids</span><span class="p">,</span> <span class="n">distances</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>        

        <span class="k">for</span> <span class="p">(</span><span class="n">nbr_id</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span> <span class="ow">in</span> <span class="n">sorted_nbrs</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">retrieve_timeseries_discharge</span><span class="p">(</span><span class="n">nbr_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">or</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># Skip bad or empty DataFrames</span>
            <span class="n">proxy_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">nbr_id</span><span class="si">}</span><span class="s1">_uar&#39;</span><span class="p">]]</span>
            <span class="n">complete_years</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">complete_year_dict</span><span class="p">[</span><span class="n">nbr_id</span><span class="p">]</span>
            <span class="n">n_years</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">complete_years</span><span class="p">)</span>
            <span class="n">good_nbrs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nbr_id</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">n_years</span><span class="p">,</span> <span class="n">proxy_df</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_nbrs</span><span class="p">)</span> <span class="o">==</span> <span class="n">REQUIRED_GOOD</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># Concatenate the timeseries</span>
        <span class="n">nbr_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">good_nbrs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Build metadata DataFrame</span>
        <span class="n">complement_type</span> <span class="o">=</span> <span class="s1">&#39;attribute_dist&#39;</span> <span class="k">if</span> <span class="n">tree_type</span> <span class="o">==</span> <span class="s1">&#39;spatial_dist&#39;</span> <span class="k">else</span> <span class="s1">&#39;spatial_dist&#39;</span>
        <span class="n">complement_tree</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">complement_type</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">_tree&quot;</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">1000</span> <span class="k">if</span> <span class="n">complement_type</span> <span class="o">==</span> <span class="s1">&#39;spatial_dist&#39;</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="n">nbr_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">[</span><span class="n">r</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">good_nbrs</span><span class="p">],</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="s1">&#39;n_years&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">nbr_data</span><span class="p">[</span><span class="n">complement_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">nbr_data</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_distance</span><span class="p">(</span><span class="n">complement_tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_nearest_neighbour_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate nearest neighbours for spatial and attribute selected k-nearest neighbours for both concurrent and asynchronous records.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    ...initializing nearest neighbours with minimum concurrent record.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbr_dfs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="n">tree_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;spatial_dist&#39;</span><span class="p">,</span> <span class="s1">&#39;attribute_dist&#39;</span><span class="p">]:</span>
            <span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieve_nearest_nbr_data</span><span class="p">(</span><span class="n">tree_type</span><span class="p">)</span>
            <span class="n">effective_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_effective_k</span><span class="p">(</span><span class="n">nbr_df</span><span class="p">,</span> <span class="n">max_k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nbr_dfs</span><span class="p">[</span><span class="n">tree_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;nbr_df&#39;</span><span class="p">:</span> <span class="n">nbr_df</span><span class="p">,</span>
                <span class="s1">&#39;nbr_data&#39;</span><span class="p">:</span> <span class="n">nbr_data</span><span class="p">,</span>
                <span class="s1">&#39;effective_k&#39;</span><span class="p">:</span> <span class="n">effective_k</span><span class="p">,</span>
            <span class="p">}</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute normalized inverse (square) distance weights to a given power.&quot;&quot;&quot;</span>

        <span class="n">distances</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distances</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inv_weights</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">**</span> <span class="n">m</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">inv_weights</span> <span class="o">/</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">inv_weights</span><span class="p">)</span>
    
      
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_frequency_ensemble_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdfs</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function computes the weighted ensemble distribution estimates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Normalize distance weights</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  <span class="c1"># Ensure 1D array</span>
            <span class="n">pdf_est</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pdfs</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">@</span> <span class="n">weights</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pdf_est</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pdfs</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>


        <span class="c1"># Check integral before normalization</span>
        <span class="n">pdf_check</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">pdf_est</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
        <span class="n">normalized_pdf</span> <span class="o">=</span> <span class="n">pdf_est</span> <span class="o">/</span> <span class="n">pdf_check</span>
        <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">normalized_pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;ensemble pdf does not integrate to 1: </span><span class="si">{</span><span class="n">pdf_check</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span>
                
        <span class="c1"># Compute PMF</span>
        <span class="n">pmf_est</span> <span class="o">=</span> <span class="n">normalized_pdf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>
        <span class="n">pmf_est</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf_est</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pmf_est</span><span class="p">,</span> <span class="n">pdf_est</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_ensemble_member_distribution_estimates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the ensemble distribution estimates based on the KNN dataframe.</span>
<span class="sd">        &quot;&quot;&quot;</span>    
        <span class="n">pdfs</span><span class="p">,</span> <span class="n">prior_biases</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(),</span> <span class="p">{}</span>
        <span class="c1"># initialize a kde estimator object</span>
        <span class="n">kde</span> <span class="o">=</span> <span class="n">KDEEstimator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span> 
            <span class="c1"># evaluate the laplace on the prediction as a prior</span>
            <span class="c1"># drop the nan values</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
            <span class="n">obs_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;0 values for </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s1">&#39;</span>

            <span class="c1"># compute the pdf and pmf using kde</span>
            <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;NaN values in </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">values</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>

            <span class="n">kde_pmf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">kde</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span>
                <span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">target_da</span>
            <span class="p">)</span>

            <span class="n">prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_prior_from_laplace_fit</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># priors are expressed in pseudo-counts</span>
            <span class="c1"># convert the pdf to counts and apply the prior</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">kde_pmf</span> <span class="o">*</span> <span class="n">obs_count</span> <span class="o">+</span> <span class="n">prior</span>

            <span class="c1"># re-normalize the pmf</span>
            <span class="n">pmf</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            <span class="n">pdf</span> <span class="o">=</span> <span class="n">pmf</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>

            <span class="n">pdf_check</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">)</span>
            <span class="n">pdf</span> <span class="o">/=</span> <span class="n">pdf_check</span>
            <span class="c1"># pdf /= pdf_check</span>
            <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">trapezoid</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;pdf does not integrate to 1 in compute_ensemble_member_distribution_estimates: </span><span class="si">{</span><span class="n">pdf_check</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">pdfs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdf</span>

            <span class="c1"># convert the pdf to pmf</span>
            <span class="n">pmf</span> <span class="o">=</span> <span class="n">pdf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span>
            <span class="n">pmf</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf</span><span class="p">)</span>
            <span class="c1"># assert np.isclose(np.sum(pmf), 1, atol=1e-4), f&#39;pmf does not sum to 1 in compute_ensemble_member_distribution_estimates: {np.sum(pmf):.5f}&#39;</span>
            
            <span class="c1"># compute the bias added by the prior</span>
            <span class="n">prior_biases</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;DKL&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_kld</span><span class="p">(</span><span class="n">kde_pmf</span><span class="p">,</span> <span class="n">pmf</span><span class="p">),</span> <span class="s1">&#39;EMD&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_emd</span><span class="p">(</span><span class="n">kde_pmf</span><span class="p">,</span> <span class="n">pmf</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">pdfs</span><span class="p">,</span> <span class="n">prior_biases</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_frequency_ensemble_distributions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For asynchronous comparisons, we estimate pdfs for ensemble members, then compute the mean in the time domain</span>
<span class="sd">        to represent the FDC simulation.  We do not do temporal averaging in this case.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">knn_df_all</span> <span class="o">=</span> <span class="n">nbr_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">knn_data_all</span> <span class="o">=</span> <span class="n">nbr_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">proxy_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">knn_df_all</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
        <span class="n">frequency_ensemble_pdfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">baseline_pmf_df</span><span class="p">[</span><span class="n">proxy_ids</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">labels</span><span class="p">,</span> <span class="n">pdfs</span><span class="p">,</span> <span class="n">pmfs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">all_distances</span> <span class="o">=</span> <span class="n">knn_data_all</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">all_ids</span> <span class="o">=</span> <span class="n">knn_data_all</span><span class="p">[</span><span class="s1">&#39;official_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># prior_bias_df = pd.DataFrame(prior_bias_dict)</span>
        <span class="k">for</span> <span class="n">wm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_schemes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">distances</span> <span class="o">=</span> <span class="n">all_distances</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>
                <span class="n">nbr_ids</span> <span class="o">=</span> <span class="n">all_ids</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>
                <span class="n">knn_pdfs</span> <span class="o">=</span> <span class="n">frequency_ensemble_pdfs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">_NN_</span><span class="si">{</span><span class="n">distance_type</span><span class="si">}</span><span class="s1">_ID</span><span class="si">{</span><span class="n">wm</span><span class="si">}</span><span class="s1">_freqEnsemble&#39;</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_weights</span><span class="p">(</span><span class="n">wm</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
                <span class="n">pmf_est</span><span class="p">,</span> <span class="n">pdf_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_frequency_ensemble_mean</span><span class="p">(</span><span class="n">knn_pdfs</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">pmf_est</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;pmf_est is None for </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">&#39;</span>
            
                <span class="c1"># compute the mean number of observations (non-nan values) per row</span>
                <span class="n">mean_obs_per_timestep</span> <span class="o">=</span> <span class="n">knn_df_all</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">mean_obs_per_proxy</span> <span class="o">=</span> <span class="n">knn_df_all</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

                <span class="n">_</span><span class="p">,</span> <span class="n">pmf_posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_posterior_with_laplace_prior</span><span class="p">(</span><span class="n">pmf_est</span><span class="p">)</span>
                <span class="nb">eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">eval_metrics</span><span class="o">.</span><span class="n">_evaluate_fdc_metrics_from_pmf</span><span class="p">(</span><span class="n">pmf_posterior</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">)</span>
                <span class="n">bias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">eval_metrics</span><span class="o">.</span><span class="n">_evaluate_fdc_metrics_from_pmf</span><span class="p">(</span><span class="n">pmf_posterior</span><span class="p">,</span> <span class="n">pmf_est</span><span class="p">)</span>
      
                <span class="c1"># compute the frequency-based ensemble pdf estimate</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span> <span class="s1">&#39;n_obs&#39;</span><span class="p">:</span> <span class="n">mean_obs_per_proxy</span><span class="p">,</span>
                    <span class="s1">&#39;mean_obs_per_timestep&#39;</span><span class="p">:</span> <span class="n">mean_obs_per_timestep</span><span class="p">,</span>
                    <span class="s1">&#39;nbrs&#39;</span><span class="p">:</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nbr_ids</span><span class="p">),</span>
                    <span class="s1">&#39;eval&#39;</span><span class="p">:</span> <span class="nb">eval</span><span class="p">,</span>
                    <span class="s1">&#39;bias&#39;</span><span class="p">:</span> <span class="n">bias</span><span class="p">,</span>
                    <span class="p">}</span>
                
                <span class="n">pdfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pdf_est</span><span class="p">))</span>
                <span class="n">pmfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pmf_est</span><span class="p">))</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="c1"># create a dataframe of labels(columns) for each pdf</span>
        <span class="n">knn_pdfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pdfs</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">knn_pmfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pmfs</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># Filter out already existing columns to avoid duplication</span>
        <span class="n">new_pdf_cols</span> <span class="o">=</span> <span class="n">knn_pdfs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">new_pmf_cols</span> <span class="o">=</span> <span class="n">knn_pmfs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="c1"># Concat only new columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="p">,</span> <span class="n">knn_pdfs</span><span class="p">[</span><span class="n">new_pdf_cols</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span><span class="p">,</span> <span class="n">knn_pmfs</span><span class="p">[</span><span class="n">new_pmf_cols</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_delta_spike_pmf_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">single_val</span><span class="p">,</span> <span class="n">log_grid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a spike PMF and compatible PDF centered at the only value in the input.</span>
<span class="sd">        The spike is placed at the nearest log_grid point to log(single_val).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log_val</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">single_val</span><span class="p">)</span>
        <span class="n">spike_idx</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">log_grid</span> <span class="o">-</span> <span class="n">log_val</span><span class="p">))</span>
        
        <span class="n">pmf</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">log_grid</span><span class="p">)</span>
        <span class="n">pmf</span> <span class="o">=</span> <span class="n">pmf</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">spike_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">log_grid</span><span class="p">)</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="n">pmf</span> <span class="o">/</span> <span class="n">dx</span>  <span class="c1"># assign all mass to one bin</span>

        <span class="k">return</span> <span class="n">pmf</span><span class="p">,</span> <span class="n">pdf</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_ensemble_contribution_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
        
        <span class="c1"># Mean number of valid values per row</span>
        <span class="n">mean_valid_per_row</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="c1"># Normalized weights per row, masking NaNs</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">masked_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">weight_sums</span> <span class="o">=</span> <span class="n">masked_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">weight_sums</span><span class="p">[</span><span class="n">weight_sums</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">normalized_weights</span> <span class="o">=</span> <span class="n">masked_weights</span> <span class="o">/</span> <span class="n">weight_sums</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># Average contribution per column across all rows</span>
        <span class="n">mean_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">normalized_weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">effective_n</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">mean_w</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mean_valid_per_row</span><span class="p">,</span> <span class="n">effective_n</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">_weighted_row_mean_ignore_nan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the weighted mean for each row, accounting for NaNs and ensuring that</span>
<span class="sd">        weights are re-normalized based on valid values only. Returns a Series aligned</span>
<span class="sd">        with df.index, as well as ensemble stats.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">masked_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="n">row_weight_sums</span> <span class="o">=</span> <span class="n">masked_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">row_weight_sums</span><span class="p">[</span><span class="n">row_weight_sums</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">normalized_weights</span> <span class="o">=</span> <span class="n">masked_weights</span> <span class="o">/</span> <span class="n">row_weight_sums</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">estimated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">normalized_weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Return as Series aligned with index</span>
        <span class="n">estimated_series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">estimated</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># Also compute stats on weights</span>
        <span class="n">mean_valid_per_row</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">mean_weight_per_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">normalized_weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">effective_k</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">mean_weight_per_col</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">estimated_series</span><span class="p">,</span> <span class="n">mean_valid_per_row</span><span class="p">,</span> <span class="n">effective_k</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_finalize_temporal_ensemble</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">temporal_ensemble_mean</span><span class="p">,</span> <span class="n">nbrs_used</span><span class="p">,</span>
            <span class="n">effective_k</span><span class="p">,</span> <span class="n">mean_valid_per_row</span>
            <span class="p">):</span>

        <span class="c1"># Clip to prevent zero runoff issues</span>
        <span class="n">temporal_ensemble_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
            <span class="n">temporal_ensemble_mean</span><span class="p">,</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mf">1e-4</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">target_da</span><span class="p">,</span> <span class="kc">None</span>
        <span class="p">)</span>

        <span class="c1"># Estimate PDF/PMF using KDE or </span>
        <span class="c1"># add small amount of random noise if there is no variance</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">temporal_ensemble_mean</span><span class="o">.</span><span class="n">values</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">est_pmf</span><span class="p">,</span> <span class="n">est_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta_spike_pmf_pdf</span><span class="p">(</span>
                <span class="n">temporal_ensemble_mean</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">est_pmf</span><span class="p">,</span> <span class="n">est_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_kde</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span>
                <span class="n">temporal_ensemble_mean</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">target_da</span>
            <span class="p">)</span>

        <span class="k">assert</span> <span class="n">est_pmf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;pmf is None for </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">pmf_posterior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_compute_posterior_with_laplace_prior</span><span class="p">(</span><span class="n">est_pmf</span><span class="p">)</span>

        <span class="nb">eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_metrics</span><span class="o">.</span><span class="n">_evaluate_fdc_metrics_from_pmf</span><span class="p">(</span><span class="n">pmf_posterior</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_pmf</span><span class="p">)</span>
        <span class="n">bias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_metrics</span><span class="o">.</span><span class="n">_evaluate_fdc_metrics_from_pmf</span><span class="p">(</span><span class="n">pmf_posterior</span><span class="p">,</span> <span class="n">est_pmf</span><span class="p">)</span>

        <span class="c1"># Store simulation outputs and metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">est_pdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">est_pmf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;nbrs&#39;</span><span class="p">:</span> <span class="n">nbrs_used</span><span class="p">,</span>
            <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span>
            <span class="s1">&#39;n_obs&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">temporal_ensemble_mean</span><span class="p">),</span>
            <span class="s1">&#39;mean_&#39;</span><span class="p">:</span> <span class="n">mean_valid_per_row</span><span class="p">,</span>
            <span class="s1">&#39;mean_nbrs_per_timestep&#39;</span><span class="p">:</span> <span class="n">effective_k</span><span class="p">,</span>  <span class="c1"># rename if clearer</span>
            <span class="s1">&#39;effective_k&#39;</span><span class="p">:</span> <span class="n">effective_k</span><span class="p">,</span>
            <span class="s1">&#39;eval&#39;</span><span class="p">:</span> <span class="nb">eval</span><span class="p">,</span>
            <span class="s1">&#39;bias&#39;</span><span class="p">:</span> <span class="n">bias</span><span class="p">,</span>
        <span class="p">}</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_temporal_ensemble_distributions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">,</span> <span class="n">wm</span><span class="p">,</span> <span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span><span class="p">):</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">nbr_data</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_nearest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">knn_df</span> <span class="o">=</span> <span class="n">nbr_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_stn</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">_NN_</span><span class="si">{</span><span class="n">distance_type</span><span class="si">}</span><span class="s1">_ID</span><span class="si">{</span><span class="n">wm</span><span class="si">}</span><span class="s1">_timeEnsemble&#39;</span>            
            <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_weights</span><span class="p">(</span><span class="n">wm</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">distances</span><span class="p">[:</span><span class="n">k</span><span class="p">])</span>
            <span class="n">temporal_ensemble_mean</span><span class="p">,</span> <span class="n">mean_valid_per_row</span><span class="p">,</span> <span class="n">effective_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_row_mean_ignore_nan</span><span class="p">(</span><span class="n">knn_df</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
            <span class="n">nbrs_used</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">knn_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_finalize_temporal_ensemble</span><span class="p">(</span>
                <span class="n">k</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">temporal_ensemble_mean</span><span class="p">,</span> <span class="n">nbrs_used</span><span class="p">,</span>
                <span class="n">effective_k</span><span class="p">,</span> <span class="n">mean_valid_per_row</span>
            <span class="p">)</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_distribution_estimates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">):</span>

        <span class="n">nbr_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbr_dfs</span><span class="p">[</span><span class="n">distance_type</span><span class="p">][</span><span class="s1">&#39;nbr_df&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">nbr_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbr_dfs</span><span class="p">[</span><span class="n">distance_type</span><span class="p">][</span><span class="s1">&#39;nbr_data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">wm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_schemes</span><span class="p">:</span>
            <span class="c1"># compute the FDC estimate by temporal ensemble mean</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_temporal_ensemble_distributions</span><span class="p">(</span><span class="n">distance_type</span><span class="p">,</span> <span class="n">wm</span><span class="p">,</span> <span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span><span class="p">,)</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="c1"># compute the frequency average ensemble pdfs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_frequency_ensemble_distributions</span><span class="p">(</span><span class="n">nbr_df</span><span class="p">,</span> <span class="n">nbr_data</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">)</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    ...</span><span class="si">{</span><span class="n">distance_type</span><span class="si">}</span><span class="s1"> ID</span><span class="si">{</span><span class="n">wm</span><span class="si">}</span><span class="s1"> took </span><span class="si">{</span><span class="n">t1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">s for temporal ensemble, </span><span class="si">{</span><span class="n">t2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t1</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">s for frequency ensemble.&#39;</span><span class="p">)</span>

        <span class="c1"># Validation</span>
        <span class="n">sim_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">pdf_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">sim_labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">pdf_labels</span><span class="p">)</span>
        
    
    <span class="k">def</span><span class="w"> </span><span class="nf">run_estimators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_metrics</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eval_metrics</span> <span class="o">=</span> <span class="n">eval_metrics</span>                  
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_nearest_neighbour_data</span><span class="p">()</span>
        <span class="c1"># set the baseline pdf by kde</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_kde</span> <span class="o">=</span> <span class="n">KDEEstimator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">baseline_log_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log_dx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;spatial_dist&#39;</span><span class="p">,</span> <span class="s1">&#39;attribute_dist&#39;</span><span class="p">]:</span>        
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_distribution_estimates</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_results</span><span class="p">()</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_make_json_serializable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;tolist&quot;</span><span class="p">):</span>
                <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">output</span>
    
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_format_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pmf_labels</span><span class="p">,</span> <span class="n">pdf_labels</span><span class="p">,</span> <span class="n">sim_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># assert label sets are the same</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">pmf_labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">pdf_labels</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;pmf_labels </span><span class="si">{</span><span class="n">pmf_labels</span><span class="si">}</span><span class="s1"> != pdf_labels </span><span class="si">{</span><span class="n">pdf_labels</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">pmf_labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">sim_labels</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;pmf_labels </span><span class="si">{</span><span class="n">pmf_labels</span><span class="si">}</span><span class="s1"> != sim_labels </span><span class="si">{</span><span class="n">sim_labels</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_simulation_data</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">pmf_labels</span><span class="p">:</span>
            <span class="c1"># add the pmf and pdf in a json serializable format</span>
            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;pmf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_pmfs</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s1">&#39;pdf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knn_pdfs</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_json_serializable</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">label</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">results</span>
        
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="n">target_cols</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;mean_uar&#39;</span><span class="p">,</span> <span class="s1">&#39;sd_uar&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;mean_logx&#39;</span><span class="p">,</span> <span class="s1">&#39;sd_logx&#39;</span><span class="p">,</span> 
<span class="p">]</span>

<span class="c1"># from utils import FDCEstimationContext</span>
<span class="n">attr_df_fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;catchment_attributes_with_runoff_stats.csv&#39;</span><span class="p">)</span>
<span class="n">LSTM_forcings_folder</span> <span class="o">=</span> <span class="s1">&#39;/home/danbot/neuralhydrology/data/BCUB_catchment_mean_met_forcings_20250320&#39;</span>
<span class="n">LSTM_ensemble_result_folder</span> <span class="o">=</span> <span class="s1">&#39;/home/danbot/code/neuralhydrology/data/ensemble_results_20250514&#39;</span>
<span class="n">baseline_distribution_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;results&#39;</span><span class="p">,</span> <span class="s1">&#39;baseline_distributions&#39;</span><span class="p">)</span>
<span class="c1"># parameter_prediction_results_folder = os.path.join(&#39;data&#39;, &#39;parameter_prediction_results&#39;)</span>

<span class="n">methods</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;parametric&#39;</span><span class="p">,</span> <span class="s1">&#39;lstm&#39;</span><span class="p">,</span> <span class="s1">&#39;knn&#39;</span><span class="p">,)</span>
<span class="c1"># methods = (&#39;knn&#39;,)</span>
<span class="n">exclude_pre_1980_data</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># use only stations with data 1980-present concurrent with Daymet</span>
<span class="n">daymet_start_date</span> <span class="o">=</span> <span class="s1">&#39;1950-01-01&#39;</span>  <span class="c1"># default start date for Daymet data</span>
<span class="n">k_nearest</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">if</span> <span class="n">exclude_pre_1980_data</span><span class="p">:</span>
    <span class="n">daymet_start_date</span> <span class="o">=</span> <span class="s1">&#39;1980-01-01&#39;</span>

<span class="n">processed</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">ESTIMATOR_CLASSES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;parametric&#39;</span><span class="p">:</span> <span class="n">ParametricFDCEstimator</span><span class="p">,</span>
    <span class="s1">&#39;lstm&#39;</span><span class="p">:</span> <span class="n">LSTMFDCEstimator</span><span class="p">,</span>
    <span class="s1">&#39;knn&#39;</span><span class="p">:</span> <span class="n">kNNFDCEstimator</span><span class="p">,</span>
    <span class="c1"># add others here</span>
<span class="p">}</span>
<span class="n">input_data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;attr_df_fpath&#39;</span><span class="p">:</span> <span class="n">attr_df_fpath</span><span class="p">,</span>
    <span class="s1">&#39;LSTM_forcings_folder&#39;</span><span class="p">:</span> <span class="n">LSTM_forcings_folder</span><span class="p">,</span>
    <span class="s1">&#39;LSTM_ensemble_result_folder&#39;</span><span class="p">:</span> <span class="n">LSTM_ensemble_result_folder</span><span class="p">,</span>
    <span class="s1">&#39;LSTM_concurrent_network&#39;</span><span class="p">:</span> <span class="n">exclude_pre_1980_data</span><span class="p">,</span>  <span class="c1"># use only stations with data 1980-present concurrent with Daymet</span>
    <span class="s1">&#39;daymet_start_date&#39;</span><span class="p">:</span> <span class="n">daymet_start_date</span><span class="p">,</span>
    <span class="c1"># &#39;parameter_prediction_results_folder&#39;: parameter_prediction_results_folder,</span>
    <span class="s1">&#39;predicted_param_dict&#39;</span><span class="p">:</span> <span class="n">predicted_param_dict</span><span class="p">,</span>
    <span class="s1">&#39;divergence_measures&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;DKL&#39;</span><span class="p">,</span> <span class="s1">&#39;EMD&#39;</span><span class="p">],</span>
    <span class="s1">&#39;baseline_pmf_stations&#39;</span><span class="p">:</span> <span class="n">pmf_stations</span><span class="p">,</span>
    <span class="s1">&#39;eps&#39;</span><span class="p">:</span> <span class="mf">1e-12</span><span class="p">,</span>
    <span class="s1">&#39;min_flow&#39;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">,</span>
    <span class="s1">&#39;n_grid_points&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="mi">12</span><span class="p">,</span>
    <span class="s1">&#39;min_record_length&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="s1">&#39;minimum_days_per_month&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="s1">&#39;parametric_target_cols&#39;</span><span class="p">:</span> <span class="n">target_cols</span><span class="p">,</span>
    <span class="s1">&#39;all_official_ids&#39;</span><span class="p">:</span> <span class="n">station_ids</span><span class="p">,</span>
    <span class="s1">&#39;daymet_concurrent_stations&#39;</span><span class="p">:</span> <span class="n">daymet_concurrent_stations</span><span class="p">,</span>
    <span class="s1">&#39;baseline_distribution_folder&#39;</span><span class="p">:</span> <span class="n">baseline_distribution_folder</span><span class="p">,</span>
    <span class="s1">&#39;prior_strength&#39;</span><span class="p">:</span> <span class="mf">1e-2</span><span class="p">,</span>  <span class="c1"># prior strength for the Laplace fit</span>
<span class="p">}</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">FDCEstimationContext</span><span class="p">(</span><span class="o">**</span><span class="n">input_data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    Using all stations in the catchment data with a baseline PMF (validated): 1097
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    ...overlap dict loaded from data/record_overlap_dict.json
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">traceback</span>

<span class="k">def</span><span class="w"> </span><span class="nf">warn_with_traceback</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">log</span> <span class="o">=</span> <span class="n">file</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;write&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span>
    <span class="n">traceback</span><span class="o">.</span><span class="n">print_stack</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">log</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">warnings</span><span class="o">.</span><span class="n">formatwarning</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">showwarning</span> <span class="o">=</span> <span class="n">warn_with_traceback</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">processed</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
<span class="n">process_fdcs</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">if</span> <span class="n">process_fdcs</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processing FDCs...&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">stn</span> <span class="ow">in</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">official_ids</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">daymet_concurrent_stations</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">stn</span> <span class="o">==</span> <span class="s1">&#39;12414900&#39;</span><span class="p">:</span> <span class="c1"># this station has no data in the LSTM ensemble results</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    ...skipping </span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1"> due to naming issue.&#39;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Estimating FDC for </span><span class="si">{</span><span class="n">stn</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">)</span>
        <span class="n">runner</span> <span class="o">=</span> <span class="n">FDCEstimatorRunner</span><span class="p">(</span><span class="n">stn</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">methods</span><span class="p">,</span> <span class="n">k_nearest</span><span class="p">,</span> <span class="n">target_cols</span><span class="p">,</span> <span class="n">ESTIMATOR_CLASSES</span><span class="p">)</span>
        <span class="n">runner</span><span class="o">.</span><span class="n">run_selected</span><span class="p">()</span>
        <span class="n">processed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="n">elapsed</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span>
            <span class="n">unit_time</span> <span class="o">=</span> <span class="n">elapsed</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Processed </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">official_ids</span><span class="p">)</span><span class="si">}</span><span class="s1"> stations in </span><span class="si">{</span><span class="n">unit_time</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds per station&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="4_Reference_Distributions.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">4. </span>Reference Distributions</p>
      </div>
    </a>
    <a class="right-next"
       href="6_Large_Sample_Results_Comparison.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">6. </span>Large Sample Comparison Results</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#non-parametric-simulation">5.1. Non-Parametric Simulation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#time-based-ensemble">5.1.1. Time-based ensemble</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#frequency-based-ensembles">5.1.2. Frequency-based ensembles</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#notes-on-k-nearest-neighbours">5.2. Notes on k-nearest neighbours</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#summary-set-theoretic-foundations-of-strict-k-nn-concurrency-selection">5.2.1. Summary: Set-Theoretic Foundations of Strict k-NN Concurrency Selection</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#set-theoretic-definition">5.2.1.1. Set-Theoretic Definition</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#related-concepts">5.2.1.2. Related Concepts</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#practical-implication">5.2.1.3. Practical Implication</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#define-a-universal-parametric-prior">5.3. Define a universal parametric prior</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#global-uniform-prior">5.3.1. Global Uniform Prior</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Dan Kovacek
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      Â© Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>